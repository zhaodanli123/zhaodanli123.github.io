<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[css世界——总结大纲]]></title>
    <url>%2F2019%2F08%2F02%2Fcss_world_learn%2F</url>
    <content type="text"><![CDATA[TODO … ❣️]]></content>
      <categories>
        <category>前端</category>
        <category>css</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[nginx使用指南]]></title>
    <url>%2F2019%2F07%2F31%2Fnginx_guide%2F</url>
    <content type="text"><![CDATA[使用指南 nginx反向代理相关文档 By default, the configuration file is named nginx.conf and placed in the directory /usr/local/nginx/conf, /etc/nginx, or /usr/local/etc/nginx Starting, Stopping, and Reloading ConfigurationTo start nginx, run the executable file. Once nginx is started, it can be controlled by invoking the executable with the -s parameter. Use the following syntax: 启动nginx 需要用到sudo 命令，否则会报错：permission denied server location 指南]]></content>
      <categories>
        <category>nginx</category>
      </categories>
      <tags>
        <tag>nginx</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前端测试:unit jest]]></title>
    <url>%2F2019%2F06%2F04%2Funit_jest%2F</url>
    <content type="text"><![CDATA[jest是Facebook的杰作之一，方便各种场景的js代码测试]]></content>
      <categories>
        <category>前端</category>
        <category>单元测试</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>javascript</tag>
        <tag>单元测试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[内外层都有overflow:auto时,滚动条问题]]></title>
    <url>%2F2019%2F05%2F31%2Fjs_q1%2F</url>
    <content type="text"><![CDATA[当div1元素的width || height 小于 内层ul1元素时,内存元素的overflow:auto失效,temp1.html ↓1234567891011121314151617181920212223242526272829303132333435363738&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;内外层双滚动条问题&lt;/title&gt; &lt;style&gt; .div1 &#123; overflow: auto; position: fixed; font-size: 14px; top: 0; bottom: 0; left: 0; right: 0; background: orange; z-index: 100; &#125; .ul1 &#123; width:700px; height:400px; overflow:auto; background:pink; &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div class=&quot;div1&quot;&gt; &lt;ul class=&quot;ul1&quot;&gt; &lt;li&gt;测试1&lt;/li&gt;&lt;li&gt;测试1&lt;/li&gt;&lt;li&gt;测试1&lt;/li&gt;&lt;li&gt;测试1&lt;/li&gt;&lt;li&gt;测试1&lt;/li&gt; &lt;li&gt;测试1&lt;/li&gt;&lt;li&gt;测试1&lt;/li&gt;&lt;li&gt;测试1&lt;/li&gt;&lt;li&gt;测试1&lt;/li&gt;&lt;li&gt;测试1&lt;/li&gt; &lt;li&gt;测试1&lt;/li&gt;&lt;li&gt;测试1&lt;/li&gt;&lt;li&gt;测试1&lt;/li&gt;&lt;li&gt;测试1&lt;/li&gt;&lt;li&gt;测试1&lt;/li&gt; &lt;li&gt;测试1&lt;/li&gt;&lt;li&gt;测试1&lt;/li&gt;&lt;li&gt;测试1&lt;/li&gt;&lt;li&gt;测试1&lt;/li&gt;&lt;li&gt;测试1&lt;/li&gt; &lt;li&gt;测试1&lt;/li&gt;&lt;li&gt;测试1&lt;/li&gt;&lt;li&gt;测试1&lt;/li&gt;&lt;li&gt;测试1&lt;/li&gt;&lt;li&gt;测试1&lt;/li&gt; &lt;li&gt;测试1&lt;/li&gt;&lt;li&gt;测试1&lt;/li&gt;&lt;li&gt;测试1&lt;/li&gt;&lt;li&gt;测试1&lt;/li&gt;&lt;li&gt;测试1&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt; 解决方案:外层容器的width不要与窗口宽度相同实现方法 (缺陷:外层容器没有滚动条，在firefox中会显示滚动条)1234567.div1 &#123; width:110%; overflow-x:hidden; overflow-y:auto; // overflow: auto; // right:0;&#125;]]></content>
      <categories>
        <category>前端</category>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[javascript逗号表达式]]></title>
    <url>%2F2019%2F05%2F28%2Fjs_comma%2F</url>
    <content type="text"><![CDATA[逗号表达式： 一般形式：表达式1，表达式2，表达式3，……表达式n 求解过程：先计算表达式1的值，再计算表达式2的值，......一直计算到表达式n的值。最后整个表达式的值是表达式n的值。 看下面几个例子：123451）x = 8*2, x*4; /*整个表达式为逗号表达式，它的值为64，x的值为16*/2）(x = 8*2, x*4) , x*2; /*整个表达式为逗号表达式，它的值为32，x的值为16*/3）x = (z=5,5*2); /*整个表达式为赋值表达式，它的值为10，z的值为5*/ 请注意：并不是所有的逗号都要看成逗号运算符，如在函数调用时，各个参数是用逗号分隔开的，这里的逗号并不是逗号运算符。如：printf(“%d, %d, %d”, x, y, z); for循环中逗号运算符逗号运算符的常见用法是在for循环的增量表达式中使用。例如：1234var i,j=5,k;for(i=0; i&lt;10; i++,j++) &#123; k = i + j;&#125; 在每次通过循环的结尾时，for语句只允许单个表达式被执行。逗号运算符允许将多个表达式视为单个表达式，因此这两个变量都递增。 逗号运算符与函数调用运算符的冲突在JavaScript中函数调用确实是函数调用运算符。它很特殊，因为其它编程语言资料中从来没有这个叫法。 函数调用运算符将计算它的每一个运算数，第一个运算数指定为函数名（括号前），而括号中的所有运算数的值将传递给这个函数作为参数。 接下来看一个逗号运算符和函数运算符冲突的例子以及解决的方法。12alert(2,5); //2alert((2,5)); //5 由于逗号运算符在JavaScript中的优先级是最低的，因此函数运算符将先于逗号运算符运行，上述代码中第一个alert函数弹出2。 解决方法如第二个alert函数所示，加上括号，保证逗号运算符先运行。 逗号运算符和赋值运算符冲突123var a = 20;var b = ++a, 10;console.log(b); 上述代码报错：由于逗号运算符要求它的运算数为复杂表达式或简单 表达式（如变量或直接量），赋值运算符先于逗号运算符执行，使逗号运算符左边不是一个运算数或表达式，而是含有var关键字的语句，因此报错。解决方法：只需加上括号，即var b = (++a, 10)，保证逗号运算符先执行即可。 再看几个示例，后两个示例略为奇葩。 示例一：1234console.log((0,9)); //9console.log((9,0)); //0if((9,0)) console.log(&quot;no&quot;);if((0,9)) console.log(&quot;yes&quot;); //yes 示例二：交换变量，无需第三个变量12345var a = &apos;a&apos;, b = &apos;b&apos;;//method1a = [b,b=a][0];//method2a = [b][b=a,0]; 分析：a = [b,b=a][0]中，[b,b=a]表示一维数组，[0]表示下标；a = [b][b=a, 0]，其中[b]表示一维数组，[b=a, 0]中按逗号运算符处理，返回0，当做下标。 在这个例子中，我一直将在[b,b=a][0]和[b][b=a, 0]视作二维数组，这不对的。 一维数组形式：[1,2,3][0] //取得值1 二维数组形式：[[1,2,3],[4,5,6]][1][1] //取得值5 不过上述两种数组表示形式很少用。 示例三：简化代码，不过可读性差 12345678if(x) &#123; foo(); return bar();&#125; else &#123; return 1;&#125;// equal to return x ? (foo(), bar()) : 1; 文章转载自 JavaScript逗号运算符]]></content>
      <categories>
        <category>algorithm</category>
      </categories>
      <tags>
        <tag>algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[javascript运算符优先级]]></title>
    <url>%2F2019%2F05%2F28%2Fjs_operator_precedence%2F</url>
    <content type="text"><![CDATA[]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mac快捷键]]></title>
    <url>%2F2019%2F05%2F21%2Fmac_quickkey%2F</url>
    <content type="text"><![CDATA[符号说明⌘：command⌃：control⌥：option⇧：shift↩：enter⌫：delete ⌘ + space =&gt; 切换输入法 shift =&gt; 切换中英 ^ + space =&gt; Spotlight ⇧ + ⌘ + c =&gt; 打开网页控制台 ⌘ + I =&gt; 显示简介 ⇧ + ⌘ + D =&gt; 打开桌面文件夹 ⇧ + ⌘ + N =&gt; 新建文件夹 ⌘ + o =&gt; 打开所选项 ⌘ + 1 =&gt; 以图标显示 ⌘ + 2 =&gt; 以列表显示 ⌘ + 3 =&gt; 以分栏显示 ⌘ + , =&gt; 打开偏好设置 ⌘ + ` =&gt; 循环显示打开的finder窗口 ⇧ + ⌘ + 3 =&gt; 将屏幕捕捉到文件 ⇧ + ⌘ + 4 =&gt; 将所选内容捕捉到文件 ⌥ + ⌘ + F =&gt; 移到搜索栏控件]]></content>
      <categories>
        <category>mac</category>
      </categories>
      <tags>
        <tag>mac</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[charles抓包使用]]></title>
    <url>%2F2019%2F05%2F21%2Fcharles%2F</url>
    <content type="text"><![CDATA[1.charles官方网站 2.charles官方网站工具类 #文章来源：抓包工具Charles的使用教程]]></content>
      <categories>
        <category>前端</category>
        <category>charles</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>charles</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[好文合集]]></title>
    <url>%2F2019%2F05%2F15%2Fgeneration%2F</url>
    <content type="text"><![CDATA[移动端页面分享快照生成总结 5种滚动吸顶实现方式的比较[性能升级版] 从输入 URL 到展现涉及哪些缓存环节(非常详细) 聊一聊前端换肤 「真®全栈之路」Web前端开发的后端指南 [前端漫谈_3] 从 filter 聊到 Promise 如何编写高质量的函数 – 敲山震虎篇 前端常用插件、工具类库汇总，不要重复造轮子啦！！！ 前端基础篇之HTTP协议 一名【合格】前端工程师的自检清单 [译] Javascript 中 Array.push 要比 Array.concat 快 945 倍！🤯🤔 JS无形装逼，最为致命 ES6、ES7、ES8、ES9、ES10新特性一览 从今天开始，拿起 TypeScript 做一个轮子的制造者 前端代码质量管理（一） Node 12 值得关注的新特性 流动的SVG线条 幻术，一行代码实现镂空效果 【译】20个更有效地使用谷歌搜索的技巧 LeetCode-OpenSource/hire 编写工程化的业务模块 是时候开发你自己的vscode扩展插件了 node批量抓取并下载照片 NodeJs/Vue项目中对process.env的使用 CentOS7安装node.js npm scripts 使用指南 【太重要惹】🙆🙆🙆 GitHub OAuth 第三方登录示例教程 前端工具函数 Node.js + ELK 日志规范 让前端开发者失业的技术，Flutter Web初体验 禁止弹窗中蒙层底部页面跟随滚动的几种方法 代码注释的艺术，再也不怕被说代码可读性差啦！ 有助于理解前端工具的 node 知识 摩拜前端周刊第9期 探索 Serverless 中的前端开发模式 大型项目前端架构浅谈 你本可以少写些 if-else 从抓取豆瓣电影聊高性能爬虫思路 browserslist 目标浏览器配置表 又是一年D2：颇具匠心的中台技术修养 客户端内H5页面的首屏性能优化 如果把线程当作一个人来对待，所有问题都瞬间明白了 那些年曾谈起的跨域80%你不知道的解决方式 前端页面优化，减少reflow的方法 富文本原理了解一下 三步教你用Node做一个微信哄女友(基友)神器，小白可上手 Web 仿 App 动画竟然引出了“性能杀手” 再谈Chrome的最小字体12px限制 前端工作学习相关网站收集整理 3分钟教你用原生js实现具有进度监听的文件上传预览组件 前端大文件上传 【译】通过阅读源码来提高js知识 input file实现多选和限制文件上传类型 es6 Proxy 的巧用 技术路线：前端开发已进入深水区 从头开始，彻底理解服务端渲染原理(8千字汇总长文) 2019年JS正则大全(常用) 从搜索系统来聊聊防抖和节流 为什么视频网站的视频链接地址是blob？ 有赞前端质量保障体系 跨域资源共享 CORS 详解 Android 7.0 以上 Charles 和 Fiddler 无法抓取 HTTPS 包的解决方式 Android平台HTTPS抓包解决方案及问题分析 实战篇 - 如何实现和淘宝移动端一样的模块化加载 （task-silce） 一个合格的前端都应该阅读这些文章 来，跟我一起实现diff算法! 【译】 使用 Node.js 读取超大的文件（第一部分） 点我达三年前端路暨点我达前端演变过程 “切图仔”如何体现重构优势 【译】现代框架存在的根本原因 如何使用 Set 来提高代码的性能 SFTP同步本地代码到服务器 让自动化工作流解放你的双手 前端进阶必备，github 优质资源整理分享！ 冴羽的 JavaScript 系列 搭建前端监控系统（三）静态资源加载监控篇 随笔分类 - 一步一步搭建前端监控系统 Promise 中的三兄弟 .all(), .race(), .allSettled() GMTC 大前端时代前端监控的最佳实践 撸一个微信小程序记事本备忘录-随微记 把前端监控做到极致 21 个VSCode 快捷键，让代码更快，更有趣 用键盘8个键演奏一首蒲公英的约定送给996的自己或者一首月亮代表我的心给七夕的她 ELK集群部署（一） 【中高级前端必备】手摸手教你撸一个脚手架 css [实践总结]纯css实现动态边框 CSS实现两个球相交的粘粘效果 提高幸福感的 9 个 CSS 技巧 CSS 滚屏效果，要比想象中的难 不可思议的纯 CSS 滚动进度条效果 css做个波浪悬浮球？ CSS——让这些“展示”有更好的扩展性——媒体查询 使用CSS实现逼真的水波纹点击效果 集中コレクション，CSS垂直居中最强合集，看看你喜欢哪种？ css高级应用三种方法实现多行省略 《CSS世界》中提到的实用技巧 [译] 从没有人告诉过我的 CSS 小知识 《CSS揭秘》读书笔记 [译] Web 使用 CSS Shapes 的艺术设计 CSS对话框小尾巴实现的最佳方式 客栈说书：CSS遮罩CSS3 mask/masks详细介绍 纯 CSS实现根据元素已知的宽度设置高度以及注意事项 CSS3 box-shadow盒阴影图形生成技术 CSS进阶（17）—— CSS中的文本处理（上） 【译】一行css代码搞定响应式布局 用 CSS 写一个商城卡券需要几步 CSS优秀起来真没JS什么事 前端进阶之什么是BFC？BFC的原理是什么？如何创建BFC？ 【不可思议的CSS】天气不可能那么可爱 【Hello CSS】第九章-如何画一个体验更好的动画？ PNG格式小图标的CSS任意颜色赋色技术 Vue相关 Vue 使用中的小技巧 5分钟撸一个Vue CLI 插件 Vue实践」武装你的前端项目 如何写好一个vue组件,老夫的一年经验全在这了 自己搭建过vue开发环境吗？ 如何写出一个利于扩展的vue路由配置 [手把手系列之]Docker 部署 vue 项目 [译] Vue 最黑暗的一天 7个有用的Vue开发技巧 拿起VuePress打造属于自己的专属博客 vue-cli3开发Chrome插件实践 Vue3.0 Function-based API RFC Vue 应用单元测试的策略与实践 06 - 如何落地的几点建议 Vue开发环境下调用接口跨域问题 Vue-cli 的 proxyTable 解决跨域问题 插件http-proxy-middleware在vue-cli中的使用 vue菜鸟从业记：公司项目里如何进行前后端接口联调 Vue-cli 3: How to properly use “http-proxy-middleware”? 用一次就会爱上的cli工具开发 Vuejs建议和最佳实践 react React小技巧汇总 React Hooks高仿B站Web移动端直播 调试黑科技 Chrome运行时性能瓶颈分析 chrome开发者工具各种骚技巧 你以为内存泄露怎么侦测（适用于日常工作和面试） 数据结构&amp;算法&amp;操作系统&amp;设计模式&amp;计算机组成原理 导师计划–数据结构和算法系列（上） 导师计划–数据结构和算法系列（下） 【算法技巧】位运算装逼指南 由三道 LeetCode 题目简单了解一下位运算 【前端进阶之路】没有入门设计模式？那看这篇就够了！ 如何创建一个完美的单例模式（转载） Java面向对象详解 JavaScript 单例模式 linux Linux生产环境上，最常用的一套“Sed“技巧 nginx 快速上手Nginx 彻底弄懂 Nginx location 匹配 webpack Webpack5.0 新特性尝鲜实战 🦀🦀 关于webpack4的14个知识点,童叟无欺 面试必备！webpack 中那些最易混淆的 5 个知识点 从今天开始，学习Webpack，减少对脚手架的依赖(下) webpack中使用反向代理或者后端代理 webpack-dev-server 代理解决cookie丢失问题 webpack的proxy解决开发环境跨越问题 webpack proxy的代理、抓包、跨域、重写代理路径、改头信息、webSocket（前后端分离必备） 手把手教你撸一个简易的 webpack 带你走进webpack世界，成为webpack头号玩家。 webpack4-用之初体验，一起敲它十一遍 NODE Node快速切换版本、版本回退(降级)、版本更新(升级) 面经 【周刊-2】三年大厂面试官-前端面试题（偏难） 「中高级前端面试」JavaScript手写代码无敌秘籍 【周刊-3】三年大厂面试官-十道前端面试题（欢迎挑战） 面试官(6): 写过『通用前端组件』吗? 前端面试之手写代码 2019 前端面试 | 知其然，并知其所以然 面试官到底想看什么样的简历？ 前端 100 问：能搞懂 80% 的请把简历给我 这儿有20道大厂面试题等你查收 🔥Android 复习资料汇总版🔥（更新至20190806） 小蝌蚪系列：三年大厂面试官——二面题（偏难）]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式 [learn]]]></title>
    <url>%2F2019%2F05%2F15%2Fdesign_patterns%2F</url>
    <content type="text"><![CDATA[TODO … ｄ(･∀･*)♪ﾟ]]></content>
      <categories>
        <category>前端</category>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[DOMContentLoaded与load的区别]]></title>
    <url>%2F2019%2F05%2F15%2Fjs_onLoad%2F</url>
    <content type="text"><![CDATA[DOMContentLoaded顾名思义，就是dom内容加载完毕。那什么是dom内容加载完毕呢？我们从打开一个网页说起。当输入一个URL，页面的展示首先是空白的，然后过一会，页面会展示出内容，但是页面的有些资源比如说图片资源还无法看到，此时页面是可以正常的交互，过一段时间后，图片才完成显示在页面。从页面空白到展示出页面内容，会触发DOMContentLoaded事件。而这段时间就是HTML文档被加载和解析完成。 这时候问题又来了，什么是HTML文档被加载和解析完成。要解决这个问题，我们就必须了解浏览器渲染原理。 当我们在浏览器地址输入URL时，浏览器会发送请求到服务器，服务器将请求的HTML文档发送回浏览器，浏览器将文档下载下来后，便开始从上到下解析，解析完成之后，会生成DOM。如果页面中有css，会根据css的内容形成CSSOM，然后DOM和CSSOM会生成一个渲染树，最后浏览器会根据渲染树的内容计算出各个节点在页面中的确切大小和位置，并将其绘制在浏览器上。下面就是页面加载和解析过程中，浏览器的一个快照 上面我们看到在解析html的过程中，html的解析会被中断，这是因为javascript会阻塞dom的解析。当解析过程中遇到&lt;script&gt;标签的时候，便会停止解析过程，转而去处理脚本，如果脚本是内联的，浏览器会先去执行这段内联的脚本，如果是外链的，那么先会去加载脚本，然后执行。在处理完脚本之后，浏览器便继续解析HTML文档。 同时javascript的执行会受到标签前面样式文件的影响。如果在标签前面有样式文件，需要样式文件加载并解析完毕后才执行脚本。这是因为javascript可以查询对象的样式。 这里需要注意一点，在现代浏览器中，为了减缓渲染被阻塞的情况，现代的浏览器都使用了猜测预加载。当解析被阻塞的时候，浏览器会有一个轻量级的HTML（或CSS）扫描器（scanner）继续在文档中扫描，查找那些将来可能能够用到的资源文件的url，在渲染器使用它们之前将其下载下来。 在这里我们可以明确DOMContentLoaded所计算的时间，当文档中没有脚本时，浏览器解析完文档便能触发 DOMContentLoaded 事件；如果文档中包含脚本，则脚本会阻塞文档的解析，而脚本需要等位于脚本前面的css加载完才能执行。在任何情况下，DOMContentLoaded 的触发不需要等待图片等其他资源加载完成。 接下来，我们来说说load，页面上所有的资源（图片，音频，视频等）被加载以后才会触发load事件，简单来说，页面的load事件会在DOMContentLoaded被触发之后才触发。 我们在 jQuery 中经常使用的 $(document).ready(function() { // ...代码... }); 其实监听的就是 DOMContentLoaded 事件，而 $(document).load(function() { // ...代码... }); 监听的是 load 事件。在用jquery的时候，我们一般都会将函数调用写在ready方法内，就是页面被解析后，我们就可以访问整个页面的所有dom元素，可以缩短页面的可交互时间，提高整个页面的体验。 下面我们在来看看如何实现这两个函数 1、onload事件onload事件所有的浏览器都支持，所以我们不需要什么兼容，只要通过调用123window.onload = function()&#123; &#125; 2、DOMContentLoaded 事件DOMContentLoaded不同的浏览器对其支持不同，所以在实现的时候我们需要做不同浏览器的兼容。 支持DOMContentLoaded事件的，就使用DOMContentLoaded事件； IE6、IE7不支持DOMContentLoaded，但它支持onreadystatechange事件，该事件的目的是提供与文档或元素的加载状态有关的信息。 更低的ie还有个特有的方法doScroll， 通过间隔调用：document.documentElement.doScroll(“left”); 可以检测DOM是否加载完成。 当页面未加载完成时，该方法会报错，直到doScroll不再报错时，就代表DOM加载完成了。该方法更接近DOMContentLoaded的实现。12345678910111213141516171819202122232425262728293031function ready(fn)&#123; if(document.addEventListener) &#123; document.addEventListener(&apos;DOMContentLoaded&apos;, function() &#123; document.removeEventListener(&apos;DOMContentLoaded&apos;,arguments.callee, false); fn(); &#125;, false); &#125; // 如果IE else if(document.attachEvent) &#123; // 确保当页面是在iframe中加载时，事件依旧会被安全触发 document.attachEvent(&apos;onreadystatechange&apos;, function() &#123; if(document.readyState == &apos;complete&apos;) &#123; document.detachEvent(&apos;onreadystatechange&apos;, arguments.callee); fn(); &#125; &#125;); // 如果是IE且页面不在iframe中时，轮询调用doScroll 方法检测DOM是否加载完毕 if(document.documentElement.doScroll &amp;&amp; typeof window.frameElement === &quot;undefined&quot;) &#123; try&#123; document.documentElement.doScroll(&apos;left&apos;); &#125; catch(error)&#123; return setTimeout(arguments.callee, 20); &#125;; fn(); &#125; &#125;&#125;; 最后我们来回答这个问题：我们为什么一再强调将css放在头部，将js文件放在尾部 在面试的过程中，经常会有人在回答页面的优化中提到将js放到body标签底部，原因是因为浏览器生成Dom树的时候是一行一行读HTML代码的，script标签放在最后面就不会影响前面的页面的渲染。那么问题来了，既然Dom树完全生成好后页面才能渲染出来，浏览器又必须读完全部HTML才能生成完整的Dom树，script标签不放在body底部是不是也一样，因为dom树的生成需要整个文档解析完毕。我们再来看一下chrome在页面渲染过程中的，绿色标志线是First Paint的时间。纳尼，为什么会出现firstpaint，页面的paint不是在渲染树生成之后吗？其实现代浏览器为了更好的用户体验,渲染引擎将尝试尽快在屏幕上显示的内容。它不会等到所有HTML解析之前开始构建和布局渲染树。部分的内容将被解析并显示。也就是说浏览器能够渲染不完整的dom树和cssom，尽快的减少白屏的时间。假如我们将js放在header，js将阻塞解析dom，dom的内容会影响到First Paint，导致First Paint延后。所以说我们会将js放在后面，以减少First Paint的时间，但是不会减少DOMContentLoaded被触发的时间。 文章转载：DOMContentLoaded与load的区别]]></content>
      <categories>
        <category>前端</category>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[nodejs[learn]]]></title>
    <url>%2F2019%2F05%2F15%2Fnodejs%2F</url>
    <content type="text"></content>
      <categories>
        <category>前端</category>
        <category>nodejs</category>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>学习笔记</tag>
        <tag>nodejs</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[es6[learn]]]></title>
    <url>%2F2019%2F05%2F15%2Fes6%2F</url>
    <content type="text"><![CDATA[1、编码风格1、块级作用域var命令存在变量提升作用let命令不存在这个问题。建议不再使用var命令，而是使用let命令取代 在let和const之间，建议优先使用const,尤其是在全局环境，不应该设置变量，最好设置为常量 2、字符串静态字符串一律使用单引号或反引号，不使用双引号。动态字符串使用反引号。 3、解构赋值使用数组成员对变量赋值时，优先使用解构赋值。函数的参数如果是对象的成员，优先使用解构赋值。 4、对象单行定义的对象，最后一个成员不以逗号结尾。多行定义的对象，最后一个成员以逗号结尾。对象尽量静态化，一旦定义，就不得随意添加新的属性。如果添加属性不可避免，要使用Object.assign方法。1234567891011// badconst a = &#123;&#125;;a.x = 3;// if reshape unavoidableconst a = &#123;&#125;;Object.assign(a, &#123; x: 3 &#125;);// goodconst a = &#123; x: null &#125;;a.x = 3; 对象的属性和方法，尽量采用简洁表达法，这样易于描述和书写。 5、数组使用扩展运算符（…）拷贝数组。const itemsCopy = [...items];使用 Array.from 方法，将类数组对象转为数组。12const foo = document.querySelectorAll(&apos;.foo&apos;);const nodes = Array.from(foo); 6、函数立即执行函数可以写成箭头函数的形式。123(() =&gt; &#123; console.log(&apos;Welcome to the Internet.&apos;);&#125;)(); 箭头函数取代Function.prototype.bind，不应再用 self/_this/that 绑定 this1234567891011// badconst self = this;const boundMethod = function(...params) &#123; return method.apply(self, params);&#125;// acceptableconst boundMethod = method.bind(this);// bestconst boundMethod = (...params) =&gt; method.apply(this, params); 简单的、单行的、不会复用的函数，建议采用箭头函数。如果函数体较为复杂，行数较多，还是应该采用传统的函数写法。 所有配置项都应该集中在一个对象，放在最后一个参数，布尔值不可以直接作为参数。1234567// badfunction divide(a, b, option = false ) &#123;&#125;// goodfunction divide(a, b, &#123; option = false &#125; = &#123;&#125;) &#123;&#125; 不要在函数体内使用 arguments 变量，使用 rest 运算符（…）代替。因为 rest 运算符显式表明你想要获取参数，而且 arguments 是一个类似数组的对象，而 rest 运算符可以提供一个真正的数组。12345678910// badfunction concatenateAll() &#123; const args = Array.prototype.slice.call(arguments); return args.join(&apos;&apos;);&#125;// goodfunction concatenateAll(...args) &#123; return args.join(&apos;&apos;);&#125; 使用默认值语法设置函数参数的默认值。123456789// badfunction handleThings(opts) &#123; opts = opts || &#123;&#125;;&#125;// goodfunction handleThings(opts = &#123;&#125;) &#123; // ...&#125; 7、Map结构注意区分 Object 和 Map，只有模拟现实世界的实体对象时，才使用 Object。如果只是需要key: value的数据结构，使用 Map 结构。因为 Map 有内建的遍历机制。12345678910111213let map = new Map(arr);for (let key of map.keys()) &#123; console.log(key);&#125;for (let value of map.values()) &#123; console.log(value);&#125;for (let item of map.entries()) &#123; console.log(item[0], item[1]);&#125; 8、Class总是用 Class，取代需要 prototype 的操作。因为 Class 的写法更简洁，更易于理解。123456789101112131415161718192021// badfunction Queue(contents = []) &#123; this._queue = [...contents];&#125;Queue.prototype.pop = function() &#123; const value = this._queue[0]; this._queue.splice(0, 1); return value;&#125;// goodclass Queue &#123; constructor(contents = []) &#123; this._queue = [...contents]; &#125; pop() &#123; const value = this._queue[0]; this._queue.splice(0, 1); return value; &#125;&#125; 使用extends实现继承，因为这样更简单，不会有破坏instanceof运算的危险。12345678910111213141516// badconst inherits = require(&apos;inherits&apos;);function PeekableQueue(contents) &#123; Queue.apply(this, contents);&#125;inherits(PeekableQueue, Queue);PeekableQueue.prototype.peek = function() &#123; return this._queue[0];&#125;// goodclass PeekableQueue extends Queue &#123; peek() &#123; return this._queue[0]; &#125;&#125; 9、模块首先，Module 语法是 JavaScript 模块的标准写法，坚持使用这种写法。使用import取代require。1234567// badconst moduleA = require(&apos;moduleA&apos;);const func1 = moduleA.func1;const func2 = moduleA.func2;// goodimport &#123; func1, func2 &#125; from &apos;moduleA&apos;; 使用export取代module.exports。123456789101112131415161718192021// commonJS的写法var React = require(&apos;react&apos;);var Breadcrumbs = React.createClass(&#123; render() &#123; return &lt;nav /&gt;; &#125;&#125;);module.exports = Breadcrumbs;// ES6的写法import React from &apos;react&apos;;class Breadcrumbs extends React.Component &#123; render() &#123; return &lt;nav /&gt;; &#125;&#125;;export default Breadcrumbs; 如果模块只有一个输出值，就使用export default，如果模块有多个输出值，就不使用export default，export default与普通的export不要同时使用。 不要在模块输入中使用通配符。因为这样可以确保你的模块之中，有一个默认输出（export default）。12345// badimport * as myObject from &apos;./importModule&apos;;// goodimport myObject from &apos;./importModule&apos;; 如果模块默认输出一个函数，函数名的首字母应该小写。(小驼峰写法)1234function makeStyleGuide() &#123;&#125;export default makeStyleGuide; 如果模块默认输出一个对象，对象名的首字母应该大写。123456const StyleGuide = &#123; es6: &#123; &#125;&#125;;export default StyleGuide; 10、ESLint的使用在项目的根目录下新建一个.eslintrc文件，配置 ESLint123&#123; &quot;extends&quot;: &quot;eslint-config-airbnb&quot;&#125; 使用 ESLint 检查文件，查看报错。$ eslint index.js 2、Module的加载实现1、加载规则对于外部的模块脚本，有几点需要注意。代码是在模块作用域之中运行，而不是在全局作用域运行。模块内部的顶层变量，外部不可见。 模块脚本自动采用严格模式，不管有没有声明use strict。模块之中，可以使用import命令加载其他模块（.js后缀不可省略，需要提供绝对 URL 或相对 URL），也可以使用export命令输出对外接口。 模块之中，顶层的this关键字返回undefined，而不是指向window。也就是说，在模块顶层使用this关键字，是无意义的。*同一个模块如果加载多次，将只执行一次。 利用顶层的this等于undefined这个语法点，可以侦测当前代码是否在 ES6 模块之中。1const isNotModuleScript = this !== undefined; 2、ES6模块与CommonJS模块的差异ES6 模块与 CommonJS 模块完全不同，它们有两个重大差异:CommonJS 模块输出的是一个值的拷贝，ES6 模块输出的是值的引用。CommonJS 模块是运行时加载，ES6 模块是编译时输出接口。 第二个差异是因为 CommonJS 加载的是一个对象（即module.exports属性），该对象只有在脚本运行完才会生成。而 ES6 模块不是对象，它的对外接口只是一种静态定义，在代码静态解析阶段就会生成。]]></content>
      <categories>
        <category>前端</category>
        <category>es6</category>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>es6</tag>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[brew]]></title>
    <url>%2F2019%2F05%2F14%2Fbrew%2F</url>
    <content type="text"><![CDATA[官网]]></content>
      <categories>
        <category>brew</category>
      </categories>
      <tags>
        <tag>brew</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[axios]]></title>
    <url>%2F2019%2F05%2F13%2Faxios%2F</url>
    <content type="text"><![CDATA[前言在开发过程中，前端需要mock数据，以便和服务器端同时开发，互不耽误，在本地用mock数据，测试环境用接口。以前在开发过程中，我都是会在打包之前把引入的mock数据注释掉，每次都要更改代码，很可能会”手滑”，那有什么好的解决方案呢？ 为了满足需求，特意看了下axios中文说明文档，生态系统中有一个用来mock第三方库：moxios(就是这么好解决，多百度准没错 youxiu👍) #moxios使用方法 安装moxios包：npm install moxios --save-dev TODO … ｄ(･∀･*)♪ﾟ]]></content>
      <categories>
        <category>前端</category>
        <category>axios</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>axios</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[正则表达式[learn]]]></title>
    <url>%2F2019%2F05%2F13%2Freg%2F</url>
    <content type="text"></content>
      <categories>
        <category>前端</category>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[常用命令]]></title>
    <url>%2F2019%2F05%2F13%2Fcommands%2F</url>
    <content type="text"><![CDATA[// 查看80端口是否被占用sudo lsof -i :80 // 直接结束占用端口的所有进程kill ${pid} TODO … ｄ(･∀･*)♪ﾟ]]></content>
      <categories>
        <category>计算机</category>
        <category>命令</category>
      </categories>
      <tags>
        <tag>计算机</tag>
        <tag>命令</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[util]]></title>
    <url>%2F2019%2F05%2F10%2Fjs_util%2F</url>
    <content type="text"><![CDATA[javascript常用工具库1.Browser 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178function getBrowserInfo() &#123; var is360 = false; var isIE = false; var isFirefox = false; var isChrome = false; var isSafari = false; var isEdge = false; var broinfo = &#123; broName:&apos;&apos;, browserVersion:&apos;&apos;, &#125; var str = &apos;&apos;; var strStart = 0; var strStop = 0; var arr = new Array(); var temp = &apos;&apos;; var userAgent = window.navigator.userAgent.toLowerCase(); //包含以下属性中所有或一部分的字符串：appCodeName,appName,appVersion,language,platform // 浏览器类型-IE let ieversion = getIEVersion(); if(ieversion!=-1 &amp;&amp; ieversion!=&apos;edge&apos;) &#123; isIE = true; broinfo.broName = &apos;IE&apos; + ieversion; broinfo.browserVersion = ieversion; return broinfo; &#125; //Edge if(userAgent.indexOf(&apos;edge&apos;) != -1) &#123; isEdge = true; broinfo.broName = &apos;Edge&apos; broinfo.browserVersion = userAgent.match(/edge\/([\d.]+)/)[1]; return broinfo; &#125; // 2345Explorer if (userAgent.indexOf(&quot;2345explorer&quot;) &gt; 0) &#123; broinfo.broName = &apos;2345浏览器&apos; broinfo.browserVersion = userAgent.match(/2345explorer\/([\d.]+)/)[1]; return broinfo; &#125; // 欧朋 if (window.opera || (userAgent.indexOf(&quot;opr&quot;) &gt; 0)) &#123; broinfo.broName = &apos;Opera&apos; broinfo.browserVersion = this.getOperaVersion(userAgent) return broinfo; &#125; // UC if (userAgent.indexOf(&quot;ubrowser&quot;) &gt; 0) &#123; broinfo.broName = &apos;UC&apos; broinfo.browserVersion = userAgent.match(/ubrowser\/([\d.]+)/)[1]; return broinfo; &#125; // 百度 if (userAgent.indexOf(&quot;bidubrowser&quot;) &gt; 0) &#123; broinfo.broName = &apos;百度&apos; broinfo.browserVersion = userAgent.match(/bidubrowser\/([\d.]+)/)[1]; return broinfo; &#125; // 搜狗 if (userAgent.indexOf(&quot;metasr&quot;) &gt; 0 || userAgent.indexOf( &quot;se 2.x&quot; ) &gt; 0 ) &#123; broinfo.broName = &apos;搜狗&apos; broinfo.browserVersion = &apos;&apos;; return broinfo; &#125; // QQ if (userAgent.indexOf(&quot;tencenttraveler&quot;) &gt; 0) &#123; broinfo.broName = &apos;QQ&apos; broinfo.browserVersion = userAgent.match(/tencenttraveler\/([\d.]+)/)[1]; return broinfo; &#125; // QQ if (userAgent.indexOf(&quot;qqbrowser&quot;) &gt; 0) &#123; broinfo.broName = &apos;QQ&apos; broinfo.browserVersion = userAgent.match(/qqbrowser\/([\d.]+)/)[1]; return broinfo; &#125; // 遨游 if (userAgent.indexOf(&quot;maxthon&quot;) &gt; 0) &#123; broinfo.broName = &apos;遨游&apos; broinfo.browserVersion = userAgent.match(/maxthon\/([\d.]+)/)[1]; return broinfo; &#125; // 火狐 if (userAgent.indexOf(&quot;firefox&quot;) &gt; 0) &#123; broinfo.broName = &apos;firefox&apos;; broinfo.browserVersion = userAgent.match(/firefox\/([\d.]+)/)[1]; return broinfo; &#125; if (userAgent.indexOf(&quot;chrome&quot;) &gt; 0) &#123; if (validate360(&apos;type&apos;, &apos;application/x360mmplugin&apos;)) &#123; broinfo.broName = &apos;360&apos; broinfo.browserVersion = userAgent.match(/chrome\/([\d.]+)/)[1]; &#125; else if(_mime(&quot;type&quot;, &quot;application/vnd.chromium.remoting-viewer&quot;))&#123; broinfo.broName = &apos;360&apos; broinfo.browserVersion = userAgent.match(/chrome\/([\d.]+)/)[1]; &#125; else &#123; broinfo.broName = &apos;chrome&apos; broinfo.browserVersion = userAgent.match(/chrome\/([\d.]+)/)[1]; &#125; &#125; else if (userAgent.indexOf(&quot;safari&quot;) &gt; -1) &#123; // 苹果 broinfo.broName = &apos;safari&apos;; broinfo.browserVersion = userAgent.match(/version\/([\d.]+)/)[1]; &#125; if(!broinfo.broName)&#123; broinfo.broName = &apos;其他&apos;; broinfo.browserVersion = &apos;&apos;; &#125; return broinfo;&#125;/* * 判断是否为360浏览器 */ function _mime(option, value) &#123; var mimeTypes = navigator.mimeTypes; for (var mt in mimeTypes) &#123; if (mimeTypes[mt][option] == value) &#123; return true; &#125; &#125; return false;&#125;function validate360(option, value) &#123; let mimeTypes = window.navigator.mimeTypes for (let mt in mimeTypes) &#123; if (mimeTypes[mt][option] == value) &#123; return true; &#125; &#125; return false;&#125;/* * 获取oper浏览器版本 */ function getOperaVersion(userAgent) &#123; try &#123; if (window.opera) &#123; return userAgent.match(/opera.([\d.]+)/)[1]; &#125; else if (userAgent.indexOf(&quot;opr&quot;) &gt; 0) &#123; return userAgent.match(/opr\/([\d.]+)/)[1]; &#125; &#125; catch (e) &#123; return 0; &#125;&#125;/* * 获取IE浏览器版本 */function getIEVersion() &#123; var userAgent = navigator.userAgent; //取得浏览器的userAgent字符串 var isIE = userAgent.indexOf(&quot;compatible&quot;) &gt; -1 &amp;&amp; userAgent.indexOf(&quot;MSIE&quot;) &gt; -1; //判断是否IE&lt;11浏览器 var isEdge = userAgent.indexOf(&quot;Edge&quot;) &gt; -1 &amp;&amp; !isIE; //判断是否IE的Edge浏览器 var isIE11 = userAgent.indexOf(&apos;Trident&apos;) &gt; -1 &amp;&amp; userAgent.indexOf(&quot;rv:11.0&quot;) &gt; -1; if(isIE) &#123; var reIE = new RegExp(&quot;MSIE (\\d+\\.\\d+);&quot;); reIE.test(userAgent); var fIEVersion = parseFloat(RegExp[&quot;$1&quot;]); if(fIEVersion == 7) &#123; return 7; &#125; else if(fIEVersion == 8) &#123; return 8; &#125; else if(fIEVersion == 9) &#123; return 9; &#125; else if(fIEVersion == 10) &#123; return 10; &#125; else &#123; return 6; //IE版本&lt;=7 &#125; &#125; else if(isEdge) &#123; return &apos;edge&apos;; //edge &#125; else if(isIE11) &#123; return 11; //IE11 &#125; else &#123; return -1; //不是ie浏览器 &#125;&#125; 2.setCookie 12345export function setCookie(name, value, hour=24) &#123; var exp = new Date(); exp.setTime(exp.getTime() + hour*3600000); document.cookie = name + &quot;=&quot; + escape(value) + &quot;;expires=&quot; + exp.toGMTString()+&quot;;domain=&apos;.weibo.com&apos;&quot;;&#125; 3.getCookie 1234567891011121314export function getCookie(objname) &#123; //获取指定名称的cookie的值 var v = &quot;&quot;; var arrstr = document.cookie.split(&quot;; &quot;); for(var i = 0; i &lt; arrstr.length; i++) &#123; var temp = arrstr[i].split(&quot;=&quot;); if(temp[0] == objname) &#123; var v1 = unescape(temp[1]); if(v == &quot;&quot; || v1.length &lt; v.length) &#123; v = v1; &#125; &#125; &#125; return v;&#125; 4.clearCookie 123export function clearCookie() &#123; document.cookie = &apos;&apos;;&#125;; 5.safeGet 12345export function safeGet(o, path) &#123; return path.split(&apos;.&apos;).reduce((o = &#123;&#125;, b) =&gt; &#123; //用到参数默认值 return o[b] &#125;, o)&#125;; 6.getFileExt 1234567export function getFileExt(filename) &#123; var pos = filename.lastIndexOf(&apos;.&apos;); if(pos &gt; 0) &#123; return filename.substring(pos + 1).toLowerCase(); &#125; return &apos;&apos;;&#125;; 7.解析url参数 12345678910111213141516171819202122export function parseParam(url) &#123; let paramsStr = /.+\?(.+)$/.exec(url); // 将 ? 后面的字符串取出来 if(!paramsStr) return; paramsStr = paramsStr[1]; const paramsArr = paramsStr.split(&apos;&amp;&apos;); // 将字符串以 &amp; 分割后存到数组中 let paramsObj = &#123;&#125;; // 将 params 存到对象中 paramsArr.forEach(param =&gt; &#123; if(/=/.test(param)) &#123; // 处理有 value 的参数 let [key, val] = param.split(&apos;=&apos;); // 分割 key 和 value val = decodeURIComponent(val); // 解码 val = /^\d+$/.test(val) ? parseFloat(val) : val; // 判断是否转为数字 if(paramsObj.hasOwnProperty(key)) &#123; // 如果对象有 key，则添加一个值 paramsObj[key] = [].concat(paramsObj[key], val); &#125; else &#123; // 如果对象没有这个 key，创建 key 并设置值 paramsObj[key] = val; &#125; &#125; else &#123; // 处理没有 value 的参数 paramsObj[param] = null; &#125; &#125;) return paramsObj;&#125; 8.parseURL 12345678910function parseURL(url)&#123; var parse_url = /^(?:([A-Za-z]+):(/&#123;0,3&#125;))?([0-9.-A-Za-z]+.[0-9A-Za-z]+)?(?::(d+))?(?:/([^?#]*))?(?:?([^#]*))?(?:#(.*))?$/; var names = [&apos;url&apos;, &apos;scheme&apos;, &apos;slash&apos;, &apos;host&apos;, &apos;port&apos;, &apos;path&apos;, &apos;query&apos;, &apos;hash&apos;]; var results = parse_url.exec(url); var that = &#123;&#125;; for (var i = 0, len = names.length; i &lt; len; i += 1) &#123; that[names[i]] = results[i] || &apos;&apos;; &#125; return that;&#125; 9.产生随机字符串 123456789function randomChar(l = 13) &#123; var x = &quot;0123456789qwertyuioplkjhgfdsazxcvbnm&quot;; var tmp = &quot;&quot;; var timestamp = new Date().getTime(); for(var i = 0; i &lt; l; i++) &#123; tmp += x.charAt(Math.ceil(Math.random() * 100000000) % x.length); &#125; return timestamp + tmp;&#125; 10.addClass 123456export function addClass(obj,cls) &#123; var obj_class=obj.className,//获取class的内容； blank = ( obj_class != &apos;&apos; ) ? &apos; &apos; : &apos;&apos;;//判断获取的class是否为空，如果不为空，则添加空格； var added = obj_class + blank + cls;//组合原来的class和需要添加的class，中间加上空格； obj.className = added;//替换原来的class；&#125; 11.removeClass 1234567export function removeClass(obj,cls)&#123; var obj_class = &apos; &apos; + obj.className + &apos; &apos;;//获取class的内容，并在首尾各加一个空格；&apos;abc bcd&apos; -&gt; &apos; abc bcd &apos; obj_class = obj_class.replace(/(\s+)/gi,&apos; &apos;);//将多余的空字符替换成一个空格；&apos; abc bcd &apos; -&gt; &apos; abc bcd &apos; var removed = obj_class.replace(&apos; &apos;+cls+&apos; &apos;,&apos; &apos;);//在原来的class，替换掉首尾加了空格的class &apos; abc bcd &apos; -&gt; &apos;bcd &apos; removed = removed.replace(/(^\s+)|(\s+$)/g,&apos;&apos;);//去掉首尾空格；&apos;bcd &apos; -&gt; &apos;bcd&apos; obj.className = removed;//替换原来的class；&#125; 12.hasClass 123456789101112export function hasClass(obj,cls)&#123; var obj_class = obj.className,//获取class的内容； obj_class_lst = obj_class.split(/\s+/);//通过split空字符将cls转换成数组 console.log(obj_class_lst); var x = 0; for(x in obj_class_lst)&#123; if ( obj_class_lst[x] == cls ) &#123; return true; &#125; &#125; return false;&#125; 13.判断当时用户使用OS版本 1234567891011121314151617181920212223function detectOS() &#123; var sUserAgent = navigator.userAgent; var isWin = (navigator.platform == &quot;Win32&quot;) || (navigator.platform == &quot;Windows&quot;); var isMac = (navigator.platform == &quot;Mac68K&quot;) || (navigator.platform == &quot;MacPPC&quot;) || (navigator.platform == &quot;Macintosh&quot;) || (navigator.platform == &quot;MacIntel&quot;); if(isMac) return &quot;Mac&quot;; var isUnix = (navigator.platform == &quot;X11&quot;) &amp;&amp; !isWin &amp;&amp; !isMac; if(isUnix) return &quot;Unix&quot;; var isLinux = (String(navigator.platform).indexOf(&quot;Linux&quot;) &gt; -1); if(isLinux) return &quot;Linux&quot;; if(isWin) &#123; var isWin2K = sUserAgent.indexOf(&quot;Windows NT 5.0&quot;) &gt; -1 || sUserAgent.indexOf(&quot;Windows 2000&quot;) &gt; -1; if(isWin2K) return &quot;Win2000&quot;; var isWinXP = sUserAgent.indexOf(&quot;Windows NT 5.1&quot;) &gt; -1 || sUserAgent.indexOf(&quot;Windows XP&quot;) &gt; -1; if(isWinXP) return &quot;WinXP&quot;; var isWin2003 = sUserAgent.indexOf(&quot;Windows NT 5.2&quot;) &gt; -1 || sUserAgent.indexOf(&quot;Windows 2003&quot;) &gt; -1; if(isWin2003) return &quot;Win2003&quot;; var isWinVista = sUserAgent.indexOf(&quot;Windows NT 6.0&quot;) &gt; -1 || sUserAgent.indexOf(&quot;Windows Vista&quot;) &gt; -1; if(isWinVista) return &quot;WinVista&quot;; var isWin7 = sUserAgent.indexOf(&quot;Windows NT 6.1&quot;) &gt; -1 || sUserAgent.indexOf(&quot;Windows 7&quot;) &gt; -1; if(isWin7) return &quot;Win7&quot;; &#125; return &quot;other&quot;;&#125; 14.decodeHTML 123456789101112function decodeHTML(str)&#123; if(typeof str !== &apos;string&apos;)&#123; throw &apos;decodeHTML need a string as parameter&apos;; &#125; return str.replace(/&quot;/g,&apos;&quot;&apos;). replace(/&lt;/g,&apos;&lt;&apos;). replace(/&gt;/g,&apos;&gt;&apos;). replace(/&apos;/g,&apos;&apos;&apos;). replace(/ /g,&apos;u00A0&apos;). replace(/ /g,&apos;u0020&apos;). replace(/&amp;/g,&apos;&amp;&apos;);&#125; 15.encodeHTML 1234567891011function encodeHTML(str)&#123; if(typeof str !== &apos;string&apos;)&#123; throw &apos;encodeHTML need a string as parameter&apos;; &#125; return str.replace(/&amp;/g,&apos;&amp;&apos;). replace(/&quot;/g,&apos;&quot;&apos;). replace(//g,&apos;&gt;&apos;). replace(/&apos;/g,&apos;&apos;&apos;). replace(/u00A0/g,&apos; &apos;). replace(/(u0020|u000B|u2028|u2029|f)/g,&apos; &apos;);&#125; 16.从左到右取字符串，中文算两个字符 12345678function leftB(str, lens)&#123; var s = str.replace(/*/g, &apos; &apos;).replace(/[^x00-xff]/g, &apos;**&apos;); str = str.slice(0, s.slice(0, lens).replace(/**/g, &apos; &apos;).replace(/*/g, &apos;&apos;).length); if ($.core.str.bLength(str) &gt; lens &amp;&amp; lens &gt; 0) &#123; str = str.slice(0, str.length - 1); &#125; return str;&#125; 17.全角字转半角字 12345function dbcToSbc(str)&#123; return str.replace(/[uff01-uff5e]/g,function(a)&#123; return String.fromCharCode(a.charCodeAt(0)-65248); &#125;).replace(/u3000/g,&quot; &quot;);&#125; 18.当前用户使用设备ios 12345678var Global = &#123; //用户当前使用设备 // iPhone X、iPhone XS isIPhoneX: /iphone/gi.test(window.navigator.userAgent) &amp;&amp; window.devicePixelRatio &amp;&amp; window.devicePixelRatio === 3 &amp;&amp;window.screen.width === 375 &amp;&amp; window.screen.height === 812, // iPhone XS Max isIPhoneXSMax: /iphone/gi.test(window.navigator.userAgent) &amp;&amp; window.devicePixelRatio &amp;&amp; window.devicePixelRatio ===3 &amp;&amp; window.screen.width === 414 &amp;&amp; window.screen.height === 896, // iPhone XR isIPhoneXR: /iphone/gi.test(window.navigator.userAgent) &amp;&amp; window.devicePixelRatio &amp;&amp; window.devicePixelRatio === 2 &amp;&amp;window.screen.width === 414 &amp;&amp; window.screen.height === 896, &#125;; 19.ua 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214/* eslint no-restricted-syntax: 0*//* eslint max-len: 0 *//* eslint one-var: 0*/module.exports = (function () &#123; const detecter = &#123;&#125;; const u = window.navigator.userAgent; const match = &#123; /* 内核(EdgeHTML,Trident,Presto,WebKit/Blink,Gecko)*/ /* eslint quote-props: 0*/ &apos;Trident&apos;: u.indexOf(&apos;Trident&apos;) &gt; -1 || u.indexOf(&apos;NET CLR&apos;) &gt; -1, &apos;Presto&apos;: u.indexOf(&apos;Presto&apos;) &gt; -1, &apos;WebKit&apos;: u.indexOf(&apos;AppleWebKit&apos;) &gt; -1, &apos;Gecko&apos;: u.indexOf(&apos;Gecko/&apos;) &gt; -1, /* 浏览器: (Safari,chrome,ie,edge,firefox,opera,kindle,360,uc,qq,baidu,maxthone,sogo,lbbrowser,xiaomi) wv: (微博,微信,支付宝,淘宝)*/ &apos;Safari&apos;: u.match(/version\/([\w\.]+).+?mobile\/\w+\s(safari)/i) || u.match(/version\/([\w\.]+).+?(mobile\s?safari|safari)/i), &apos;Chrome&apos;: u.indexOf(&apos;Chrome&apos;) &gt; -1 || u.match(/((?:android.+)crmo|crios)\/([\w\.]+)/i), &apos;IE&apos;: u.match(/(?:ms|\()(ie)\s([\w\.]+)/i) || u.match(/(trident).+rv[:\s]([\w\.]+).+like\sgecko/i), &apos;Edge&apos;: u.match(/(edge)\/((\d+)?[\w\.]+)/i), &apos;Firefox&apos;: u.indexOf(&apos;Firefox&apos;) &gt; -1 || u.match(/fxios\/([\w\.-]+)/i), &apos;Firefox Focus&apos;: u.indexOf(&apos;Focus&apos;) &gt; -1, &apos;Chromium&apos;: u.indexOf(&apos;Chromium&apos;) &gt; -1, &apos;Opera&apos;: u.indexOf(&apos;Opera&apos;) &gt; -1 || u.match(/\s(opr)\/([\w\.]+)/i), &apos;Vivaldi&apos;: u.indexOf(&apos;Vivaldi&apos;) &gt; -1, &apos;Yandex&apos;: u.match(/(yabrowser)\/([\w\.]+)/i), &apos;Kindle&apos;: u.match(/(kindle)\/([\w\.]+)/i), &apos;360&apos;: u.indexOf(&apos;360EE&apos;) &gt; -1 || u.indexOf(&apos;360SE&apos;) &gt; -1, &apos;UC&apos;: u.match(/(uc\s?browser)[\/\s]?([\w\.]+)/i) || u.match(/ucweb.+(ucbrowser)[\/\s]?([\w\.]+)/i) || u.match(/(ucbrowser)\/([\w\.]+)/i) || u.match(/juc.+(ucweb)[\/\s]?([\w\.]+)/i), &apos;QQBrowser&apos;: u.match(/m?(qqbrowser)[\/\s]?([\w\.]+)/i), &apos;Baidu&apos;: u.indexOf(&apos;Baidu&apos;) &gt; -1 || u.indexOf(&apos;BIDUBrowser&apos;) &gt; -1, /* 遨游*/ &apos;Maxthon&apos;: u.indexOf(&apos;Maxthon&apos;) &gt; -1, &apos;Sogou&apos;: u.indexOf(&apos;MetaSr&apos;) &gt; -1 || u.indexOf(&apos;Sogou&apos;) &gt; -1, /* 猎豹*/ &apos;LBBROWSER&apos;: u.indexOf(&apos;LBBROWSER&apos;) &gt; -1, &apos;XiaoMi&apos;: u.match(/xiaomi\/miuibrowser\/([\w\.]+)/i), /* webview*/ &apos;Wechat&apos;: u.match(/(micromessenger)\/([\w\.]+)/i), &apos;Taobao&apos;: u.indexOf(&apos;AliApp(TB&apos;) &gt; -1, &apos;Alipay&apos;: u.indexOf(&apos;AliApp(AP&apos;) &gt; -1, &apos;Weibo&apos;: u.match(/Weibo\s*\((.*?)\)/i), &apos;QQ&apos;: u.indexOf(&apos;QQ/&apos;) &gt; -1, /* 系统或平台*/ &apos;Windows&apos;: u.match(/microsoft\s(windows)\s(vista|xp)/i) || u.match(/(windows)\snt\s6\.2;\s(arm)/i), &apos;Mac OS&apos;: u.match(/(mac\sos\sx)\s?([\w\s\.]+\w)*/i) || u.match(/(macintosh|mac(?=_powerpc)\s)/i), &apos;Android&apos;: u.indexOf(&apos;Android&apos;) &gt; -1, &apos;Windows Phone&apos;: u.indexOf(&apos;IEMobile&apos;) &gt; -1, /* &apos;Windows Phone&apos;: u.match(/(windows\sphone(?:\sos)*)[\s\/]?([\d\.\s]+\w)*!/i) || ua.match(/(windows\smobile|windows)[\s\/]?([ntce\d\.\s]+\w)/i) || u.match(/(win(?=3|9|n)|win\s9x\s)([nt\d\.]+)/i),*/ &apos;iOS&apos;: u.match(/(ip[honead]+)(?:.*os\s([\w]+)*\slike\smac|;\sopera)/i), /* 设备 电脑(PC),平板或PDA(Tablet),手机(Mobile)*/ &apos;Mobile&apos;: u.indexOf(&apos;Mobile&apos;) &gt; -1 || u.indexOf(&apos;iPhone&apos;) &gt; -1 || u.indexOf(&apos;480&apos;) &gt; -1, &apos;Tablet&apos;: u.indexOf(&apos;Tablet&apos;) &gt; -1 || u.indexOf(&apos;Pad&apos;) &gt; -1 || u.indexOf(&apos;Nexus 7&apos;) &gt; -1 &#125;; /* 基本信息*/ const hash = &#123; engine: [&apos;WebKit&apos;, &apos;Trident&apos;, &apos;Gecko&apos;, &apos;Presto&apos;], browser: [&apos;Chrome&apos;, &apos;Safari&apos;, &apos;Edge&apos;, &apos;IE&apos;, &apos;Firefox&apos;, &apos;Firefox Focus&apos;, &apos;Chromium&apos;, &apos;Opera&apos;, &apos;Vivaldi&apos;, &apos;Yandex&apos;, &apos;Kindle&apos;, &apos;360&apos;, &apos;UC&apos;, &apos;QQBrowser&apos;, &apos;QQ&apos;, &apos;Baidu&apos;, &apos;Maxthon&apos;, &apos;Sogou&apos;, &apos;LBBROWSER&apos;, &apos;XiaoMi&apos;, &apos;Wechat&apos;, &apos;Taobao&apos;, &apos;Alipay&apos;, &apos;Weibo&apos;], os: [&apos;Windows&apos;, &apos;Mac OS&apos;, &apos;Android&apos;, &apos;iOS&apos;, &apos;Windows Phone&apos;], device: [&apos;Mobile&apos;, &apos;Tablet&apos;] &#125;; detecter.device = &apos;PC&apos;; /* eslint guard-for-in: 0 */ for (const s in hash) &#123; for (let i = 0; i &lt; hash[s].length; i += 1) &#123; const value = hash[s][i]; if (value &amp;&amp; match[value]) &#123; detecter[s] = value; &#125; &#125; &#125; /* 系统版本信息*/ const osVersion = &#123; &apos;Windows&apos;: function () &#123; const v = u.replace(/^.*Windows NT ([\d.]+);.*$/, &apos;$1&apos;); const hashV = &#123; &apos;6.4&apos;: &apos;10&apos;, &apos;6.3&apos;: &apos;8.1&apos;, &apos;6.2&apos;: &apos;8&apos;, &apos;6.1&apos;: &apos;7&apos;, &apos;6.0&apos;: &apos;Vista&apos;, &apos;5.2&apos;: &apos;XP&apos;, &apos;5.1&apos;: &apos;XP&apos;, &apos;5.0&apos;: &apos;2000&apos; &#125;; return hashV[v] || v; &#125;, &apos;Mac OS&apos;: function () &#123; return u.replace(/^.*Mac OS X ([\d_]+).*$/, &apos;$1&apos;).replace(/_/g, &apos;.&apos;); &#125;, &apos;Android&apos;: function () &#123; return u.replace(/^.*Android ([\d.]+);.*$/, &apos;$1&apos;); &#125;, &apos;iOS&apos;: function () &#123; return u.replace(/^.*OS ([\d_]+) like.*$/, &apos;$1&apos;).replace(/_/g, &apos;.&apos;); &#125;, &apos;Windows Phone&apos;: function () &#123; return u.replace(/^.*Windows Phone( OS)? ([\d.]+);.*$/, &apos;$2&apos;); &#125; &#125;; detecter.osVersion = &apos;&apos;; if (osVersion[detecter.os]) &#123; detecter.osVersion = osVersion[detecter.os](); if (detecter.osVersion === u) &#123; detecter.osVersion = &apos;&apos;; &#125; &#125; /* 浏览器版本信息 */ const version = &#123; &apos;Safari&apos;: function () &#123; return u.replace(/^.*Version\/([\d.]+).*$/, &apos;$1&apos;); &#125;, &apos;Chrome&apos;: function () &#123; return u.replace(/^.*Chrome\/([\d.]+).*$/, &apos;$1&apos;).replace(/^.*CriOS\/([\d.]+).*$/, &apos;$1&apos;); &#125;, &apos;IE&apos;: function () &#123; return u.replace(/^.*MSIE ([\d.]+).*$/, &apos;$1&apos;).replace(/^.*rv:([\d.]+).*$/, &apos;$1&apos;); &#125;, &apos;Edge&apos;: function () &#123; return u.replace(/^.*Edge\/([\d.]+).*$/, &apos;$1&apos;); &#125;, &apos;Firefox&apos;: function () &#123; return u.replace(/^.*Firefox\/([\d.]+).*$/, &apos;$1&apos;).replace(/^.*FxiOS\/([\d.]+).*$/, &apos;$1&apos;); &#125;, &apos;Firefox Focus&apos;: function () &#123; return u.replace(/^.*Focus\/([\d.]+).*$/, &apos;$1&apos;); &#125;, &apos;Chromium&apos;: function () &#123; return u.replace(/^.*Chromium\/([\d.]+).*$/, &apos;$1&apos;); &#125;, &apos;Opera&apos;: function () &#123; return u.replace(/^.*Opera\/([\d.]+).*$/, &apos;$1&apos;).replace(/^.*OPR\/([\d.]+).*$/, &apos;$1&apos;); &#125;, &apos;Vivaldi&apos;: function () &#123; return u.replace(/^.*Vivaldi\/([\d.]+).*$/, &apos;$1&apos;); &#125;, &apos;Yandex&apos;: function () &#123; return u.replace(/^.*YaBrowser\/([\d.]+).*$/, &apos;$1&apos;); &#125;, &apos;Kindle&apos;: function () &#123; return u.replace(/^.*Version\/([\d.]+).*$/, &apos;$1&apos;); &#125;, &apos;Maxthon&apos;: function () &#123; return u.replace(/^.*Maxthon\/([\d.]+).*$/, &apos;$1&apos;); &#125;, &apos;QQBrowser&apos;: function () &#123; return u.replace(/^.*QQBrowser\/([\d.]+).*$/, &apos;$1&apos;); &#125;, /* eslint no-useless-escape: 0*/ &apos;Baidu&apos;: function () &#123; return u.replace(/^.*BIDUBrowser[\s\/]([\d.]+).*$/, &apos;$1&apos;); &#125;, &apos;UC&apos;: function () &#123; return u.replace(/^.*UC?Browser\/([\d.]+).*$/, &apos;$1&apos;).replace(/juc.+(ucweb)[\/\s]?([\w\.]+)/i, &apos;$1&apos;); &#125;, &apos;Sogou&apos;: function () &#123; return u.replace(/^.*SE ([\d.X]+).*$/, &apos;$1&apos;).replace(/^.*SogouMobileBrowser\/([\d.]+).*$/, &apos;$1&apos;); &#125;, &apos;XiaoMi&apos;: function () &#123; return u.replace(/^.*MiuiBrowser\/([\d.]+).*$/, &apos;$1&apos;); &#125;, &apos;Wechat&apos;: function () &#123; return u.replace(/^.*MicroMessenger\/([\d.]+).*$/, &apos;$1&apos;); &#125;, &apos;Taobao&apos;: function () &#123; return u.replace(/^.*AliApp\(TB\/([\d.]+).*$/, &apos;$1&apos;); &#125;, &apos;Alipay&apos;: function () &#123; return u.replace(/^.*AliApp\(AP\/([\d.]+).*$/, &apos;$1&apos;); &#125;, /* &quot;Mozilla/5.0 (iPhone; CPU iPhone OS 10_3_2 like Mac OS X) AppleWebKit/603.2.4 (KHTML, like Gecko) Mobile/14F89 Weibo (iPhone9,2__weibo__7.6.0__iphone__os10.3.2)&quot; */ &apos;Weibo&apos;: function () &#123; const arr = u.match(/__weibo__(\d+?.\d+?.\d+)(_*\w*)*__(.+)?__/); if (!arr || !arr.length || arr.length &lt; 2) &#123; return &apos;&apos;; &#125; return arr[1]; &#125;, &apos;QQ&apos;: function () &#123; return u.replace(/^.*QQ\/([\d.]+).*$/, &apos;$1&apos;); &#125;, &#125;; detecter.version = &apos;&apos;; if (version[detecter.browser]) &#123; detecter.version = version[detecter.browser](); if (detecter.version === u) &#123; detecter.version = &apos;&apos;; &#125; &#125; /* 修正*/ if (detecter.browser === &apos;Edge&apos;) &#123; detecter.engine = &apos;EdgeHTML&apos;; &#125; else if (detecter.browser === &apos;Chrome&apos; &amp;&amp; parseInt(detecter.version, 10) &gt; 27) &#123; detecter.engine = &apos;Blink&apos;; &#125; else if (detecter.browser === &apos;Opera&apos; &amp;&amp; parseInt(detecter.version, 10) &gt; 12) &#123; detecter.engine = &apos;Blink&apos;; &#125; else if (detecter.browser === &apos;Yandex&apos;) &#123; detecter.engine = &apos;Blink&apos;; &#125; detecter.versionCompare = function (a, b) &#123; const pa = a.indexOf(&apos;_&apos;) &gt; -1 ? a.split(&apos;_&apos;) : a.split(&apos;.&apos;); const pb = b.indexOf(&apos;_&apos;) &gt; -1 ? b.split(&apos;_&apos;) : b.split(&apos;.&apos;); const len = Math.max(pa.length, pb.length); for (let i = 0; i &lt; len; i += 1) &#123; const na = Number(pa[i]) || 0; const nb = Number(pb[i]) || 0; if (na &gt; nb) return 1; if (nb &gt; na) return -1; &#125; return 0; &#125;; return detecter;&#125;()); 20.解决ios12上软键盘顶起页面后隐藏不回弹的问题 1!function(e)&#123;var a,i=navigator.userAgent.toLowerCase(),n=document.documentElement,t=parseInt(n.clientWidth);if(/(iPhone|iPad|iPod|iOS)/i.test(navigator.userAgent)||i.indexOf(&quot;like mac os x&quot;)&gt;0)&#123;var s=/os [\d._]*/gi,o=i.match(s);a=(o+&quot;&quot;).replace(/[^0-9|_.]/gi,&quot;&quot;).replace(/_/gi,&quot;.&quot;)&#125;var r=a+&quot;&quot;;&quot;undefined&quot;!=r&amp;&amp;r.length&gt;0&amp;&amp;(a=parseInt(r),a&gt;=8&amp;&amp;(375==t||667==t||320==t||568==t||480==t)?n.className=&quot;iosx2&quot;:(a&gt;=8&amp;&amp;414==t||736==t)&amp;&amp;(n.className=&quot;iosx3&quot;)),/(Android)/i.test(navigator.userAgent)&amp;&amp;(n.className=&quot;android&quot;)&#125;(window);]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode算法解析]]></title>
    <url>%2F2019%2F05%2F10%2Falgorithm_generation%2F</url>
    <content type="text"><![CDATA[分类解题 ###数组 832.翻转图像遍历一次，使用位运算异或将0/1反转，使用es6解构将x,y交换 [x,y]=[y,x] 977.有序数组的平方TODO 1051. 高度检查器1.两数之和遍历一次，以空间换时间，空间复杂度O(n)，时间复杂度O(n)123456789101112131415161718192021/** * @param &#123;number[]&#125; nums * @param &#123;number&#125; target * @return &#123;number[]&#125; */var twoSum = function(nums, target) &#123; let result = []; let heads = &#123;&#125;;//key-value: 值 - 键 let needs = &#123;&#125;;//key-value: 值 - true nums.forEach(function(item,index,arr)&#123; if(needs[item])&#123; let left = heads[target-item]; result = [left,index]; return; &#125; else &#123; heads[item] = index; needs[target-item] = true; &#125; &#125;) return result&#125;; TODO … ｄ(･∀･*)♪ﾟ]]></content>
      <categories>
        <category>algorithm</category>
      </categories>
      <tags>
        <tag>algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[你不知道的javascript【learn】]]></title>
    <url>%2F2019%2F05%2F10%2Fjs_book_learn%2F</url>
    <content type="text"><![CDATA[TODO … ❣️]]></content>
      <categories>
        <category>javascript</category>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>javascript</tag>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[html2canvas]]></title>
    <url>%2F2019%2F05%2F10%2Fhtml2canvas%2F</url>
    <content type="text"><![CDATA[TODO … ｄ(･∀･*)♪ﾟ]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[http权威指南 [学习笔记]]]></title>
    <url>%2F2019%2F05%2F10%2Fhttp_authority_guide%2F</url>
    <content type="text"><![CDATA[第一部分：web的基础第1章节：http概述web浏览器/服务器和相关的web应用程序都是通过http相互通信的 web客户端和服务器web内容都是存储在web服务器上的。web服务器所使用的是http协议，因此常常会被称为http服务器 媒体类型http给每种要通过web传输的对象都打上了名为MIME类型的数据格式标签。MIME类型是一种文本标记，表示一种主要的对象类型和一个特定的子类型，中间由一条斜杠来分割 URIURI有两种形式，分别称为URL和URN URL 统一资源定位符是资源表示服最常见的形式，url描述了一台特定服务器上某资源的特定位置 事务一个http事务由一条(从客户端法网服务器的)请求命令和一个(从服务器发回客户端的)响应结果组成这种通信是通过名为http报文的格式化数据块进行的 方法每条http请求报文都包含一个方法 连接报文是如何通过传输控制协议连接从一个地方搬移到另一个地方去的 TCP/IPhttp是个应用层协议，http无需操心网络通信的具体细节，http无需操心网络通信的具体细节，它把联网的细节都交给了通用可靠的因特网传输协议（TCP/IP）TCP提供了： 无差错的数据传输 按序传输(数据总是会按照发送的顺序到达) 未分段的数据流(可以在任意时刻以任意尺寸将数据发送出去) 只要建立了TCP连接，客户端和服务器之间的报文交换就不会丢失，不会被破坏，不会在接收时出现错序 连接/IP地址/端口号在http客户端向服务器发送报文之前，需要用网际协议(IP)地址和端口号在客户端和服务器之间建立一条TCP/IP连接 web的组织结构代理——位于客户端和服务器之间的http中间实体缓存——http的仓库，使常用页面的副本可以保存在离客户端更近的地方网关——连接其他应用程序的特殊web服务器隧道——对http通信报文进行盲转发的特殊代理Agent代理——发起自动Http请求的半智能web客户端 代理http代理服务器是web安全、应用集成以及性能优化的重要组成模块(如图)代理位于客户端和服务器之间，接收所有客户端的http请求，并将这些请求转发给服务器(可能会对请求进行修改之后转发) 对用户来说，这些应用程序就是一个代理，代表用户访问服务器出于安全考虑，通常会将代理作为转发所有web流量的可信任中间节点使用。 缓存web缓存或者代理缓存是一种特殊的http代理服务器，可以将经过代理传送的常用文档复制保存起来，下一个请求同一文档的客户端就可以享受缓存的私有副本所提供的服务客户端从附近的缓存下载文档会比从远程web服务器下载快很多。http定义了很多功能，使得缓存更加高效，第7章会详细讲解 网关网关(gateway)是一种特殊的服务器，作为其他服务器的中间实体使用。通常用于将http流量转换成其他的协议。网关接受请求时就好像自己是资源的源端服务器，客户端看不出来自己是否正在与一个网关进行通信 隧道 TODO隧道是建立起来之后，就会在两条连接之间对原始数据进行盲转发的http应用程序http隧道通常用来在一条或多条http连接上转发非http数据，转发时不会窥探数据http隧道的一种常见用途是通过Http连接承载加密的安全套接字层(SSL)流量，这样SSL流量皆可以穿过只允许web流量通过的防火墙了 Agent代理用户Agent代理，是代表用户发起http请求的客户端程序，所有发布we请求的应用程序都是Http Agent代理.到目前为止，我们只提到过一种Http代理：web浏览器，但用户Agent代理还有很多其他类型比如，有些自己会在web上闲逛的自动用户Agent代理，可以在无人监视的情况下发布Http事务并获取内容。这些自动代理的名字通常都很生动，比如”网络蜘蛛” “web机器人” 第2章节：url与资源浏览因特网资源url是浏览器寻找信息时所需的资源位置，通过Url，人类和应用程序才能找到、使用、共享网上大量的数据资源。url是人们对http和其他协议的常用访问点：一个人将浏览器指向一个url，浏览器就会在幕后发送适当的协议报文来获取人们所期望的资源 url的语法大部分url方案的url语法都建立在这个由9部分构成的通用格式上1&lt;scheme&gt;://&lt;user&gt;:&lt;password&gt;@&lt;host&gt;:&lt;port&gt;/&lt;path&gt;;&lt;params&gt;?&lt;query&gt;#&lt;frag&gt; 表2-1：通用url组件TODO url快捷方式第3章节：http报文如何创建报文，以及如何理解他们了解如下概念： 报文是如何流动的 http报文的三个组成部分(起始行、首部、实体的主体部分) 请求和响应报文之间的区别 请求报文支持的各种功能(方法) 和响应报文一起返回的各种状态码 各种各样的http首部都是用来做什么的 报文流http报文是在http应用程序之间发送的数据块。这些数据块以一些文本形式的元信息开头，这些信息描述了报文的内容及含义、 报文流入源端服务器http使用术语流入(inbound)和流出(outbound)来描述事务处理的方向。报文流入源端服务器，工作完成之后，会流回用户的Agent代理中 报文向下游流动http报文会像河水一样流动，不管是请求报文还是响应报文，所有报文都会向下游流动。所有报文的发送者都在接受者的上游 报文的组成部分报文首部首部分类http规范定义了几种首部字段。应用程序也可以随意发明自己所用的首部。http首部可以分为以下几类： 通用首部 既可以出现在请求报文中，也可以出现在响应报文中 请求首部 提供更多有关请求的信息 响应首部 提供更多有关响应的信息 实体首部 描述主体的长度和内容，或者资源本身 扩展首部 规范中没有定义的新首部 方法安全方法http定义了一组被称为安全方法的方法。GET方法和HEAD方法都被认为是安全的，这就意味着使用GET或HEAD方法的HTTP请求都不会产生什么动作(http请求不会在服务器上产生什么结果) HEADHEAD方法与GET方法的行为类似，但服务器在响应中只返回首部。不会返回实体的主体部分。这就允许客户端在未获取实际资源的情况下，对资源的首部进行检查。使用HEAD可以： 在不获取资源的情况下了解资源的情况 通过查看响应中的状态码，看看某个对象是否存在 通过查看首部，测试资源是否被修改了 服务器开发者必须确保返回的首部与get请求所返回的首部完全相同 POST用来向服务器输入数据 TERACE客户端发起一个请求时，这个请求可能要穿过防火墙、代理、网关或其他一些应用程序。每个中间节点都可能会修改原始的HTTP请求,TRACE方法允许客户端在最终将请求发送给服务器时，看看它变成了什么样子TRACE请求会在目的服务器端发起一个”环回”诊断。行程最后一站的服务器会弹回一条TRACE响应，并在响应主体中携带它收到的原始请求报文。这样客户端就可以查看在所有中间http应用程序组成的请求/响应链上，原始报文是否，以及如何被毁坏或修改过 OPTIONSOPTIONS方法请求web服务器告知其支持的各种功能。可以询问服务器通常支持哪些方法，或者对某些特殊资源支持哪些方法 DELETEDELETE方法所做的事情就是请服务器删除URL所指定的资源。但是，客户端应用程序无法保证删除操作一定会被执行。因为HTTP规范允许服务器在不通知客户端的情况下撤销请求 状态码100 ~ 100 信息性状态码TODO 200 ~ 299 成功状态码300 ~ 399 重定向状态码重定向状态码要么告知客户端使用替代位置来访问他们所感兴趣的资源，要么就提供一个替代的响应而不是资源的内容，如果资源已被移动，可发送一个重定向状态码和一个可选的Location首部来告知客户端资源已被移走，以及现在可以在哪里找到它，这样，浏览器就可以在不打扰使用者的情况下，透明地转入新的位置了 TODO 400 ~ 499 客户端错误状态码有时客户端会发送一些服务器无法处理的东西，比如格式错误的请求报文，或者最常见的是，请求一个不存在的url 500 ~ 599 服务器错误状态码首部通用首部通用的信息性首部 Connection: 允许客户端和服务器指定与请求/响应连接有关的选项 Date: 提供日期和时间标志，说明报文是什么时间创建的 MIME-Version: 给出了发送端使用的MIME版本 Trailer: 如果报文采用了分块传输编码方式，就可以用这个首部列出位于报文trailer部分的首部集合 Transfer-Encoding: 告知接收端为了保证报文的可靠传输，对报文采用了什么编码方式 Update: 给出了发送端可能想要”升级”使用的新版本或协议 Via: 显示了报文经过的中间节点(代理、网关) 通用缓存首部http/1.0引入了第一个允许http应用程序缓存对象本地副本的首部，这样就不需要总是直接从源端服务器获取了，最新的http版本有非常丰富的缓存参数集。 Cache-Control: 用于随报文传送缓存指示 Pragma: 另一种随报文传送指示的方式，但并不专用于缓存 请求首部信息性首部 Cient-Ip: 提供了运行客户端的机器的IP地址 From: 提供了客户端用户的E-mail地址 Host: 给出了接受请求的服务器的的主机名和端口号 Referer: 提供了包含当前请求URI的文档的URL UA-Color: 提供了与客户端显示器的显示颜色有关的信息 VA-CPU: 给出了客户端CPU的类型或制造商 UA-Disp: 提供了与客户端显示器(屏幕)能力有关的信息 UA-OS: 给出了运行在客户端机器上的操作系统名称及版本 UA-Pixels: 提供了客户端显示器的像素信息 User-Agent: 将发起请求的应用程序名称告知服务器 Accept首部Accept首部为客户端提供了一种将其喜好和能力告知服务器的方式，包括他们想要什么，可以使用什么，以及最重要的，他们不想要什么，这样，服务器就可以根据这些额外信息，对要发送的内容作出更明智的决定，Accept首部会使连接的两端都受益。客户端会得到他们想要的内容，服务器则不会浪费时间和带宽发送客户端无法使用的东西 Accept: 告诉服务器能够发送哪些媒体类型 Accept-Charset: 告诉服务器能够发送哪些字符集 Accept-Encoding: 告诉服务器能够发送哪些编码方式 Accept-Language: 告诉服务器能够发送哪些语言 TE: 告诉服务器可以使用哪些扩展传输编码 条件请求首部有时客户端希望为请求加上某些限制。要求服务器在对请求进行响应之前确保某个条件为真 Expect: 允许客户端列出某请求所要求的服务器行为 If-Match: 如果实体标记与文档当前的实体标记相匹配，就获取这份文档 If-Modified-Since: 除非在某个指定的日止之后资源被修改过，否则就限制这个请求 If-None-Match: 如果提供的实体标记与当前文档的实体标记不符，就获取这份文档 If-Range: 允许对文档的某个范围进行条件请求 If-Unmodified-Since: 除非在某个指定日期之后资源没有被修改过，否则就限制这个请求 Range: 如果服务器支持范围请求，就请求资源的指定范围 安全请求首部http本身就支持一种简单的机制，可以对请求进行质询/响应认证。这种机制要求客户端在获取特定的资源之前，先对自身进行认证，这样就可以使事务稍微安全一些。 Authorization: 包含了客户端提供给服务器，以便对其自身进行认证的数据 cookie: 客户端用它想服务器传送一个令牌———它并不是真正的安全首部，但确实隐含了安全功能 代理请求首都随着因特网上代理的普遍应用，人们定义了几个首都来协助其更好的工作。 Max-Forward: 在通往源服务器的路径上，将请求转发给其他代理或网管的最大次数——与TRACE方法一同使用 Proxy-Authorization: 与Authorization首部相同，但这个首部是在与代理进行认证时使用的 Proxy-Connection: 与Connection首部相同，但这个首部是在与代理建立连接时使用的 响应首部信息性首部 Age: (从最初创建开始)响应持续时间 Public: 服务器为其资源支持的请求方法列表 Retry-After: 如果资源不可用的话，在此日期或时间重试 Server: 服务器应用程序软件的名称和版本 Title: 对HTML文档来说，就是HTML文档的源端给出的标题 Warning: 比原因短语中更详细的一些警告报文 协商首部如果资源有多种表示方式，http/1.1可以为服务器和客户端提供对资源进行协商的能力。 Accept-Range: 对此资源来说，服务器可接受的范围类型 Vary: 服务器查看的其他首部的列表，可能会使响应发生变化，也就是说，这是一个首部列表，服务器会根据这些首部的内容挑选出最适合的资源版本发送给客户端 安全响应首部 Proxy-Authenticate: 来自代理的对客户端的质询列表 Set-Cookie: 不是真正的安全首部，但隐含有安全功能，可以在客户端设置一个令牌，以便服务器对客户端进行标识 WWW-Authenticate: 来自服务器的对客户端的质询列表 实体首部实体首部提供了有关实体及其内容的大量信息，实体首部可以告知报文的接受者在对什么进行处理 Allow: 列出了可以对此实体执行的请求方法 Location: 告知客户端实体实际上位于何处，用于将接收端定向到资源的位置(url)上去 内容首部内容首部提供了与实体内容有关的特定信息，说明了其类型、尺寸以及处理它所需要的其他有用信息 Content-Base: 解析主体中的相对URL时使用的基础URL Content-Encoding: 对主体执行的任意编码方式 Content-Language: 理解主体时最适宜使用的自然语言 Content-Length: 主体的长度或尺寸 Content-Location: 资源实际所处的位置 Content-MD5: 主体的MD5校验 Content-Range: 在整个资源中此实体表示的字节范围 Content-Type: 这个主体的对象类型 实体缓存首部通用的缓存首部说明了如何或者什么时候进行缓存。实体的缓存首部提供了与被缓存实体有关的信息——比如，验证已缓存的资源副本是否仍然有效所需的信息，以及更好地估计已缓存资源何时失效所需的线索 Etag: 与此实体先挂你的实体标记 Expires: 实体不再有效，要从原始的源端再次获取此实体的日期和时间 Last-modified: 这个实体最后一次被修改的日期和时间 第4章节：连接管理http连接是http报文传输的关键通道。本章将学到： HTTP是如何使用TCP连接的 TCP连接的时延，瓶颈已经存在的障碍 HTTP的优化，包括并行连接、keep-alive(持久连接)和管道化连接 管理连接时应该以及不应该做的事情 TCP连接TCP/IP是全球计算机及网络设备都在使用的一种常用的分组交换网络分层协议集。客户端应用程序可以打开一条TCP/IP连接，连接到可能运行在世界任何地方的服务器应用陈程序。一旦连接建立起来了，在客户端和服务器的计算器之间交换的报文就永远不会丢失、受损、失序 TCP的可靠数据管道HTTP连接实际上就是TCP连接及其使用规则。 要想正确、快速地发送数据，就需要了解TCP的一些基本知识：TCP为HTTP提供了一条可靠的 比特传输管道 。从TCP连接一端填入的字节会从另一端以原有的顺序、正确的传送过来[如图] TCP流是分段的、由IP分组传送TCP的数据是通过名为IP分组(或IP数据报)的小数据块来发送的。这样的话，HTTP就是”HTTP over TCP over IP”这个”协议栈”中的最顶层。其安全版本HTTPS就是在HTTP和TCP之间插入了一个(称为TLS或SSL)密码加密层[如图] HTTP要传送一条报文时，会以流的形式将报文数据的内容通过一条打开的TCP连接按序传输。TCP收到数据流之后，会将数据流砍成称作段的小数据块，并将段封装在IP分组里，通过因特网进行传输每个TCP段都由IP分组来承载，从一个IP地址发送到另一个IP地址的。每个IP分组中都包括 一个IP分组首部(通常为20字节)—— 包含了源和目的IP地址、长度、其他的一些标记。 一个TCP段首部(通常为20字节)—— 包含了TCP端口号、TCP控制标记、以及用于数据排序和完整性检查的一些数字值 一个TCP数据块(0或者多个字节) 保持TCP连接持续不断的运行在任意时刻计算机都可以有几条TCP连接处于打开状态。TCP是通过端口号来保持所有这些连接持续不断的运行IP地址可以将你连接到正确的计算机，而端口号则可以将你连接到正确的应用程序上去，TCP连接是通过4个值来识别的；、1&lt;源IP地址、源端口号、目的IP地址、目的端口号&gt; 这4个值一起唯一地定义了一条连接。两条不同的TCP连接不能拥有4个完全相同的地址组件值(但不同的链接的部分组件可以拥有相同的值)[如图]承载TCP段的IP分组，它承载了TCP数据流中的小数据块 用TCP套接字编程TODO 【没看明白】[如图] TCP客户端和服务器是如何通过TCP套接字接口进行通信的 对TCP性能的考虑HTTP紧挨着TCP，位于其上层，所以HTTP事务的性能在很大程度上取决于底层TCP通道的性能。本章重点:TCP基本性能特点HTTP连接优化特性 HTTP事务的时延【图】 串行HTTP事务的时间线注意，与建立TCP连接，以及传输请求和响应报文的时间相比，事务处理时间可能是很短的。除非客户端或服务器超载，或增在处理复杂的动态资源，否则HTTP时延就是由TCP网络时延构成的 HTTP事务的时延有以下几种主要原因:1.客户端首先需要URI确定web服务器的IP地址和端口号。如果最近没有对URI中的主机名进行访问，通过DNS解析系统将URI中的主机名转换成一个IP地址可能要话费数十秒时间2.接下来，客户端会向服务器发送一条TCP连接请求，并等待服务器回送一个请求接受应答。每条新的TCP连接都会有连接建立时延。这个值通常最多只有一两秒钟，但如果有数百个HTTP事务的话，这个值会快速叠加3.一旦连接建立成功，客户端就会通过新建立的TCP管道来发送HTTP请求，数据到达时，web服务器会从TCP连接中读取请求报文，并对请求进行处理，因特网传输请求报文，以及服务器处理请求报文都需要时间4.然后，web服务器会回送HTTP响应，这也需要花费时间 这些TCP网络时延的大小取决于硬件速度、网络和服务器的负载，请求和响应报文的尺寸，以及客户端和服务器之间的距离。TCP协议的技术复杂性也会对时延产生巨大影响 性能聚焦区域最常见的TCP相关时延： TCP连接建立握手 TCP慢启动拥塞控制 数据聚集的Nagle算法 用于捎带确认的TCP延迟确认算法 TIME_WAIT时延和端口耗尽 TCP连接的握手时延TCP连接的握手时延建立一条新的TCP连接时，甚至是在发送任意数据之前，TCP软件之间会交换一系列的IP分组，对连接的有关参数进行沟通。如果连接只用来传送少量数据，这些交换过程就会严重降低HTTP性能 TCP连续握手需要经过以下几个步骤：1.请求新的TCP连接时，客户端要向服务器发送一个小的TCP分组(通常是40~60字节)这个分组中设置了一个特殊的SYN标记，说明这是一个连接请求2.如果服务器接受了连接，就会对一些连接参数进行计算，并向客户端回送一个TCP分组，这个分组中的SYN和ACK标记都被置空，说明连接请求已被接受3.最后，客户端向服务器回送一条确认信息，通知它连接已成功建立。现代的TCP栈都允许客户端在这个确认分组中发送数据 以上步骤如图所示： 【TODO】 延迟确认TODO TCP慢启动TCP数据传输的性能还取决于TCP连接的使用期。TCP连接会随着时间进行自我“调节”，起初会限制连接的最大速度，如果数据成功传输，会随着时间的推移提高传输的速度。这种调节被称为TCP慢启动，用于防止因特网的突然过载和拥堵。TCP慢启动限制了一个TCP端点在任意时刻可以传输的分组数。简单来说，每成功接受一个分组，发送端就有了另外两个分组的权限。如果某个HTTP事务有大量数据要发送，是不能一次将所有分组都发送出去的。必须发送一个分组，等待确认，然后可以发送两个分组，每个分组都必须被确认，这样就可以发送四个分组，以此类推，这种方式被称为”打开拥塞窗口”由于存在这种拥塞控制特性，所以新连接的传输速度会比已经交换过一定量数据的、已”调节”链接慢一些，由于已调节连接更快一些，所以HTTP中有一些可以重用现存连接的工具 TIME_WAIT累积与端口耗尽4.3 HTTP连接的处理常被误解的connection首部HTTP允许在客户端和最终的远端服务器之间存在一串HTTP中间实体(代理、告诉缓存等)。可以从客户端开始，逐条地将HTTP报文经过这些中间设备，转发到远端服务器上去(或者进行反向传输)在某些情况下，两个相邻的HTTP应用程序会为他们共享的连接应用一组选项。HTTP的Connection首部字段中有一个由逗号分隔的连接标签列表，这些标签为此连接指定了一些不会传播到其他连接中去的选项。比如，可以用Connection:close来说明发送完下一条报文之后必须关闭的连接 Connection首部可以承载3中不同类型的标签，因此有时会很令人费解: HTTP首部字段名，列出了只于此连接有关的首部 任意标签值，用于描述此连接的非标准选项 值close，说明操作完成之后需关闭这条持久连接 如果连接标签中包含了一个HTTP首部字段的名称，那么这个首部字段就包含了与一些连接有关的信息，不能将其转发出去。在将报文转发出去之前，必须删除Connection首部列出的所有首部字段。由于Connection首部可以防止无意中对本地首部的转发，因此将逐跳首部名放入Connection首部被称为”对首部的保护” 如下图 [todo] HTTP应用程序收到一条带有Connection首部的报文时，接收端会解析发送端请求的所有选项，并将其应用，然后会在此报文转发给下一跳地址之前，删除Connection首部以及Connection中列出的所有首部。而且，可能还会有少量没有作为Connection首部值列出，但一定不能被代理转发的逐跳首部，其中包括Proxy-Authenticate Proxy-Connection Transfer-Encoding Upgrade 串行事务处理时延如果只对连接进行简单的管理,TCP的性能时延可能会叠加起来。比如：假设有一个包含了三个图片的web页面。浏览器需要发起4个HTTP事务来显示此页面，1个用于顶层的HTML页面，3个用于嵌入的图片。如果每个事务都需要(串行地建立)一条新的连接，那么时延和慢启动就会叠加起来如下图 [todo] 有几种现存和新兴的方法可以提高HTTP的连接性能。 并行连接 通过多条TCP连接发起并发的HTTP请求 持久连接 重用TCP连接，以消除连接及关闭时延 管道化连接 通过共享的TCP连接发起并发的HTTP请求 复用的连接 交替传送请求和响应报文 4.4 并行连接HTTP允许客户端打开多条连接，并行地执行多个HTTP事务 4.4.1 并行连接可能会提高页面的加载速度4.4.2 并行连接不一定更快实际上，浏览器确实使用了并行连接，但他们会将并行连接的总数限制为一个较小的值（通常是4个）。服务器可以随意关闭来自特定客户端的超量连接 4.4.3 并行连接可能让人”感觉”更快一些4.5 持久连接HTTP/1.1允许HTTP设备在事务处理结束之后将TCP连接保持在打开状态，以便为未来的HTTP请求重用现存的链接。在事务结束之后仍然保持在打开状态的TCP连接被称为持久连接，非持久连接会在每个事务结束之后关闭。持久连接会在不同事务之间保持打开状态，直到客户端或服务器决定将其关闭为止。重用已对目标服务器打开的空闲持久连接，就可以避开缓慢的连接建立阶段。而且，已经打开的连接还可以避免慢启动的拥塞适应阶段，以便更快速地进行数据的传输 持久连接与并行连接配合时使用可能是最高效的方式。现在很多web应用程序都会打开少量的并行连接，其中每一个都是持久连接。持久连接有两种类型：比较老的HTTP/1.0+”keep-alive“连接，以及现代的HTTP/1.1”persistent”连接 HTTP/1.0+ keep-alive连接实现HTTP/1.0 keep-alive连接的客户端可以通过包含Connection:Keep-alive首部请求将一条连接保持在打开状态如果服务器愿意为下一条请求将链接保持在打开状态，就在响应中包含相同的首部，如果响应中没有Connection:Keep-Alive首部，客户端就认为服务器不支持keep-alive,会在发回响应报文之后关闭连接 keep-alive首部只是请求将连接保持在活跃状态。可以用Keep-Alive通用首部中指定的、由逗号分割的选项来调节keep-alive的行为： 参数timeout是在Keep-alive响应首部发送的。它估计了服务器希望将连接保持在活跃状态的时间。 参数max是在keep-alive响应首部发送的。他估计了服务器还希望为多少个事务保持此连接的活跃状态。这并不是一个承诺值 Keep-Alive首部还可支持任意未经处理的属性，这些属性主要用于诊断和调试。语法为name [=value] Keep-Alive首部完全是可选的，但只有在提供Connection:Keep-Alive时才能使用它 以下例子说明服务器最多还会为另外5个事务保持连接的打开状态，或者将打开状态保持到连接空闲了2分钟之后：12Connection: Keep-AliveKeep-Alive: max=5, timeout=120 Keep-Alive连接的限制和规则使用keep-alive连接时有一些限制和一些需要澄清的地方 在HTTP/1.0中，keep-alive并不是默认是使用的。客户端必须发送一个Connection:Keep-alive请求首部来激活keep-alive连接 Connection:Keep-Alive首部必须随所有希望保持持久连接的报文一起发送。如果客户端没有发送Connection:Keep-Alive首部，服务器就会在那条请求之后关闭连接 通过检测响应中是否包含Connection:Keep-Alive响应首部，客户端可以判断服务器是否会在发出响应之后关闭连接 只有在无需检测到连接的关闭即可确定报文实体主体部分长度的情况下，才能将连接保持在打开状态——也就是说实体的主体部分必须有正确的Content-Length，有多部件媒体类型，或者用分块传输编码的方式进行了编码。在一条keep-alive信道中回送错误的Content-Length是😕，这样的话，事务处理的另一端就无法精确地检测出一条报文的结束和另一条报文的开始。 代理和网关必须执行Connection首部的规则。代理或网管必须在将报文转发出去或将其高速缓存之前，删除在Connection首部中命名的所有首部字段以及Connection首部自身 Keep-Alive和哑代理TODO 插入Proxy-Connection网景的浏览器及代理实现者们提出了一个对盲中继问题的变通做饭，这种做法并不要求所有的web应用程序都支持高版本的HTTP，这种变通做法引入了一个名为Proxy-Connection的新首部，解决了在客户端后面紧跟着一个盲中继所带来的问题——但并没有解决所有其他情况下存在的问题。 持久连接的限制和规则TODO 关闭连接的奥秘连接管理——尤其是知道在什么时候以及如何去关闭连接——是HTTP的实用魔法之一。 第二部分 HTTP结构第5章 web服务器web服务器的实现web服务器实现了HTTP和相关的TCP连接处理。负责管理web服务器提供的资源，以及对web服务器的配置、控制及扩展方面的管理web服务器逻辑实现了HTTP协议、管理者web资源，并负责提供web服务器的管理功能。web服务器逻辑和操作系统共同负责管理TCP连接。底层操作系统负责管理底层计算机系统的硬件细节，并提供了TCP/IP网络支持、负责装载web资源的文件系统以及控制当前计算活动的进程管理功能。 web服务器有各种不同的形式： 可以在标准的计算机系统上安装并运行通用的软件web服务器 可以买一台web服务器设备，通常会是一台安装在时髦机架上的计算机，里面的软件会预装并配置好。 在少量计算机芯片上实现嵌入式web服务器，使其成为完美的(便携式)消费类设备管理控制台。 通用软件web服务器。。。中间可能有漏。。。 以后再补充 第6章 代理6.8.3 Allow首部Allow实体首部字段列出了请求URI表示的资源所支持的方法列表。如果URI为*的话，列出的就是整个服务器所支持的方法列表，例如：Allow: GET, HEAD, PUT可以将Allow首部作为请求首部，建议在新的资源商支持某些方法。可以将Allow首部作为请求首部，建议在新的资源上支持某些方法，并不要求服务器支持这些方法，但应该在相应的响应中包含一个Allow首部，列出它实际支持的方法。 第7章 缓存 （重点）web缓存是可以自动保存常见文档副本的HTTP设备。当web请求抵达缓存时，如果本地有”已缓存的”副本，就可以从本地存储设备而不是原始服务器中提取这个文档，使用缓存有如下优点： 缓存减少了冗余的数据传输，节省了你的网络费用 缓存缓解了网络瓶颈的问题，不需要更多的带宽就能够更快的加载 缓存降低了对原始服务器的要求。服务器可以更快地响应，避免过载的出现。 缓存降低了距离时延，因为从较远的地方加载页面会更慢一点 7.1冗余的数据传输有很多客户端访问一个流行的原始服务器页面时，服务器会多次传输同一份文档，每次传送给一个客户端。一些相同的字节会在网络中一遍遍地传输，这些冗余的数据传输会耗尽昂贵的网络带宽，降低传输速度，家中web服务器的负载。有了缓存，就可以保留第一条服务器响应的副本，后继请求就可以由缓存的副本来应对了，这样可以减少哪些流入/流出原始服务器的、被浪费掉了的重复流量。 7.2带宽瓶颈缓存还可以缓解网络的瓶颈问题，很多网络为本地网络客户端提供的带宽比为远程服务器提供的带宽要宽，客户端会以路径上最慢的网速访问服务器。如果客户端从一个快速局域网的缓存中得到了一份副本，那么缓存就可以提高性能——尤其是要传输比较大的文件时。 【配图】 7.3 瞬间拥塞缓存在破坏瞬间拥塞时显得非常重要(微博服务器崩溃) 7.4 距离时延即使带宽不是问题，距离也可能成为问题。每台网络路由器都会增加因特网流量的时延。将缓存放在附近的机房里可以将文件传输距离从数千英里缩短为数十米 7.5 命中的和未命中的缓存无法保存世界上每份文档的副本。可以用已有的副本为某些到达缓存的请求提供服务。这被称为缓存命中，其他一些到达缓存的请求可能会由于没有副本可用，而被转发给原始服务器，这被称为缓存未命中 7.5.1 再验证原始服务器的内容可能会发生变化，缓存要不时对其进行检测，看看他们保存的副本是否仍是服务器上最新的副本。为了有效地进行再验证，HTTP定义了一些特殊的请求，不用从服务器上获取整个对象，就可以快速检测出内容是否是最新的 缓存可以在任意时刻，以任意的频率对副本进行再验证，但由于缓存中通常会包含数百万的文档，而且网络带宽是很珍贵的，所以大部分缓存只有在客户端发起请求，并且副本旧的足以需要检测的时候，才会对副本进行再验证。 缓存对缓存的副本进行再验证时，会向原始服务器发送一个小的再验证请求，如果内容没有变化，服务器会以一个小的304not modified进行响应。只要缓存知道副本仍然有效，就会再次将副本标识为暂时新鲜的，并将副本提供给客户端，这被称为再验证命中或缓存命中。这种方式确实要与原始服务器进行核对，所以会比单纯的缓存命中要慢，但他没有从服务器中获取对象数据，所以要比缓存未命中快一些。 Http为我们提供了几个用来对已缓存对象进行再验证的工具，但最常用的是If-Modified-Since首部，将这个首部添加到GET请求中去，就可以告诉服务器，就可以告诉服务器，只有在缓存了对象的副本之后，又对其进行了修改的情况下才发送此对象。这里列出了在3种情况下(服务器内容未被修改，服务器内容已被修改，服务器上的对象删除了) 服务器收到GET If-Modified-Since请求时会发生的情况： 再验证命中如果服务器对象未被修改，服务器会向客户端发送一个小的HTTP 304NOt Modified响应 再验证未命中如果服务器对象与已缓存副本不同，服务器向客户端发送一条普通的、带有完整内容的HTTP200 OK响应 对象被删除如果服务器对象被删除了，服务器就回送一个404Not Found响应，缓存也会将其副本删除 7.5.2命中率由缓存提供服务的请求所占的比例被称为缓存命中率，有时也被称为文档命中率 7.5.3字节命中率由于文档并不全是同一尺寸的，所以文档命中率并不能说明一切，有些大型对象被访问的次数可能较少，但由于尺寸的原因，对整个数据流量的贡献却更大，因此，有些人更愿意使用字节命中率作为度量值。 7.5.4 区分命中和未命中的情况HTTP没有为用户提供一种手段来区分响应式缓存命中的，还是访问原始服务器得到的，在这两种情况下，响应码都是200 OK,说明响应有主体部分，有些商业代理缓存会在Via首部附加一些额外信息，以描述缓存中发生的情况。客户端有一种方法可以判断响应是否来自缓存，就是使用Date首部，将响应中Date首部的值与当前时间进行比较，如果响应中的日期比较早，客户端通常就可以认为这是一条缓存的响应。客户端也可以通过Age首部来检测缓存的响应。 7.6 缓存的拓扑结构私有缓存、共有缓存【图】 7.6.1 私有缓存web浏览器中有内建的私有缓存——大多数浏览器都会将常用文档缓存在你个人电脑的磁盘和内容中。并且允许用户去配置缓存的大小和各种设置。还可以去看看浏览器的缓存中有什么内容。 【咋看？？？】 7.6.2 公有代理缓存公有缓存是特殊的共享代理服务器，被称为缓存代理服务器，代理缓存会从本地缓存中提供文档，或者代表用户与服务器进行联系，公有缓存会接受来自多个用户的访问，所以通过它可以更好地减少冗余流量。 7.6.3 代理缓存的层次结构在实际中，实现层次化的缓存时是有意义的，在这种结构中，在较小缓存中未命中的请求会被导向较大的父缓存，由他来为剩下的哪些”提炼过的”流量提供服务，在靠近客户端的地方使用小型廉价缓存，而更高层次中，则逐步采用更大、功能更强的缓存来装载多用户共享的文档 最好大部分用户都能在附近的第一级缓存中命中，如果没有命中，较大的父缓存可能能够处理他们的请求，在缓存层次结构很深的情况下，请求可能要穿过很长一溜缓存，但每个拦截代理都会添加一些性能损耗，当代理链路变得很长的时候，这种性能损耗会变得非常明显。 7.6.4 网络缓存、内容路由、对等缓存有些网络结构会构建复杂的网状缓存，而不是简单地缓存层次结构。网状缓存中的代理缓存之间会以更加复杂的方式进行对话，做出动态的缓存通信决策，决定与哪个父缓存进行对话，或者决定彻底绕开缓存，直接链接原始服务器。这种代理缓存会决定选择何种路由对内容进行访问、管理、传送，因此可将其称为内容路由器。网状缓存中为内容路由设计的缓存要完成下列所有功能： 根据URL在父缓存或原始服务器之间进行动态选择。 根据URL动态地选择一个特定的父缓存。 前往父缓存之前，在本地缓存中搜索已缓存的副本。 允许其他缓存对其缓存的部分内容进行访问，但不允许因特网流量通过他们的缓存 缓存之间这些更为复杂的关系允许不同的组织互为对等实体，将他们的缓存连接起来以实现共赢。提供可选的对等支持的缓存被称为兄弟缓存。HTTP并不支持兄弟缓存，所以人们通过一些协议对HTTP进行了扩展。 7.7. 缓存的处理步骤现代的商业化代理缓存相当复杂。这些缓存构建得非常高效(数据结构一定非常好),可以支持HTTP和其他一些技术的各种高级特性。但除了一些微妙的细节之外，web缓存的基本工作原理大多很简单。对一条HTTP GET报文的基本缓存处理过程包括7个步骤：1.接收 —— 缓存从网络中读取抵达的请求报文2.解析 —— 缓存对报文进行解析，提取出URL和各种首部3.查询 —— 缓存查看杀死否有本地副本可用，如果没有，就获取一份副本(并将其保存在本地)4.新鲜度检测 —— 缓存查看已缓存副本是否足够新鲜，如果不是，就询问服务器是否有任何更新5.创建响应 —— 缓存会用新的首部和已缓存的主体来构建一条响应报文6.发送 —— 缓存通过网络将响应回发给客户端7.日志 —— 缓存可选的创建一个日志文件条目来描述这个事务 7.7.3 第三步 —— 查询在第三步中，缓存获取了URL，查找本地副本。本地副本可能存储在内存、本地磁盘，甚至附近的另一台计算机中。专业级的缓存会使用快速算法来确定本地缓存中是否有某个对象。如果本地没有这个文档，它可以根据情形和配置，到原始服务器或父代理中去取，或者返回一条错误信息。已缓存对象中包含了服务器响应主体和原始服务器响应首部，这样就会在缓存命中时返回正确的服务器首部，已缓存对象中还包含了一些元数据，用来记录对象在缓存中停留了多长时间，以及它被用过多少次等。 7.7.4 第四步 —— 新鲜度检测客户端发送给缓存的所有请求首部自身都可以强制缓存进行再验证，或者完全避免验证，这使得事情变得更加复杂了。HTTP有一组非常复杂的新鲜度检测规则，缓存产品支持的大量配置选项，以及与非HTTP新鲜度标准进行互通的需要则使问题变得更加严重了。 7.7.5 第五步 —— 创建响应缓存会将已缓存的服务器响应首部作为响应首部的起点。然后缓存对这些基础首部进行了修改和扩充。缓存会向首部插入新鲜度信息(Cache-Control Age Expires首部)，而且通常会包含一个Via首部来是说明请求是由一个代理缓存提供的。注意，缓存不应该调整Date首部。Date首部表示的是原始服务器最初产生这个对象的日期。 7.8 保持副本的新鲜HTTP有一些简单的机制可以在不要求服务器记住有哪些缓存拥有其文档副本的情况下，保持已缓存数据与服务器数据之间充分一致。HTTP将这些简单的机制称为文档过期，和服务器再验证。【配图】 7.8.1 文档过期通过特殊的HTTP Cache-Control首部和Expire首部，HTTP让原始服务器向每个文档附加了一个”过期日期”这些首部说明了在多长时间内可以将这些内容视为新鲜的。在缓存文档过期之前，缓存可以以任意频率使用这些副本，而无需与服务器联系——当然，除非客户端请求中包含有组织提供已缓存或未验证资源的首部。但一旦已缓存文档过期，缓存就必须与服务器进行核对，询问文档是否被修改过，如果被修改过，就要获取一份新鲜(带有新的过期日期)的副本 7.8.2 过期日期和使用期服务器用HTTP/1.0+的Expires首部或者HTTP/1.1的Cache-Control：max-age响应首部来制定过期时间，同时还会带有响应主体。Expires首部和Cache-Control:max-age首部所做的事情本质上是一样的，但由于Cache-Control首部使用的是先对时间而不是绝对时间，所以我们更倾向于使用比较新的Cache-Control首部。 7.8.3 服务器再验证仅仅是已缓存文档过期了并不意味者他和原始服务器上目前处于活跃状态的文档有实际的区别；这只是意味着到了要进行核对的时间了。这种情况被称为“服务器再验证”说明缓存需要询问原始服务器文档是否发生了变化。 如果再验证先试试内容发生了变化，缓存会获取一份新的文档副本，并将其存储在文档的位置上，然后将文档发送给客户端。 如果再验证显示内容内有发生变化，缓存只需要获取新的首部，包括一个新的过期日期，并对缓存中的首部进行更新就行了 7.8.4 用条件方法进行再验证HTTP的条件方法可以高效地实现再验证。HTTP允许缓存向原始服务器发送一个”条件get”，请求服务器只有在文档与缓存中现有的副本不同时，才回送对象主体，通过这种方式，将新鲜度检测和对象获取结合成了单个条件GET,向GET请求报文中添加一些特殊的条件首部，就可以发起条件GET。只有条件为真时，web服务器才会返回对象。 HTTP定义了5个条件请求首部，对缓存再验证来说最有用的2个首部是If-Modified-Since和If-None-Match,所有的条件首部都以前缀”If”开头 7.8.6 If-None-Match:实体标签再验证有些情况下仅使用最后修改日期进行再验证是不够的。 有些文档可能会被周期性地重写，但实际包含的数据常常是一样的，尽管内容没有变化，但修改日期会发生变化。 有些文档可能被修改了，但所做的修改并不重要，不需要让世界范围内的缓存都重装数据 有些服务器无法准确地判定其页面的最后修改日期。 有些服务器提供的文档会在亚秒间隙发生变化，对这些服务器来说，以一秒为粒度的修改日期可能不够用。 为了解决这些问题，HTTP允许用户对被称为实体标签(ETag)的”版本标识符”进行比较。实体标签是附加到文档上的任意标签，他们可能包含了文档的序列号或版本名，或者是文档内容的校验和其他指纹信息。 当发布者对文档进行修改时，可以修改文档的实体标签来说明这个新的版本。这样，如果实体标签被修改了，缓存就可以用If-None-Match条件首部来GET文档的新副本了。 7.8.8 什么时候应该使用实体标签和最近修改日期如果服务器回送一个实体标签，HTTP/1.1客户端就必须使用实体标签验证器，如果服务器只回送了一个Last-Modified值，客户端就可以使用If-modified-Since验证，如果实体标签和最后修改日期都提供了，客户端就应该使用这两种再验证方案，这样HTTP/1.0和HTTP/1.1缓存就都可以正确响应了。 除非HTTP/1.1原始服务器无法生成标签验证器(ETag),否则就应该发送一个出去(服务器端应做的)，如果使用弱实体标签有优势的话，发送的可能就是个弱实体标签，而不是强实体标签。而且最好同时发送一个最近修改值。如果HTTP/1.1缓存或服务器收到的请求既带有If-Modified-Since，又带有实体标签条件首部，那么只有这两个条件都满足时，才能返回304Not Modified响应。 7.9 控制缓存的能力服务器可以通过HTTP定义的几种方式来指定在文档过期之前可以将其缓存多长时间。按照优先级递减的顺序，服务器可以： 附加一个Cache-Control: no-store 首部到响应中去 附加一个Cache-Control: no-cache 首部到响应中去 附加一个Cache-Control: mmust-revalidate 首部到响应中去 附加一个Cache-Control: max-age 首部到响应中去 附加一个Expires日期首部到响应中去 不附加过期信息，让缓存确定自己的过期日期 7.9.1 no-store与no-cacheHTTP/1.1提供了几种限制对象缓存，或限制提供已缓存对象的方式，以维持对象的新鲜度。no-store和no-cache首部可以防止缓存提供未经证实的已缓存对象：123Pragma: no-cacheCache-Control: no-storeCache-Control: no-cache 标识为no-store的响应会禁止缓存对响应进行复制。缓存通常会像非缓存代理服务器一样，向客户端转发一条no-store响应，然后删除对象。【本质上是不存储数据在缓存中】 标识为no-cache的响应实际上是可以存储在本地缓存区的。只是在与原始服务器进行新鲜度再验证之前，缓存不能将其提供给客户端使用。这个首部使用do-not-serve-from-cache-without-revalidation这个名字会更恰当一点 7.9.2 max-age响应首部Cache-Control:max-age首部表示的是从服务器将文档传来之时起，可以认为此文档处于新鲜状态的秒数。还有一个s-maxage首部,其行为与max-age类似，但仅适用于共享(公用)缓存12Cache-Control: max-age=3600Cache-Control: s-maxage=3600 7.9.3Expires响应首部不推荐使用Expires首部，他指定的是实际的过期日期而不是秒数，有些服务器还会回送一个Expires:0响应首部，试图将文档置于永远过期的状态。 7.9.4must-revalidate响应首部1Cache-Control:must-revalidate 在事先没有跟元素是服务器进行再验证的情况下，不能提供这个对象的陈旧副本，缓存仍然可以随意提供新鲜的副本。如果在缓存进行must-revalidate新鲜度检查时，原始服务器不可用，缓存就必须返回一条504Gateway Timeout错误 7.9.6 客户端的新鲜度限制web浏览器都有refresh或reload按钮，可以强制对浏览器或代理缓存中可能过期的内容进行刷新。refresh按钮会发布一个附加了Cache-Control请求首部的GET方法，这个请求会强制进行再验证， 或者无条件地从服务器获取文档。refresh的确切行为取决于特定的浏览器、文档、连接缓存的配置 7.10 设置缓存控制本章简要介绍Apache web服务器是怎样支持缓存控制的。 7.10.2 通过HTTP-EQUIV控制HTML缓存HTTP服务器响应首部用于回送稳当的待其信息以及缓存控制信息。web服务器与配置文件进行交互，为所提供的文档分配正确的Cache-Control首部 为了让作者在无需与web服务器的配置文件进行交互的情况下，能够更容易地为所提供的HTML文档分配HTTP首部信息，HTML2.0定义了&lt;META HTTP-EQUIV&gt;标签。例子如下：1&lt;META HTTP-EUQIV=&quot;Cache-Control&quot; CONTENT=&quot;no-cache&quot;&gt; 支持这个可选特性会增加服务器的额外负载，这些值也只是静态的，而且他只支持HTML，不支持很多其他的文件类型，所以很少有web服务器和代理支持此特性。 &lt;META HTTP-EQUIV&gt;标签并不是控制文档缓存特性的好方法。通过配置正确的服务器发出HTTP首部，是传送文档缓存控制请求的唯一可靠的方法。 7.11 详细算法Date首部说明了文档是在什么时候离开原始服务器的，但并没有说明文档在到缓存的传输过程中花费了多长时间，如果文档的传输经过了一长串的代理和父缓存，网络时延可能会相当大。 第8章 集成点: 网管、隧道、中继http已成为应用程序开发者的一种基本构造模块，开发者们可以在http上捎回其他的协议内容(比如，可以将其他协议的流量包裹在http中，用http通过隧道或者中继方式将这些流量穿过公司的防火墙)web上所有资源都可以使用http协议，而且其他应用程序和应用程序协议也可以利用http来完成他们的任务 本章节会讨论： 在http和其他协议及应用程序之间起到接口作用的网关 允许不同类型的web应用程序互相通信的应用程序接口 允许用户在http连接上发送非http流量的隧道 作为一种简化的http代理，一次将数据转发一跳的中继 8.1 网关HTTP扩展和接口的发展是由用户需求驱动的。要再web上发布更复杂资源的需求出现时，人们很快就明确了一点；单个应用程序无法处理所有这些能想到的资源。 为了解决这个问题，开发者提出了网关的概念，网关可以作为某种翻译器使用，它抽象出了一种能够到达资源的方法。网关是资源和应用程序之间的粘合剂。应用程序可以请求网关来处理某条请求，网关可以提供一条响应。网关可以向数据库发送查询语句，或者生成动态的内容，就像一个门一样，进去一条请求，出来一个响应。 图8-1显示的是一种资源网关。在这里，服务器就是作为连接数据库内容的网关使用的，客户端只是在通过http请求资源，而服务器在与网关进行交互以获取资源。 有些网关会自动将HTTP流量转换为其他协议，这样http客户端无需了解其他协议，就可以与其他应用程序进行交互了(图8-2) 客户端和服务器端网关 服务器端网关： 通过HTTP与客户端对话，通过其他协议与服务器通信 客户端网关： 通过其他协议与客户端对话，通过http与服务器通信 8.3资源网关最常见的网关、应用程序服务器，会将目标服务器与网关集合在一个服务器中实现。应用程序服务器是服务器端网关，与客户端通过http进行通信，并与服务器端的应用程序相连。 请求需要使用网关的资源时，服务器会请辅助应用程序来处理请求。服务器会将辅助应用程序所需的数据传送给他。通常就是整条请求，或者用户想在数据库上运行的请求之类的东西。 8.3.1 CGICGI(Common Gateway Interface)通用网关接口CGI协议为外部翻译器与现有的HTTP服务器提供了一种简洁的接口方式。 8.5 隧道我们已经讨论了几种不同的方式，通过这些方式可以用HTTP对不同类型的资源进行访问，或者使用HTTP来启动应用程序到应用程序的通信。在本节中，我们要看看HTTP的另一种方法——web隧道，这种方式可以通过HTTP应用程序访问使用非HTTP协议的应用程序。 8.5.1 用Connect建立HTTP隧道web隧道是用HTTP的CONNECT方法建立起来的。CONNECT方法请求隧道网关创建一条到达任意目的服务器和端口的tcp连接，并对客户端和服务器之间的后续进行盲转发。下图显示了CONNECT方法如何建立起一条到达网关的隧道。 1.CONNECT请求除了起始行之外，CONNECT的语法与其他HTTP方法类似。一个后面跟着冒号和端口号的主机名取代了请求URI。主机和端口都必须制定：12CONNECT home.netscape.com:443 HTTP/1.0User-Agent: Mozilla/4.0 和其他HTTP报文一样，起始行之后，有零个或多个HTTP请求首部字段。 2.CONNECT响应发送了请求之后，客户端会等待来自网关的响应。和普通HTTP报文一样，响应码200表示成功。按照惯例，响应中的原因短语通常被设置为”Connection Established”12HTTP/1.0 200 Connection EstablishedProxy-agent: Netscape-Proxy/1.1 与普通HTTP响应不同，这个响应并不需要包含Content-Type首部，此时连接只是对原始字节进行转接，不再是报文的承载者，所以不需要使用内容类型了 8.5.2 数据隧道、定时、连接管理管道化数据对网关是不透明的，所以网关不能对分组的顺序和分组流作任何假设。一旦隧道尽力起来了，数据就可以在任意时间流向任意方向了。（隧道的两端必须做好在任意时刻接受来自连接任一端分组的准备，而且必须将数据立即转发出去。 8.5.3 SSL隧道最初开发web隧道是为了通过防火墙来传输加密的SSL流量。很多组织都会将所有流量通过分组过滤路由器和代理服务器以隧道方式传输，以提升安全性。但有些协议，比如加密SSL,其信息是加密的，无法通过传统的代理服务器转发。隧道会通过一条HTTP链接来传输SSL流量，以穿过端口80的HTTP防火墙 为了让SSL流量经现存的代理防火墙进行传输，HTTP中添加了一项隧道特性，在此特性中，可以将原始的加密数据放在HTTP报文中好，通过普通的HTTP信道传送。通常会用隧道将非HTTP流量传过端口过滤防火墙。但是，这项特性可能会被滥用，使得恶意协议通过HTTP隧道流入某个组织内部。 8.5.4 SSL隧道与HTTP/HTTPS网关的对比8.5.6 隧道的安全性考虑岁到网关无法验证目前使用的协议是否就是他原本打算经过隧道传输的协议。因此，比如说，一些喜欢捣乱的用户可能会通过本打算用于SSL的隧道，越过公司防火墙传递因特网游戏流量，而恶意用户可能会用隧道打开Telnet会话，或用隧道绕过公司的E-mail扫描器来发送E-mail 为了降低对隧道的滥用，网关应该职位特定的知名端口，比如HTTPS的端口443打开隧道 8.6 中继HTTP中继(relay)是没有完全遵循HTTP规范的简单HTTP代理。中继负责处理HTTP中建立连接的部分，然后对字节进行盲转发。HTTP很复杂，所以实现基本的代理功能并对流量进行盲转发，而且不执行任何首 部和方法逻辑，有时是很有用的。盲中继很容易实现，所以有时会提供简单的过滤、 诊断或内容转换功能。但这种方式可能潜在严重的互操作问题，所以部署的时候要 特别小心。某些简单盲中继实现中存在的一个更常见(也更声名狼藉的)问题是，由于它们无 法正确处理 Connection 首部，所以有潜在的挂起 keep-alive 连接的可能。下图对这种情况进行了说明。 第9章 web机器人本章我们来仔细了解一下被称为 Web 机器人(Web robot)的自活跃(self-animating) 用户代理，以继续我们的 HTTP 架构之旅。 Web 机器人是能够在无需人类干预的情况下自动进行一系列 Web 事务处理的软件 程序。很多机器人会从一个 Web 站点逛到另一个 Web 站点，获取内容，跟踪超链， 并对它们找到的数据进行处理。比如”爬虫” 9.1 爬虫及爬行方式Web 爬虫是一种机器人，它们会递归地对各种信息性 Web 站点进行遍历，获取第 一个 Web 页面，然后获取那个页面指向的所有 Web 页面(超链)，然后是那些页面指向的 所有 Web 页面，依此类推。 9.1.1 从哪儿开始:根集爬虫开始访问的 URL 初始集合 被称作根集(root set) 9.1.2 链接的提取以及相对链接的标准化爬虫在 Web 上移动时，会不停地对 HTML 页面进行解析。它要对所解析的每个页 面上的 URL 链接进行分析，并将这些链接添加到需要爬行的页面列表中去，并这些链接从相对 URL 转换为绝对形式。 9.1.3 避免环路的出现机器人在 Web 上爬行时，要特别小心不要陷入循环，或环路(cycle)之中 9.1.4 循环与复制环路对爬虫的害处： 使爬虫陷入循环，爬虫会消耗掉很多网络带宽在不停地获取相同的页面上 如果爬虫与被循环请求的web服务器连接良好，它会击垮Web站点，阻止所有真实用户访问这个站点 爬虫应用程序会被重复的内容所充斥，毫无意义 9.1.5 面包屑留下的痕迹由于 URL 的数量巨大，所以， 要使用复杂的数据结构以便快速判定哪些 URL 是曾经访问过的 (数据量越大，越要设计复杂的数据结构)，数据结构在访问速 度和内存使用方面都应该是非常高效的(时间复杂度、空间复杂度)，机器人至少要用到搜索树或散列表，以快速判定某个 URL 是否被访问过。 这里列出了大规模Web爬虫对其访问过的地址进行管理时使用的一些有用的技术 树和散列表复杂的机器人可能会用搜索树或散列表来记录已访问的 URL 有损的存在位图为了减小空间，一些大型爬虫会使用有损数据结构，比如存在位数组，用一个散列函数将每个 URL 都转换成一个定长的数字，这个数字在 数组中有个相关的“存在位”，如果存在位已经置位了，爬虫就认为已经爬行过那个 URL 了。 检查点一定要将已访问 URL 列表保存到硬盘上，以防机器人程序崩溃 分类随着 Web 的扩展，在一台计算机上通过单个机器人来完成爬行就变得不太现实 了。那台计算机可能没有足够的内存、磁盘空间、计算能力，或网络带宽来完成 爬行任务。有些大型 Web 机器人会使用机器人“集群”，每个独立的计算机是一个机器人， 以汇接方式工作。为每个机器人分配一个特定的 URL“片”，由其负责爬行。这 些机器人配合工作，爬行整个 Web。机器人个体之间可能需要相互通信，来回传 送 URL，以覆盖出故障的对等实体的爬行范围，或协调其工作。 9.1.8 文件系统连接环路文件系统中的符号连接会造成特定的潜在环路图 9-3b 的问题是 subdir/ 是个指向“/”的环路，但由于 URL 看起来有所不同，所以 机器人无法单从 URL 本身判断出文档是相同的。毫无戒备的机器人就有了陷入循环 的危险。如果没有某种循环检测方式，这个环路就会继续下去，通常会持续到 URL 的长度超过机器人或服务器的限制为止。 9.1.9 动态虚拟Web空间 9.1.10 避免循环和重复没有什么简单明了的方式可以避免所有的环路。实际上，经过良好设计的机器人中 要包含一组试探方式，以避免环路的出现。 在机器人会遇到的各种危险的Web中，有些技术的使用可以使机器人有更好的表现。 规范化 URL将URL转换为标准形式以避免语法上的别名 广度优先的爬行以广度优先的方式来调度 URL 去访问 Web 站点，就可以将环路的影响最小化 节流限制一段时间内机器人可以从一个 Web 站点获取的页面数量 限制 URL 的大小用 URL 长度来限 制爬虫可能会带来些麻烦;但如果每当请求的 URL 达到某个特定长度时，都记 录一次错误的话，就可以为用户提供一种检查某特定站点上所发生情况的方法。 URL/ 站点黑名单 模式检测 内容指纹用内容指纹的机器人会获取页面内容中的字节，并计算出一个校验和，MD5 这样的报文摘要函数就常被用于指纹计算。 9.2 机器人机器人和所有其他 HTTP 客户端程序并没有什么区别。它们也要遵守 HTTP 规范中 的规则。发出 HTTP 请求并将自己广播成 HTTP/1.1 客户端的机器人也要使用正确 的 HTTP 请求首部。很多机器人都试图只实现请求它们所查找内容所需的最小HTTP集。 9.2.1 识别请求首部在追踪错误爬虫的所有者，以及向服务器提供机器人所能处理的内容类型时，这些 信息都是很有用的。鼓励机器人实现者们使用的基本识别首部包括如下内容。 User-Agent将发起请求的机器人名字告知服务器。 From提供机器人的用户 / 管理者的 E-mail 地址。 Accept告知服务器可以发送哪些媒体类型。10 这有助于确保机器人只接收它感兴趣的内 容(文本、图片等)。 Referer提供包含了当前请求 URL 的文档的 URL。（这怎么能知道呢，还有再多存出一份referer url吗？） 9.2.2 虚拟主机9.2.3 条件请求9.2.4 对响应的处理很多机器人的兴趣主要在于用简单的 GET 方法来获取所请求的内容，所以，一般不 会在处理响应的方式上花费太多时间。但是，使用了某些 HTTP 特性(比如条件请 求)的机器人，以及那些想要更好地探索服务器，并与服务器进行交互的机器人则 要能够对各种不同类型的 HTTP 响应进行处理。 1. 状态码2. 实体机器人实现者可能会去扫描 HTML 文 档的 HEAD 组件，以查找 http-equiv 信息。??? 9.2.5 User-Agent导向站点管理者应该设计一个处理机器人请求的策略。比如，它们可以为所有其他特性 不太丰富的浏览器和机器人开发一些页面，而不是将其内容限定在特定浏览器所支 持的范围。 9.3 行为不当的机器人• 失控机器人机器人发起HTTP请求的速度要比人类快得多，它们通常都运 行在具有快速网络链路的高速计算机上,如果机器人陷入了环路之中，就可能会向Web服务器发出大量的负载——很可能会使服务器过载.• 失效的 URL• 很长的错误 URL由于环路和编程错误的存在，机器人可能会向 Web 站点请求一些很大的、无意 义的 URL。如果 URL 足够长的话，就会降低 Web 服务器的性能，使Web服务器的访问日志杂乱不堪. 9.4 拒绝机器人访问管理员提供了一个被称为“拒绝机器人访问标准”的标准，但通常只是根据存储访问控制信息的文件而将其称为robots.txt。 …暂时省略较多机器人相关内容 9.6 搜索引擎得到最广泛使用的web机器人都是因特网搜索引擎。现在 Web 上很多最流行的站点都是搜索引擎。(百度)，很多 Web 用户将其作为起始点，它 们会为用户提供宝贵的服务，帮助用户找到他们感兴趣的信息。Web 爬虫为因特网搜索引擎提供信息，它们获取 Web 上的文档，并允许搜索引擎 创建与本书后面的索引类似的索引，用以说明哪些文档中有哪些词存在。搜索引擎 是 Web 机器人的主要来源 9.6.1 大格局搜索引擎要用复杂的爬虫 来获取数十亿 Web 页面，还要使用复杂的查询引擎来处理数百万用户产生的查 询负荷。 9.6.2 现代搜索引擎结构现在的搜索引擎都构建了一些名为“全文索引”的复杂本地数据库，装载了全世界 的 Web 页面，搜索引擎爬虫会搜集 Web 页面，把它们带回家，并将其添加到全文索引中去。 9.6.3 全文索引全文索引就是一个数据库，创建了索引之后，就不需要对文档自身进行扫描了。 TODO … ❣️]]></content>
      <categories>
        <category>http</category>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>http</tag>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue-cli3都有些什么特异功能？]]></title>
    <url>%2F2019%2F05%2F07%2Fvue_cli_feature%2F</url>
    <content type="text"><![CDATA[为了快速开发，少走弯路，决定好好研读下vue-cli3官方文档 一、使用命令在vue cli中，会默认安装@vue/cli-service，@vue/cli-service中有vue-cli-service命令。项目中的package.json文件中的script表示可执行命令，可通过npm 或 yarn 调用这些script:package.json ↓ 123456&#123; &quot;scripts&quot;: &#123; &quot;serve&quot;: &quot;vue-cli-service serve&quot;, &quot;build&quot;: &quot;vue-cli-service build&quot; &#125;&#125; terminal ↓12npm run serveyarn serve serve 命令会启动一个开发服务器 (基于 webpack-dev-server) 并附带开箱即用的模块热重载 1.1 vue-cli-service serve命令1234567891011121314151617181920用法：vue-cli-service serve [options] [entry]options： --open 在服务器启动时打开浏览器 --copy 在服务器启动时将 URL 复制到剪切版 --mode 指定环境模式 (默认值：development) --host 指定 host (默认值：0.0.0.0) --port 指定 port (默认值：8080) --https 使用 https (默认值：false) entry: 唯一入口 ↓ 设置src/main.js文件为唯一入口 package.json &quot;scripts&quot;:&#123; &quot;dev&quot;: &quot;vue-cli-service serve --open --copy ./src/main.js&quot;, &#125; 除了通过命令行参数，还可使用 vue.config.js中的devServer字段配置开发服务器 1.2 vue-cli-service build命令1234567891011121314151617用法：vue-cli-service build [options] [entry|pattern]options： --mode 指定环境模式 (默认值：production) --dest 指定输出目录 (默认值：dist) --modern 面向现代浏览器带自动回退地构建应用 --target app | lib | wc | wc-async (默认值：app) --name 库或 Web Components 模式下的名字 (默认值：package.json 中的 &quot;name&quot; 字段或入口文件名) --no-clean 在构建项目之前不清除目标目录 --report 生成 report.html 以帮助分析包内容 --report-json 生成 report.json 以帮助分析包内容 --watch 监听文件变化 --report 和 --report-json 会根据构建统计生成报告，它会帮助你分析包中包含的模块们的大小。 --target 允许你将项目中的任何组件以一个库或 Web Components 组件的方式进行构建 --modern 使用现代模式构建应用，为现代浏览器交付原生支持的 ES2015 代码，并生成一个兼容老浏览器的包用来自动回退。 栗子 🌰 package.json ↓123 &quot;scripts&quot;:&#123;&quot;build&quot;: &quot;vue-cli-service build --dest output --report --report-json&quot;, &#125; 如图： 1.3 vue-cli-service inspect命令1234567用法：vue-cli-service inspect [options] [...paths]选项： --mode 指定环境模式 (默认值：development) 可使用 vue-cli-service inspect 来审查一个 Vue CLI 项目的 webpack config 二、配置参考2.1 全局配置 👏👏👏命令行中输入vue config可审查、修改全局的cli配置(我的.vuerc文件内容) ↓123456789101112131415161718192021 &#123; &quot;presets&quot;: &#123; &quot;base&quot;: &#123; &quot;useConfigFiles&quot;: false, &quot;plugins&quot;: &#123; &quot;@vue/cli-plugin-babel&quot;: &#123;&#125;, &quot;@vue/cli-plugin-eslint&quot;: &#123; &quot;config&quot;: &quot;standard&quot;, &quot;lintOn&quot;: [ &quot;save&quot; ] &#125; &#125;, &quot;router&quot;: true, &quot;routerHistoryMode&quot;: true, &quot;vuex&quot;: true, &quot;cssPreprocessor&quot;: &quot;less&quot; &#125; &#125;, &quot;useTaobaoRegistry&quot;: true&#125; 2.2 vue.config.js该文件是一个可选的配置文件，如果项目的根目录中存在这个文件，那么它会被@vue/cli-service自动加载 这个文件应该导出一个包含了选项的对象：123module.exports = &#123; //选项...&#125; publicPath [Type:string][Default:’/‘]publicPath是部署应用包时的基本URL，默认情况下，Vue cli会假设你的应用是被部署在一个域名的根路径上。例如https://www.my-app.com/如果应用被部署在一个子路径上，就需要用publicPath指定子路径。如果应用被部署在https://www.my-app.com/my-app/，则设置publicPath为/my-app/这个值在开发环境下同样生效。如果你想把开发服务器架设在根路径，你可以使用一个条件式的值：12345module.exports = &#123; publicPath: process.env.NODE_ENV === &apos;production&apos; ? &apos;/production-sub-path/&apos; : &apos;/&apos;&#125; 默认情况下，打包生成的dist目录下的html文件引用的js、css文件都为 “/“ =&gt; 根路径上如图： 更改publicPath路径后 vue.config.js ↓ 12345module.exports = &#123; publicPath: process.env.NODE_ENV === &apos;production&apos; ? &apos;/production-sub-path/&apos; : &apos;/&apos;&#125; 如图： outputDir [Type:string][Default:’dist’]运行 vue-cli-service build 时生成的生产环境构建文件的目录另:目标目录在构建之前会被清除 (构建时传入 –no-clean 可关闭该行为)。123module.exports = &#123; outputDir: &apos;dist_test --no-clean&apos;&#125; assetsDir [Type:string][Default:’’]放置生成的静态资源 (js、css、img、fonts) 的 (相对于 outputDir 的) 目录。 indexPath [Type:string][Default:’index.html’]指定生成的 index.html 的输出路径 (相对于 outputDir)。也可以是一个绝对路径。如图： filenameHashing [Type:Boolean][Default:true]默认情况下，生成的静态资源在它们的文件名中包含了 hash 以便更好的控制缓存如图： -&gt; pages [Type:object][Default:undefined]在multi-page模式下构建应用时，每个page都应该有一个对应的js入口文件。123456789101112131415161718192021222324用法：module.exports = &#123; pages: &#123; page1: &#123; // page 的入口 entry: &apos;src/page1/main.js&apos;, // 模板来源 template: &apos;src/page1/page1.html&apos;, // 在 dist/index.html 的输出 filename: &apos;page1.html&apos;, // 当使用 title 选项时， // template 中的 title 标签需要是 &lt;title&gt;&lt;%= htmlWebpackPlugin.options.title %&gt;&lt;/title&gt; title: &apos;页面title&apos;, // 在这个页面中包含的块，默认情况下会包含 // 提取出来的通用 chunk 和 vendor chunk。 chunks: [&apos;chunk-vendors&apos;, &apos;chunk-common&apos;, &apos;index&apos;] &#125;, // 当使用只有入口的字符串格式时， // 模板会被推导为 `public/page2.html` // 并且如果找不到的话，就回退到 `public/index.html`。 // 输出文件名会被推导为 `page2.html`。 page2: &apos;src/subpage/main.js&apos; &#125;&#125; package.json ↓123456789101112131415var pages = &#123; page1:&#123; entry:&apos;src/page/page1/main.js&apos;, template:&apos;src/page/page1/page1.html&apos;, filename:&apos;page1.html&apos;, title:&apos;page1&apos;, &#125;, page2:&apos;src/page/page2/main.js&apos;&#125;module.exports = &#123; outputDir: &apos;dist_test&apos;, filenameHashing: false, //静态文件不自动生成hash pages:pages&#125; 执行 npm run build 打包生成dist_test目录如下 ├── favicon.ico├── index.html├── js│ ├── chunk-vendors.js│ ├── chunk-vendors.js.map│ ├── page1.js│ ├── page1.js.map│ ├── page2.js│ └── page2.js.map├── page1.html├── page2.html├── report.html└── report.json lintOnSave [Type:boolean || ‘error’][Default:true]设置为 true 时，eslint-loader 会将 lint 错误输出为编译警告。默认情况下，警告仅仅会被输出到命令行，且不会使得编译失败。如果你希望让 lint 错误在开发时直接显示在浏览器中，你可以使用 lintOnSave: ‘error’。这会强制 eslint-loader 将 lint 错误输出为编译错误，同时也意味着 lint 错误将会导致编译失败。当 lintOnSave 是一个 truthy 的值时，eslint-loader 在开发和生产构建下都会被启用。如果你想要在生产构建时禁用 eslint-loader，你可以用如下配置：1234// vue.config.jsmodule.exports = &#123; lintOnSave: process.env.NODE_ENV !== &apos;production&apos;&#125; transpileDependencies [Type:string || RegExp][Default:[]]默认情况下 babel-loader 会忽略所有 node_modules 中的文件。如果你想要通过 Babel 显式转译一个依赖，可以在这个选项中列出来。 productionSourceMap [Type:boolean][Default:true]如果你不需要生产环境的 source map，可以将其设置为 false 以加速生产环境构建。1234// vue.config.jsmodule.exports = &#123; productionSourceMap:false&#125; -&gt; crossorigin [Type:string][Default:undefined]TODO… integrity [Type:boolean][Default:true]在生成的 HTML 中的 &lt;link rel=&quot;stylesheet&quot;&gt; 和 &lt;script&gt; 标签上启用 Subresource Integrity (SRI)。如果你构建后的文件是部署在 CDN 上的，启用该选项可以提供额外的安全性。需要注意的是该选项仅影响由 html-webpack-plugin 在构建时注入的标签 - 直接写在模版 (public/index.html) 中的标签不受影响。另外，当启用 SRI 时，preload resource hints 会被禁用，因为 Chrome 的一个 bug 会导致文件被下载两次。 configureWebpack [Type:object || Function]如果这个值是一个对象，则会通过 webpack-merge 合并到最终的配置中。如果这个值是一个函数，则会接收被解析的配置作为参数。该函数及可以修改配置并不返回任何东西，也可以返回一个被克隆或合并过的配置版本。更多细节可查阅：配合 webpack &gt; 简单的配置方式webpack官网配置demo如下： vue.config.js123456789101112131415161718192021222324const UglifyJsPlugin = require(&apos;uglifyjs-webpack-plugin&apos;); //清除注释//Objectmodule.exports = &#123; configWebpack:&#123; plugins:[ new UglifyJsPlugin(), ] &#125;&#125;//Functionmodule.exports = &#123; configWebpack: config =&gt;&#123; var plugins = [ new UglifyJsPlugin() ]； config.plugins = [ ...config.plugins, ...plugins ]; &#125;&#125; chainWebpack [Type:Function]是一个函数，会接收一个基于 webpack-chain 的 ChainableConfig 实例。允许对内部的 webpack 配置进行更细粒度的修改你需要熟悉 webpack-chain 的 API 并阅读一些源码以便了解如何最大程度利用好这个选项，但是比起直接修改 webpack 配置，它的表达能力更强，也更为安全。demo如下 vue.config.js123456789101112module.exports = &#123; chainWebpack: config =&gt; &#123; config.module .rule(&apos;vue&apos;) .use(&apos;vue-loader&apos;) .loader(&apos;vue-loader&apos;) .tap(options =&gt; &#123; // 修改它的选项... return options &#125;) &#125;&#125; css.modules [Type:boolean][Default:false]TODO.. css.extract [Type:boolean][Default: 生产环境下是 true，开发环境下是 false]TODO… devServer [Type:object]所有webpack-dev-server的选项都支持 devServer.proxyTODO….. parallel[Type:boolean][Default: require(‘os’).cpus().length &gt; 1]是否为 Babel 或 TypeScript 使用 thread-loader。该选项在系统的 CPU 有多于一个内核时自动启用，仅作用于生产构建。 pluginOptions [Type:object]这是一个不进行任何 schema 验证的对象，因此它可以用来传递任何第三方插件选项。例如：1234567module.exports = &#123; pluginOptions: &#123; foo: &#123; // 插件可以作为 `options.pluginOptions.foo` 访问这些选项。 &#125; &#125;&#125; BabelBabel 可以通过 babel.config.js 进行配置。TIP Vue CLI 使用了 Babel 7 中的新配置格式 babel.config.js。和 .babelrc 或 package.json 中的 babel 字段不同，这个配置文件不会使用基于文件位置的方案，而是会一致地运用到项目根目录以下的所有文件，包括 node_modules 内部的依赖。我们推荐在 Vue CLI 项目中始终使用 babel.config.js 取代其它格式。 TypeScriptTypeScript 可以通过 tsconfig.json 来配置。 更多细节可查阅 @vue/cli-plugin-typescript 单元测试Jest更多细节可查阅 @vue/cli-plugin-unit-jest Mocha (配合 mocha-webpack)更多细节可查阅 @vue/cli-plugin-unit-mocha 三、模式模式是 Vue CLI 项目中一个重要的概念。默认情况下，一个 Vue CLI 项目有三个模式： development 模式用于 vue-cli-service serve production 模式用于 vue-cli-service build 和 vue-cli-service test:e2e test 模式用于 vue-cli-service test:unit 注意模式不同于 NODE_ENV，一个模式可以包含多个环境变量。也就是说，每个模式都会将 NODE_ENV 的值设置为模式的名称——比如在 development 模式下 NODE_ENV 的值会被设置为 “development”。你可以通过为 .env 文件增加后缀来设置某个模式下特有的环境变量。比如，如果你在项目根目录创建一个名为 .env.development 的文件，那么在这个文件里声明过的变量就只会在 development 模式下被载入。 示例：Staging 模式假设我们有一个应用包含以下 .env 文件： VUE_APP_TITLE=My App和 .env.staging 文件：12NODE_ENV=productionVUE_APP_TITLE=My App (staging) vue-cli-service build 会加载可能存在的 .env、.env.production 和 .env.production.local 文件然后构建出生产环境应用； vue-cli-service build --mode staging 会在 staging 模式下加载可能存在的 .env、.env.staging 和 .env.staging.local 文件然后构建出生产环境应用。 这两种情况下，根据 NODE_ENV，构建出的应用都是生产环境应用，但是在 staging 版本中，process.env.VUE_APP_TITLE 被覆写成了另一个值。 在客户端侧代码中使用环境变量只有以 VUE_APP_ 开头的变量会被 webpack.DefinePlugin 静态嵌入到客户端侧的包中。你可以在应用的代码中这样访问它们：1console.log(process.env.VUE_APP_SECRET) 在构建过程中，process.env.VUE_APP_SECRET 将会被相应的值所取代。在 VUE_APP_SECRET=secret 的情况下，它会被替换为 “sercet”。 除了 VUE_APP_* 变量之外，在你的应用代码中始终可用的还有两个特殊的变量： NODE_ENV - 会是 “development”、”production” 或 “test” 中的一个。具体的值取决于应用运行的模式。BASE_URL - 会和 vue.config.js 中的 publicPath 选项相符，即你的应用会部署到的基础路径。所有解析出来的环境变量都可以在 public/index.html 中以 HTML 插值中介绍的方式使用。 GitLab Pages根据gitlab pages文档的描述,所有的配置都在根目录中的.gitlab-ci.yml 文件中。下面的范例是一个很好的入门:123456789101112131415# .gitlab-ci.yml 文件应放在你仓库的根目录下 pages: # 必须定义一个名为 pages 的 job image: node:latest stage: deploy script: - npm ci - npm run build - mv public public-vue # GitLab Pages 的钩子设置在 public 文件夹 - mv dist public # 重命名 dist 文件夹 (npm run build 之后的输出位置) artifacts: paths: - public # artifact path 一定要在 /public , 这样 GitLab Pages 才能获取 only: - master 在推送到仓库之前提交 .gitlab-ci.yml 和 vue.config.js 文件。GitLab CI 的管道将会被触发: 当成功时候, 到 Settings &gt; Pages 查看关于网站的链接。]]></content>
      <categories>
        <category>vue</category>
      </categories>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js常用方法]]></title>
    <url>%2F2019%2F05%2F06%2Fjs_methods%2F</url>
    <content type="text"><![CDATA[1.监听滚动到底部+节流阀 2.canvas绘图 3.HTML代码中&lt;%%&gt;、&lt;%=%&gt;、&lt;%:%&gt;各是什么意思?分别用来实现什么的? 4.img标签中src请求的原理（过程），Filter是否可以拦截不可拦截，但无论是binary还是img对象都可监听onload onerror事件 5.js reduce 6.canvas图片跨域问题 - 简书www.jianshu.com 7.使用Charles进行HTTPS抓包 - 简书www.jianshu.com 8.Tencent/vConsole: A lightweight, extendable front-end developer tool for mobile web page.github.com 9.https://github.com/libin1991/Mobile-webpackPlugin-for-consoleDebug/blob/29367af7d72ade08ae68053ac41bafd4c6373256/files/debug.js 10.MAC终端神器iterm2——告别黑白 - xiaobe - 博客园www.cnblogs.com 11.CSS3 @media查询 | 菜鸟教程www.runoob.com 12.媒体查询使用方法@media - Leaves_Yu的博客 - CSDN博客blog.csdn.net 13.html5的audio实现高仿微信语音播放效果 - 创业男生 - 博客园www.cnblogs.com 14.git 放弃解决冲突_百度搜索www.baidu.com 15.meta no-cache_百度搜索www.baidu.com 16.URL.createObjectURL和URL.revokeObjectURL - 诗&amp;远方 - 博客园www.cnblogs.com 17.input file限制文件类型 - Google 搜索www.google.com.hk 18.input type = file上传图片限制大小、类型判断、像素判断 - 阿俊的博客 - CSDN博客blog.csdn.net 19.GaryStimson/paste.js: read image/text data from clipboard (cross-browser)github.com 20.charles external proxy server https://juejin.im/post/5c9f3d4cf265da30af3c0a94 21.https://juejin.im/post/5cab64ce5188251b19486041 22.https://blog.csdn.net/weixin_42112635/article/details/88070622 23.https://www.jianshu.com/p/903ec28c5640 24.js 在module中解析字符串为变量 brew yarn.lock? 为什么多数项目中都有这个文件 DOMContentLoaded与load的区别 font文件跨域，转成base64过大 在linux下安装Node CentOS7安装node.js switchHosts软件基于electron开发而成 [👍]]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[markdown编辑器语法——文字颜色、大小、字体与背景色的设置]]></title>
    <url>%2F2019%2F04%2F29%2Fmd_config%2F</url>
    <content type="text"><![CDATA[一、颜色 在markdown中采用如下方式能够控制文字的颜色：123浅红色文字：&lt;font color=&quot;#dd0000&quot;&gt;浅红色文字：&lt;/font&gt;&lt;br /&gt; 浅青色文字：&lt;font color=&quot;#00dddd&quot;&gt;浅青色文字&lt;/font&gt;&lt;br /&gt; 浅紫色文字：&lt;font color=&quot;#dd00dd&quot;&gt;浅紫色文字&lt;/font&gt;&lt;br /&gt; 效果如下：浅青色文字：浅青色文字 二、大小12size为1：&lt;font size=&quot;1&quot;&gt;size为1&lt;/font&gt;&lt;br /&gt; size为2：&lt;font size=&quot;2&quot;&gt;size为2&lt;/font&gt;&lt;br /&gt; 效果如下：size为1：size为1 三、字体12&lt;span style=&quot;font-family:&quot;SimHei&quot;, serif;&quot;&gt;我是黑体字&lt;/span&gt;&lt;span style=&quot;font-family:SimSun, serif;&quot;&gt;我是宋体字&lt;/span&gt; 效果如下：我是宋体字 四、背景色1&lt;table&gt;&lt;tr&gt;&lt;td bgcolor=#FFCDC7&gt;背景色的设置是按照十六进制颜色值：#FFCDC7&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt; 效果如下： 背景色的设置是按照十六进制颜色值：#FFCDC7 五：1&lt;span xss=removed&gt;所添加的需要加下划线的行内文字&lt;/span&gt; 效果如下所添加的需要加下划线的行内文字]]></content>
      <categories>
        <category>markdown</category>
      </categories>
      <tags>
        <tag>markdown</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[css填坑指南]]></title>
    <url>%2F2019%2F04%2F29%2Fcss_g%2F</url>
    <content type="text"><![CDATA[前言css的坑跨过了一个又一个，以前总是过了就算了，不久就又忘了 😂so 开一篇文章专门记录遇到的各种css坑~~~ 正文 背景图片旋转TODO … ❣️]]></content>
      <categories>
        <category>css</category>
      </categories>
      <tags>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo神坑]]></title>
    <url>%2F2019%2F04%2F29%2Fhexo_bug%2F</url>
    <content type="text"><![CDATA[想做个内容折叠的功能，网上找到了代码，咔咔咔复制粘贴。发现并没有折叠…….. (〒︿〒)就开始查代码找问题，原来是首页的index.html文件没有引入post-details.js文件，而文章详情页会自动引入post-details.js,所以只有详情页折叠才是生效的 (〒︿〒)^2我是通过 hexo deploy命令 生成public文件夹的，那么这个命令都做了写什么??]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[sublime IDE 常见快捷键]]></title>
    <url>%2F2019%2F04%2F29%2Fsublime_quick_find%2F</url>
    <content type="text"><![CDATA[符号说明⌘：command⌃：control⌥：option⇧：shift↩：enter⌫：delete （打开/关闭/前往）快捷键 功能⌘⇧N 打开一个新的sublime窗口⌘N 新建文件⌘⇧W 关闭sublime，关闭所有文件⌘W 关闭当前文件⌘P 跳转、前往文件、前往项目、命令提示、前往method等等（Goto anything）⌘⇧T 重新打开最近关闭的文件⌘T 前往文件⌘⌃P 前往项目⌘R 前往method⌘⇧P 命令提示⌃G 前往行⌘KB 开关侧栏⌃` 打开控制台⌃- 光标跳回上一个位置⌃⇧- 光标恢复位置 （编辑）快捷键 功能⌘A 全选⌘L 选择行（重复按下将下一行加入选择）⌘D 选择词（重复按下时多重选择相同的词进行多重编辑）⌃⇧M 选择括号的内容⌘⇧↩ 在当前行前插入新行⌘↩ 在当前行后插入新行⌃⇧K 删除行⌘KK 从光标处删除至行尾⌘K⌫ 从光标处删除至行首⌘⇧D 复制（多）行⌘J 合并（多）行⌘KU 改为大写⌘KL 改为小写⌘C 复制⌘X 剪切⌘V 粘贴⌘/ 注释⌘⌥/ 块注释⌘Z 撤销⌘Y 恢复撤销⌘⇧V 粘贴并自动缩进⌘⌥V 从历史中选择粘贴⌃M 跳转至对应的括号⌘U 软撤销（可撤销光标移动）⌘⇧U 软重做（可重做光标移动）⌘⇧S 保存所有文件⌘] 向右缩进⌘[ 向左缩进⌘⌥T 特殊符号集⌘⇧L 将选区转换成多个单行选区 （查找/替换）快捷键 功能⌘f 查找⌘⌥f 查找并替换⌘⌥g 查找下一个符合当前所选的内容⌘⌃g 查找所有符合当前选择的内容进行多重编辑⌘⇧F 在所有打开的文件中进行查找 （拆分窗口/标签页）快捷键 功能⌘⌥[1,2,3,4] 单列、双列、三列、四列⌘⌥5 网格（4组）⌃[1,2,3,4] 焦点移动到相应的组（分屏编号）⌃⇧[1,2,3,4] 将当前文件移动到相应的组（分屏编号）⌘[1,2,3,4] 选择相应的标签页 （快捷操作）快捷键 功能⌘⌃上下键 两行交换位置⌘KB 显示/隐藏侧边 开启vim 模式：在菜单栏中： Preferences -&gt; Setting - User ，即可打开配置文件进行编辑，将 ignored_packages 项的[]里面内容清空或注释掉：]]></content>
      <categories>
        <category>编译器</category>
        <category>sublime</category>
      </categories>
      <tags>
        <tag>sublime</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue插件汇总 [learn]]]></title>
    <url>%2F2019%2F04%2F29%2Fvue_plugin_generation%2F</url>
    <content type="text"><![CDATA[一、UI组件及框架element - 饿了么出品的Vue2的web UI工具套件mint-ui - Vue 2的移动UI元素iview - 基于 Vuejs 的开源 UI 组件库Keen-UI - 轻量级的基本UI组件合集vue-material - 通过Vue Material和Vue 2建立精美的app应用muse-ui - 三端样式一致的响应式 UI 库vuetify - 为移动而生的Vue JS 2组件框架vonic - 快速构建移动端单页应用vue-blu - 帮助你轻松创建web应用vue-multiselect - Vue.js选择框解决方案VueCircleMenu - 漂亮的vue圆环菜单vue-chat - vuejs和vuex及webpack的聊天示例radon-ui - 快速开发产品的Vue组件库vue-waterfall - Vue.js的瀑布布局组件vue-carbon - 基于 vue 开发MD风格的移动端vue-beauty - 由vue和ant design创建的优美UI组件bootstrap-vue - 应用于Vuejs2的Twitter的Bootstrap 4组件vueAdmin - 基于vuejs2和element的简单的管理员模板vue-ztree - 用 vue 写的树层级组件vue-tree - vue树视图组件vue-tabs - 多tab页轻型框架 二、滚动scroll组件vue-scroller - Vonic UI的功能性组件vue-mugen-scroll - 无限滚动组件vue-infinite-loading - VueJS的无限滚动插件vue-virtual-scroller - 带任意数目数据的顺畅的滚动vue-infinite-scroll - VueJS的无限滚动指令vue-scrollbar - 最简单的滚动区域组件vue-scroll - vue滚动vue-pull-to-refresh - Vue2的上拉下拉mint-loadmore - VueJS的双向下拉刷新组件vue-smoothscroll - smoothscroll的VueJS版本 三、slider组件vue-awesome-swiper - vue.js触摸滑动组件vue-slick - 实现流畅轮播框的vue组件vue-swipe - VueJS触摸滑块vue-swiper - 易于使用的滑块组件vue-images - 显示一组图片的lightbox组件vue-carousel-3d - VueJS的3D轮播组件vue-slide - vue轻量级滑动组件vue-slider - vue 滑动组件vue-m-carousel - vue 移动端轮播组件dd-vue-component - 订单来了的公共组件库vue-easy-slider - Vue 2.x的滑块组件 四、编辑器markcook - 好看的markdown编辑器eme - 优雅的Markdown编辑器vue-syntax-highlight - Sublime Text语法高亮vue-quill-editor - 基于Quill适用于Vue2的富文本编辑器Vueditor - 所见即所得的编辑器vue-html5-editor - html5所见即所得编辑器vue2-editor - HTML编辑器vue-simplemde - VueJS的Markdown编辑器组件vue-quill - vue组件构建quill编辑器 五、图表vue-table - 简化数据表格vue-chartjs - vue中的Chartjs的封装vue-charts - 轻松渲染一个图表vue-chart - 强大的高速的vue图表解析vue-highcharts - HighCharts组件chartjs - Vue Bulma的chartjs组件vue-chartkick - VueJS一行代码实现优美图表 六、日历vue-calendar - 日期选择插件vue-datepicker - 日历和日期选择组件vue-datetime-picker - 日期时间选择控件vue2-calendar - 支持lunar和日期事件的日期选择器vue-fullcalendar - 基于vue.js的全日历组件vue-datepicker - 漂亮的Vue日期选择器组件datepicker - 基于flatpickr的时间选择组件vue2-timepicker - 下拉时间选择器vue-date-picker - VueJS日期选择器组件vue-datepicker-simple - 基于vue的日期选择器 七、地址选择vue-city - 城市选择器vue-region-picker - 选择中国的省份市和地区 八、地图vue-amap - 基于Vue 2和高德地图的地图组件vue-google-maps - 带有双向数据绑定Google地图组件vue-baidu-map- 基于 Vue 2的百度地图组件库vue-cmap - Vue China map可视化组件 九、播放器vue-video-player - VueJS视频及直播播放器vue-video - Vue.js的HTML5视频播放器vue-music-master - vue手机端网页音乐播放器 十、文件上传vue-upload-component - Vuejs文件上传组件vue-core-image-upload - 轻量级的vue上传插件vue-dropzone - 用于文件上传的Vue组件 十一、图片处理vue-lazyload-img - 移动优化的vue图片懒加载插件vue-image-crop-upload - vue图片剪裁上传组件vue-svgicon - 创建svg图标组件的工具vue-img-loader - 图片加载UI组件vue-image-clip- 基于vue的图像剪辑组件vue-progressive-image - Vue的渐进图像加载插件 十二、提示vue-toast-mobile - VueJS的toast插件vue-msgbox - vuejs的消息框vue-tooltip - 带绑定信息提示的提示工具vue-verify-pop - 带气泡提示的vue校验插件 十三、进度条vue-radial-progress - Vue.js放射性进度条组件vue-progressbar - vue轻量级进度条vue2-loading-bar - 最简单的仿Youtube加载条视图 十四、开发框架汇总vue-admin - Vue管理面板框架electron-vue - Electron及VueJS快速启动样板vue-2.0-boilerplate - Vue2单页应用样板vue-webgulp - 仿VueJS Vue loader示例vue-bulma - 轻量级高性能MVVM Admin UI框架vue-spa-template - 前后端分离后的单页应用开发Framework7-Vue - VueJS与Framework7结合vue-element-starter - vue启动页 十五、实用库汇总vuelidate - 简单轻量级的基于模块的Vue.js验证qingcheng - qingcheng主题vuex - 专为 Vue.js 应用程序开发的状态管理模式vue-axios - 将axios整合到VueJS的封装vue-desktop - 创建管理面板网站的UI库vue-meta - 管理app的meta信息avoriaz - VueJS测试实用工具库vue-framework7 - 结合VueJS使用的Framework7组件vue-lazy-render - 用于Vue组件的延迟渲染vue-svg-icon - vue2的可变彩色svg图标方案vue-online - reactive的在线和离线组件vue-password-strength-meter - 交互式密码强度计vuep - 用实时编辑和预览来渲染Vue组件vue-bootstrap-modal - vue的Bootstrap样式组件element-admin - 支持 vuecli 的 Element UI 的后台模板vue-shortkey - 应用于Vue.js的Vue-ShortKey 插件cleave - 基于cleave.js的Cleave组件vue-events - 简化事件的VueJS插件http-vue-loader - 从html及js环境加载vue文件vue-electron - 将选择的API封装到Vue对象中的插件vue-router-transition - 页面过渡插件vuemit - 处理VueJS事件vue-cordova - Cordova的VueJS插件vue-qart - 用于qartjs的Vue2指令vue-websocket - VueJS的Websocket插件vue-gesture - VueJS的手势事件插件vue-local-storage - 具有类型支持的Vuejs本地储存插件lazy-vue - 懒加载图片vue-lazyloadImg - 图片懒加载插件vue-bus - VueJS的事件总线vue-observe-visibility - 当元素在页面上可见或隐藏时检测vue-notifications - 非阻塞通知库v-media-query - vue中添加用于配合媒体查询的方法vuex-shared-mutations - 分享某种Vuex mutationsvue-lazy-component - 懒加载组件或者元素的Vue指令vue-reactive-storage - vue插件的Reactive层vue-ts-loader - 在Vue装载机检查脚本vue-pagination-2 - 简单通用的分页组件vuex-i18n - 定位插件Vue.resize - 检测HTML调整大小事件的vue指令vue-zoombox - 一个高级zoomboxleo-vue-validator - 异步的表单验证组件modal - Vue Bulma的modal组件Famous-Vue - Famous库的vue组件vue-input-autosize - 基于内容自动调整文本输入的大小vue-file-base64 - 将文件转换为Base64的vue组件Vue-Easy-Validator - 简单的表单验证vue-truncate-filter - 截断字符串的VueJS过滤器 十六、服务端vue-ssr - 结合Express使用Vue2服务端渲染nuxt.js - 用于服务器渲染Vue app的最小化框架vue-ssr - 非常简单的VueJS服务器端渲染模板vue-easy-renderer - Nodejs服务端渲染express-vue - 简单的使用服务器端渲染vue.js 十七、辅助工具DejaVue - Vuejs可视化及压力测试vue-generate-component - 轻松生成Vue js组件的CLI工具vscode-VueHelper - 目前vscode最好的vue代码提示插件vue-play - 展示Vue组件的最小化框架VuejsStarterKit - vuejs starter套件vue-multipage-cli - 简单的多页CLI 十八、应用实例pagekit - 轻量级的CMS建站系统vuedo - 博客平台koel - 基于网络的个人音频流媒体服务CMS-of-Blog - 博客内容管理器vue-cnode - 重写vue版cnode社区vue-ghpages-blog - 依赖GitHub Pages无需本地生成的静态博客swoole-vue-webim - Web版的聊天应用fewords - 功能极其简单的笔记本jackblog-vue - 个人博客系统vue-blog - 使用Vue2.0 和Vuex的vue-blogvue-dashing-js - nuvo-dashing-js的forkrss-reader - 简单的rss阅读器 声明：作者：尹先生code链接：https://www.jianshu.com/p/3147c5b76f15]]></content>
      <categories>
        <category>前端</category>
        <category>vue</category>
      </categories>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[如何在一台机器上同时使用github与gitlab服务?]]></title>
    <url>%2F2019%2F04%2F29%2Fgithub_gitlab_ssh%2F</url>
    <content type="text"><![CDATA[前言：github是网络公有代码仓库，一般用于私人代码托管，而githuab一般是企业搭建的内部代码仓库。工作期间，我们都会同时用到这两个仓库，但企业邮箱和个人邮箱是不同的，因此产生的ssh key会不同，就造成了冲突。如何在一台机器上同时使用github与gitlab服务呢? 步骤：1.生成秘钥 公司的GitLab生成一个SSH-Key 在~/.ssh/目录会生成gitlab_id-rsa和gitlab_id-rsa.pub私钥和公钥。我们将gitlab_id-rsa.pub中的内容粘帖到公司GitLab服务器的SSH-key的配置中。$ ssh-keygen -t rsa -C “注册的gitlab邮箱” -f ~/.ssh/gitlab_id-rsa 公网github生成一个SSH-Key 在~/.ssh/目录会生成github_id-rsa和github_id-rsa.pub私钥和公钥。我们将github_id-rsa.pub中的内容粘帖到github服务器的SSH-key的配置中。$ ssh-keygen -t rsa -C “注册的github邮箱” -f ~/.ssh/github_id-rsa 2.添加config在~/.ssh下添加config配置文件,内容如下：12345678910111213141516# github keyHost github Port 22 User git HostName github.com PreferredAuthentications publickey IdentityFile ~/.ssh/github_id-rsa#如果你是macOS Sierra 0.12.2及以后版本，都需要添加以下两个字段 AddKeysToAgent yes UseKeychain yesHost gitlab Port 22 User git HostName gitlab.com PreferredAuthentications publickey IdentityFile ~/.ssh/gitlab_id-rsa 下面对上述配置文件中使用到的配置字段信息进行简单解释： Host它涵盖了下面一个段的配置，我们可以通过他来替代将要连接的服务器地址。这里可以使用任意字段或通配符。当ssh的时候如果服务器地址能匹配上这里Host指定的值，则Host下面指定的HostName将被作为最终的服务器地址使用，并且将使用该Host字段下面配置的所有自定义配置来覆盖默认的/etc/ssh/ssh_config配置信息。 Port自定义的端口。默认为22，可不配置 User自定义的用户名，默认为git，可不配置 HostName真正连接的服务器地址 PreferredAuthentications指定优先使用哪种方式验证，支持密码和秘钥验证方式 IdentityFile指定本次连接使用的密钥文件 3 添加ssh私钥到ssh-agentterminal执行命令 ssh-add -K ~/.ssh/gitlab_id-rsa 4.配置仓库假设gitlab与github的工作目录分别如下所示： github工作仓库:~/workspace/githubgitlab工作仓库:~/workspace/gitlab 则配置如下：1234567891011#gitlabcd ~/workspace/gitlabgit initgit config --global user.name &apos;gitlab&apos;git config --global user.email &apos;gitlab@company.com&apos;#githubcd ~/workspace/githubgit initgit config --local user.name &apos;personal&apos;git config --local user.email &apos;personal@163.com&apos; 4.测试12345# 测试github$ ssh -T git@github.com # 测试gitlab$ ssh -T git@gitlab.com .git文件到底有什么用嘞?TODO…. ##不小心把.git文件删除了，如何获取？git init命令自动生成.git文件 修改git远程仓库不知道做了什么操作，今天提代码时发现推不上去 git remote -v命令返回空噔噔噔噔~ 使用 git remote add origin [url] 就好啦 也可以直接修改config文件~ 参考资料：github和gitlab仓库一起使用]]></content>
      <categories>
        <category>git</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[linux学习笔记]]></title>
    <url>%2F2019%2F04%2F13%2Flearn-linux%2F</url>
    <content type="text"><![CDATA[一文字模式下指令的下达默认root的提示符为# 一般身份使用者的提示符为$ Linux的默认shell程序就是bash加入选项设置时，通常选项前会带 - 号，例如-h有时会使用选项的完整全名，则选项前带 – 号，例如–help4.2.2 无论几个空格都会被识别为一个空格4.2.3 enter表示启动当前行指令4.2.4 指令太长，可以使用反斜线()+回车符(enter)换行4.2.5 重要的几个热键 tab 命令补全 ctrl+c 中断程序执行 ctrl+d 直接离开命令行 fn+↑ 上一屏 fn+↓ 下一屏 tab tab 显示所有可用指令 space 显示more时可向下翻页 /关键字 向下主动搜索关键字 （效果如下） ?关键字 向上主动搜索关键字 n, N 利用/或者?来搜索字符串时，可以用n来继续下一个搜索，用N进行反向搜索 4.2.6 –help 可以帮助你如何去使用指令4.2.7 man command 显示完整的操作说明(星星眼) man是manual的简写啦例：输入man date后shell会打印以下信息~截图第一行中可以看到DATE(1) DATE表示指令名称，（1）代表”一般使用者可使用的命令” 那么是不是代表还有其他代号嘞~~ 当然啦 上截图！上述的表格内容可以使用”man man”来更详细的取得说明TIPS:上表中的1,5,8这三个代码hin重要，也请务必将这三个数字的含义记下来！ 简而言之，如何去找到所需要的指令呢？（ 以打印为例lp[line print] ） man lp ，找到相关说明 lp[tab][tab] 找到以lp开头的指令 找到相关指令后， –help 查基本语法 若有需要再以man去查询指令的用法 TIPS：如果你知道某个指令，但却忘记了相关参数与选项，请先善用–help 来查询相关信息；当有任何你不知道的指令或文件格式等，但你想要了解它，请使用man/info查询 二 超简单文本编译器 nano vim 等 (本小节仅讲nano)三 Linux的文件权限与目录配置在linux中任何一个文件都具有user group other三种身份的权限 linux文件权限概念当你在你的屏幕前面出现了”Permission deny”的时候，不用担心，肯定是权限设置错误啦 linux文件属性使用sudo切换为root身份在terminal输入ls -al可查看文件详细信息 d r w x r - x r - x ① ② ③ ④ ⑤ ⑥ ⑦ ⑧ ⑨ ⑩ ① 当为[d]则是目录 当为[-]则是文件 [l]表示为链接未见 [b]可随机存取设备 ②③④ user权限三个为一组，均为“rwx”的三个参数的组合。 [r] —— read [w] —— write [x] —— execute [-] —— 无权限 ⑤⑥⑦ group权限 ⑧⑨⑩ other权限 root基本上是不受系统的权限所限制，无论文件权限是什么，默认root都可存取 如何改变文件属性与权限几种常用于group、user、other权限修改的指令：chgrp ——&gt; 改变文件所属群组 (要被改变的群组名称必须要在/etc/group文件内存在才行)chown ——&gt; 改变文件userchmod ——&gt; 改变文件的权限, SUID, SGID, SBIT等特性 复制文件，cp 来源文件 目的文件，由于cp会复制执行者的属性与权限，可通过chmod修改 改变权限,chmod 数字类型改变文件权限Linux文件的基本权限有9个，分别是owner/user/other三中身份各有read/white/execute权限，这九个权限是三个一组的，可以使用数字表示各个权限，各权限的分数对照表如下： &gt;r:4 &gt; w:2 &gt; x:1 每种身份各自的三个权限(r/w/x)分数是需要累加的，例如：权限为 [-rwxrwx—]分数为： owner = rwx = 4 + 2 + 1 = 7 &gt; group = rwx = 4 + 2 + 1 = 7 &gt; other = 0所以等下我们设置权限的变更时，该文件的权限就是770啦如果我们要将某文件(a.txt)的权限都设置为启用，只需要输入一下命令即可：chmod 777 a.txt 符号类型改变文件权限user group other三种身份可用u g o 表示。此外a表示all,读写权限可写成r w x也就是可以使用下面的方式来看：| chmod | u g o a | + (加入) - (除去) = (设置) | r w x | 文件或目录将一个文件权限改成”-rwxr-xr-x”chmod u=rwx,go=rx a.txt如果不知道原先的文件属性，只想要给a.txt文件的三种身份都增加可写入权限：chmod a+w a.txt 目录与文件权限意义 权限对文件的重要性r 可读取文件的实际内容，如读取文本文件的文字内容等w 可以编辑、新增、修改文件的内容(但不含删除该文件!)x 该文件具有可以被系统执行的权限 权限对目录的重要性r 具有读取目录结构清单的权限w 具有以下权限 1.创建新的文件与目录 2.删除已存在的文件与目录(不论改文件的权限是什么) 3.将已存在的文件或目录更名 4.移动该目录内的文件、目录位置x 使用者能否进入该目录 linux文件种类与扩展名 正规文件——第一个属性为[-] 纯文本文件 二进制档 数据格式文件 目录——第一个属性为[d] 链接文件——类似windows系统下的快捷方式，第一个属性为[l] 设备与设备文件 数据接口文件 数据输送档 常用扩展名 *.sh：脚本或批处理文件，因为批处理文件为使用shell写成的， 所以扩展名为.sh Z, .tar, .tar.gz, .zip, *.tgz: 经过打包的压缩文件 .html .php基本上，linux系统上的文件名只是为了让你了解该文件可能的用途，真正的执行与否仍需要权限 文件名称的开头为小数点.时，代表这个文件为”隐藏文件”。 linux目录配置linux目录配置的依据 —— FHSFHS依据文件系统使用的频繁与否与是否允许使用者随意更改，而将目录定义为四种交互作用的形态1.可分享的——可以分享给其他系统挂载使用的目录2.不可分享——自己机器上运行的设备文件或者是3.不变的4.可变动的 /usr依据FHS的基本定义， /usr(unix software resource缩写)里面放置的数据属于可分享的与不可变动的， /var/var目录主要针对常态性变动的文件，包括cache, log file,某些软件运行所产生的文件，程序文件(lock file, run file) 目录树架构图 四 安装SentOS7六 Linux的文件与目录管理目录的相关操作常见的处理目录的指令 cd : 变换目录 [change directory] pwd : 显示当前目录 [print working directory] mkdir : 创建一个新的目录 rmdir : 删除一个空的目录 “~” 表示主文件夹 cd ~ 可以回到个人的主文件夹中 mkdir默认情况下，需要一层一层创建才行加上-p 选项后，可以直接下达mkdir -p /home/bird/testing/test1系统会依序创建目录，如果该目录已存在则跳过 rmdir目录需要一层一层删除，被删除的目录里不能存在其他目录或文件 关于可执行文件路径的变量： $PATH当我们在执行一个指令的时候，举例来说”ls”，系统会按照PATH的设置去每个PATH定义的目录下搜寻文件名为ls的可执行文件，如果PATH定义的目录中含有多个文件名为”ls”的可执行文件，那么先搜寻到的同名指令先被执行echo $PATH命令，会打印出环境变量echo是打印，PATH前面加$表示后面接的是变量，所以会显示出目前的PATHPATH 这个变量的内容是由一堆目录组成，每个目录中间用冒号隔开，每个目录是有顺序之分的。 文件与目录管理复制、删除、移动： cp rm mv cp （复制文件/目录）选项与参数 -p : 连同文件的属性(权限、用户、时间)一起复制过去，而非使用默认属性(备份常用) -i : 若目标文件已经存在，在覆盖时会先询问动作的进行 -a : 将文件的所有特性一起复制 -r : 递回持续复制，用于目录的复制行为 -L : 进行硬式链接的链接文件创建，而非复制文件本身 eg:cp ~/.bashrc /tmp/bashrc 将.bashrc复制到/tmp下，并更名为bashrccp /var/log/wtmp . .表示复制到当前目录cp -a /var/log wtemp wtemp_2 将文件的所有特性一起复制cp -r /etc/ /tmp 复制 /etc/目录下的所有内容到/tmp下 rm (移除文件或目录)选项与参数 -f : force忽略不存在的文件，不会出现警告信息 -i : 互动模式，在删除前会询问使用者是否动作 -r : 递回删除 eg:rm -i bashrc 删除bashrc文件rm -i bashrc*通过万用字符 将bashrc开头的文件名都删除 星号表示0到无穷多个任意字符 mv(移动文件与目录，或更名)选项与参数 -f : force如果目标文件已经存在，不会询问而直接覆盖 -i : 若目标文件已经存在，就询问是否覆盖 -u : 若目标文件已经存在，且source比较新，才会更新(update) 取得路径的文件名称与目录名称eg:basename /etc/sysconfig/network 取得最后的文件名dirname /etc/sysconfig/network 取得最后的目录名 文件内容查阅 cat : 由第一行开始显示文本内容 tac : 从最后一行开始显示 nl : 显示的时候，顺便输出行号 more : 一页一页显示文件内容 less : 和more类似，但可以往前翻页 head : 只看头几行 tail : 只看尾几行 od : 以二进制的方式读取文件内容 修改文件时间或创建新文件：touchdate; ll bashrc; ll --time=atime bashrc; ll --time=ctime bashrc 分号“;”代表连续指令的下达，可以在一行指令当中写入多重指令，这些指令会依序执行。 文件与目录的默认权限与隐藏权限文件默认权限： umaskunask是指定“目前使用者在创建文件或目录时的权限默认值”可通过以下两种指令查看umask umask -Sumask 022 设置umask权限 指令与文件的搜索which (寻找可执行文件)type文件文件名搜索whereis 找系统中某些特定目录下面的文件locate 利用数据库来搜寻文件名 九 vim程序编辑器为什么要学vim呢？1.所有unix like系统都会内置vi文本编辑器2.很多个别软件的编辑接口都会主动调vi 【重点】3.vim具有程序编辑的能力，可以主动的以字体颜色辨别语法的正确性，方便程序设计；4.程序简单，编辑速度相当快 vi的使用基本上共分为三种模式，分别是“一般指令模式”，“编辑模式”，”命令行命令模式”： 一般指令模式 以vi打开一个文件就是直接进入一般指令模式 编辑模式 在一般指令模式下，按下”i” “I” “o” “O” “a” “A” “r” “R”等任何一个字母之后才会进入编辑模式。 要回到一般指令模式，则必须按下“ESC”按键即可退出编辑模式 命令行命令模式 在一般模式中，输入” : / ?”三个钟的任何一个按钮，就可以将光标移动到最下面那一列。在这个模式当中，可以提供你“搜寻数据”的动作，而读取、存盘(white)、大量取代字符、离开(quit)vi、显示行号等等的动作则是在此模式中达成的 按键说明一般指令模式可用的按钮说明，关闭表移动、复制粘贴、搜寻取代等 一般指令模式切换到编辑模式的可用的按钮说明 一般指令模式切换到命令行界面的可用按钮说明 vim的额外功能同事友情提供的vim思维导图 BASHbash shell 的功能 命令编修能力（history）: 能够记忆使用过的命令，这些指令记录在你的主文件夹内的.bash_history中，.bash_history记录的是前一次登录以前所执行的命令，而这一次登录所执行的命令都被暂存在内存中，当你成功登出系统后，该指令记忆才会记录到.bash_history中 命令与文件补全功能 (tab键的好处) 命令别名设置功能 (alias) 在命令行输入 alias 就可以知道目前的命令别名有哪些了 alias ll=&#39;ls -al&#39; 可直接设置别名 程序化脚本 (shell script) 万用字符： * 星号 指令的下达与快速标记按钮当指令太长，可通过反斜线()加回车键[enter]的形式跳脱，下一行最前面就会自动出现&gt;符号当要删除一长串错误的指令时，可通过下列两个组合键: ctrl + u / ctrl + k 从光标处向前删除指令串 / 从光标处向后删除指令串 ctrl + a / ctrl + e 让光标移动到整个指令串的最前面 / 让光标移动到整个指令串的最后面 变量的取用与设置：echo，变量设置规则 unset可以使用 echo $变量名 或 echo ${变量名}取用变量 设置或修改变量的内容使用等号表达式=就好啦12myname(变量名) = 123echo myname 变量的设置规则 变量与变量内容用 = 连接 等号两边不能直接接空白字符 变量名称只能是英文字母或数字，并且不能以数字开头 值中如果有空白字符，可用双引号或单引号包住 （双引号中可放变量，单引号中只能放纯文本） 可用\将特殊字符转义 若该变量需要在其他子程序执行，则需要以export来使变量变成环境变量：”export PATH” 通常大写字符为系统默认变量，自行设置变量可以使用小写字符，方便判断 取消变量的方法：unset unset myname 环境变量的功能查阅shell中默认的环境变量env or export 以下为小弟我本人的环境变量，懒得贴图了，直接上手粘！1234567891011121314151617181920TMPDIR=/var/folders/g2/37j_jdzj0r5fkpqt5x40nz480000gn/T/XPC_FLAGS=0x0Apple_PubSub_Socket_Render=/private/tmp/com.apple.launchd.DfBySdnMtL/RenderTERM=xterm-256colorLANG=zh_CN.UTF-8SSH_AUTH_SOCK=/private/tmp/com.apple.launchd.fJOM7N4nto/ListenersSECURITYSESSIONID=186a7XPC_SERVICE_NAME=0TERM_PROGRAM=Apple_TerminalTERM_PROGRAM_VERSION=404TERM_SESSION_ID=9BE3D49E-883B-4B2B-8A36-95D53498D377SHELL=/bin/zshHOME=/Users/zhaodanliLOGNAME=zhaodanliUSER=zhaodanliPATH=/usr/bin:/bin:/usr/sbin:/sbin:/usr/local/binSHLVL=1PWD=/Users/zhaodanliOLDPWD=/Users/zhaodanli_=/usr/bin/env 上面的键值对都是啥意思？我们来一！个！一！个！分！析！HOME —— 代表使用者的主文件夹SHELL —— 目前这个环境使用的shell是哪支程序PATH —— 可执行文件搜索的路径，目录与目录中间以冒号分隔LANG —— 语系数据 用set观察所有变量(环境变量 + 自订变量)(懒得贴图了，直接上手粘！)123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146&apos;!&apos;=49751&apos;#&apos;=0&apos;$&apos;=28217&apos;*&apos;=( )-=569XZilms0=-zsh&apos;?&apos;=0@=( )ARGC=0Apple_PubSub_Socket_Render=/private/tmp/com.apple.launchd.DfBySdnMtL/RenderCDPATH=&apos;&apos;COLORFGBG=&apos;12;8&apos;COLORTERM=truecolorCOLUMNS=119CPUTYPE=x86_64EGID=20EUID=501FIGNORE=&apos;&apos;FPATH=/usr/local/share/zsh/site-functions:/usr/share/zsh/site-functions:/usr/share/zsh/5.3/functionsGID=20HISTCHARS=&apos;!^#&apos;HISTCMD=74HISTSIZE=30HOME=/Users/zhaodanliHOST=zhaodanlideMacBook-Air.localIFS=$&apos; \t\n\C-@&apos;ITERM_PROFILE=DefaultITERM_SESSION_ID=w1t0p0:76A29E5F-591E-44CB-B999-C0C6AFACFD3FKEYBOARD_HACK=&apos;&apos;KEYTIMEOUT=40LANG=zh_CN.UTF-8LINENO=94LINES=21LISTMAX=100LOGCHECK=60LOGNAME=zhaodanliMACHTYPE=x86_64MAILCHECK=60MAILPATH=&apos;&apos;MANPATH=&apos;&apos;MODULE_PATH=/usr/lib/zsh/5.3NULLCMD=catOLDPWD=/Users/zhaodanliOPTARG=&apos;&apos;OPTIND=1OSTYPE=darwin17.0PATH=/usr/bin:/bin:/usr/sbin:/sbin:/usr/local/binPPID=28214PROMPT=&apos;%d $&gt; &apos;PROMPT2=&apos;%_&gt; &apos;PROMPT3=&apos;?# &apos;PROMPT4=&apos;+%N:%i&gt; &apos;PS1=&apos;%d $&gt; &apos;PS2=&apos;%_&gt; &apos;PS3=&apos;?# &apos;PS4=&apos;+%N:%i&gt; &apos;PSVAR=&apos;&apos;PWD=/Users/zhaodanli/danli/sina_project/lottery_pcRANDOM=29048READNULLCMD=moreSAVEHIST=0SECONDS=33670SHELL=/bin/zshSHLVL=1SPROMPT=&apos;zsh: correct &apos;\&apos;&apos;%R&apos;\&apos;&apos; to &apos;\&apos;&apos;%r&apos;\&apos;&apos; [nyae]? &apos;SSH_AUTH_SOCK=/private/tmp/com.apple.launchd.fJOM7N4nto/ListenersTERM=xterm-256colorTERM_PROGRAM=iTerm.appTERM_PROGRAM_VERSION=3.2.9TERM_SESSION_ID=w1t0p0:76A29E5F-591E-44CB-B999-C0C6AFACFD3FTIMEFMT=&apos;%J %U user %S system %P cpu %*E total&apos;TMPDIR=/var/folders/g2/37j_jdzj0r5fkpqt5x40nz480000gn/T/TMPPREFIX=/tmp/zshTRY_BLOCK_ERROR=-1TRY_BLOCK_INTERRUPT=-1TTY=/dev/ttys000TTYIDLE=0UID=501USER=zhaodanliUSERNAME=zhaodanliVENDOR=appleWATCH=&apos;&apos;WATCHFMT=&apos;%n has %a %l from %m.&apos;WORDCHARS=&apos;*?_-.[]~=/&amp;;!#$%^()&#123;&#125;&lt;&gt;&apos;XPC_FLAGS=0x0XPC_SERVICE_NAME=0ZSH_ARGZERO=-zshZSH_EVAL_CONTEXT=toplevelZSH_NAME=zshZSH_PATCHLEVEL=zsh-5.3-0-g4cfdbdbZSH_SUBSHELL=0ZSH_VERSION=5.3_=set__CF_USER_TEXT_ENCODING=0x0:25:52aliasesargv=( )builtinscdpath=( )commandsdirstackdis_aliasesdis_builtinsdis_functionsdis_galiasesdis_patcharsdis_reswordsdis_saliasesfignore=( )fpath=( /usr/local/share/zsh/site-functions /usr/share/zsh/site-functions /usr/share/zsh/5.3/functions )funcfiletracefuncsourcetracefuncstackfunctionsfunctracegaliaseshistchars=&apos;!^#&apos;historyhistorywordsjobdirsjobstatesjobtextskeymapsmailpath=( )manpath=( )module_path=( /usr/lib/zsh/5.3 )modulesnameddirsoptionsparameterspatcharspath=( /usr/bin /bin /usr/sbin /sbin /usr/local/bin )pipestatus=( 0 )prompt=&apos;%d $&gt; &apos;psvar=( )reswordssaliasessignals=( EXIT HUP INT QUIT ILL TRAP ABRT EMT FPE KILL BUS SEGV SYS PIPE ALRM TERM URG STOP TSTP CONT CHLD TTIN TTOU IO XCPU XFSZ VTALRM PROF WINCH INFO USR1 USR2 ZERR DEBUG )status=0termcapterminfouserdirswatch=( )widgetszle_bracketed_paste=( $&apos;\C-[[?2004h&apos; $&apos;\C-[[?2004l&apos; )zsh_eval_context=( toplevel )zsh_scheduled_events PS1 —— 提示字符的设置$ —— 关于本shell的pid(process id 线程id)，想要知道我们的shell的pid,可用通过 echo $$ 得到? —— 关于上个执行指令的回传值 env 和 set两者之间的差异在于”该变量是否会被子程序所继续引用”当你登录linux并取得一个bash后，这个bash就是一个独立程序了，这个程序是通过pid来识别的，接下来在这个bash下所下达的任何指令都是由这个bash衍生出来的，哪些被下达的指令就被称为子程序了。而子程序只会继承父程序的环境变量，子程序不会继承父程序的自订变量。所以原本bash的自订变量在进入子程序后就会消失。 如何让自订变量变成环境变量？？？当当当当 ~ 锵 ~export 变量名执行以上操作后，就可以分享自己的变量设置给后来调用的文件或其他程序了 其实呢， 环境变量可以看做是全局变量， 自订变量可以看做的局部变量 命令别名的设置执行以下命令alias lm=&#39;ls -al | more&#39;即可执行lm指令 历史命令 history通过执行history查看历史命令执行!n可以选择下达第n个指令 万用字符与特殊符号 *代表”0到无穷多个”任意字符 ?代表“一定有一个”任意字符 [-]若有减号在中括号内时，代表”在编码顺序内的所有字符”例如[0-9]表示所有数字 [^]若中括号内的第一个字符为^表示取反实例：ll -d /etc/cron* 找出/ect/下以cron开头的文件名ll -d /etc/????? 找出/etc/下刚好是我五个字母的文件名ll -d /etc/[^a-z]找出/etc/下文件名非小写字母开头的文件名 命令执行的判断依据： ; , &amp;&amp; ||很多指令需要在一次输入去执行，而不想分次执行时，可通过一次输入多重指令方式cmd ; cmd 分号前的指令执行完成后就会立刻接着执行后面的指令。 若前一个指令执行的结果为正确，在linux下面会回传一个$?=0的值，可通过短路语句判断后续操作是否要继续执行cmd1 &amp;&amp; cmd2 若cmd1执行完毕且执行正确($?=0)，则开始执行cmd2ls /temp/vbird &amp;&amp; echo &quot;exist&quot; || echo &quot;not exist&quot; //如果vbird存在则打印exist，否则打印not exist 管道命令 pipe |管道命令”|”仅能处理有前面一个指令传来的正确信息，对于错误信息没有处理能力 頡取命令: cur grep将一段数据经过分析后，取出我们所想要的，或者是经由分析关键字，取得我们所想要的那一行！cut——将一段信息的某一段给他“切”出来，处理的信息是以行为单位 grep分析一行信息，若当中有我们所需要的信息，就将该行拿出来语法如下1234567grep [-acinv] [--color=auto] &apos;搜寻字串&apos; filename选项与参数-a : 将binary文件以text文件的方式搜寻数据-c : 计算找到&apos;搜寻字串&apos;的次数-i : 忽略大小写的不同-n : 随便输出行号-v : 反向选择，即显示出没有&apos;搜寻字串&apos;内容的那一行 eg:将last中，有root字符的那行取出last | grep &#39;root&#39; eg:将last中，没有root字符的那行取出last | grep -v &#39;root&#39; 排序命令： sort wc uniqLinux的账号与群组使用者识别码 UID(user id) 与 GID(group id)使用者功能不论是useradd/usermod/userdel,都是系统管理员能够使用的指令，一般身份使用者可使用以下常用的账号数据变更与查询指令:1.id查新某人或者自己的相关uid/gid等信息2.finger查阅很多使用者相关的信息，是一个比较危险的指令 使用者身份切换安全起见，尽量使用一般身份使用者来操作linux的日常作业，等到需要设置系统环境时，才变换身份为root来进行系统管理。 如何让一般使用者转变身份成为root呢？主要有以下两种方式： 以su-直接将身份变成root即可，但是这个指令却需要root的密码，也就是说如果你要以su变成root的话，你的一般使用者就必须要有root的密码才行； 以sudo指令执行root的指令串，由于sudo需要实现设置妥当，且sudo需要输入使用着自己的密码，因此多人共同管理同一部主机时，sudo要比su更加好用且安全。 su若要完整的切换到新使用者的环境，必须要使用su - username或者su -l username才会连同PATH/USER/MAIL等变量都转成新使用者的环境使用root切换成为任何使用者时，并不需要输入新使用者的密码 虽然使用su很方便，但是缺点是：当主机是多人共管时，如果大家都要使用su来切换成为Root身份，那么每个人都要知道root的密码，很不安全 sudosudo的执行仅需要自己的密码即可，由于sudo可以让你以其他用户的身份(通常是使用root的身份来执行指令)，因此并非所有人都能够执行sudo,仅有规范到/etc/sudoers内的 sudo的指令用法由于一开始系统默认仅有root可以执行sudo sudo默认仅有root能使用，因为sudo的执行是这样的流程：1.当使用者执行sudo时，系统于/etc/sudoers文件中搜寻该使用者是否有执行sudo的权限2.若使用者具有可执行sudo的权限后，便让使用者”输入使用者自己的密码”来确认3.若密码输入成功，便开始进行sudo后续借接的指令(但root执行sudo时，不需要输入密码)4.若想要切换的身份与执行者身份相同，那也不需要输入密码 /etc/sudoers文件要通过visudo修改为什么要使用visudo呢，因为/ect/sudoers是有设置语法的，如果设置错误会造成无法使用sudo指令的不良后货。因此才会使用visudoo去修改，并在结束离开修改画面时，系统会去检验/etc/sudoers的语法 linux主机上的使用者讯息传递查询使用者:w, who, last, lastlogw who: 查看已登录在系统上面的使用者 使用者对谈：write, mesg, wallwrite可以直接将讯息传给接受者。 磁盘配额(Quota)的应用与实作…[未完待续] 692页]]></content>
      <categories>
        <category>计算机</category>
        <category>操作系统</category>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[webpack打包时会打包其他独立页面的js文件[走查纠错]]]></title>
    <url>%2F2019%2F04%2F11%2Fwebpack_bug_fix%2F</url>
    <content type="text"><![CDATA[前言：在开发过程中，遇到一个神奇的问题，Vue多页面配置，打包时，会莫名其妙产生了两个chunk文件，而且这个文件十分庞大，仔细看了下，这个页面中根本没有引入这个文件/(ㄒoㄒ)/~~ 怎么肥四呢~ 正好趁着坑还热乎！ 抓紧去webpack官网看下 打包究竟是怎样的一个流程~ PS:https://webpack.docschina.org/concepts/ webpack官网https://webpack.docschina.org/plugins webpack插件列表， 福音啊~~https://github.com/webpack-contrib/awesome-webpack#webpack-plugins 更多第三方插件，查看 awesome-webpack列表 插件接口(plugin interface) 功能极其强大，可以用来处理各种各样的任务。[删] 核心文档梳理 (基于v4.29.6版本) ↓1.entry每个html对应一个entry入口起点 值：string || array || object 1.1 单个入口（简写）语法123456789101112131415-------------单入口 ↓-------------module.exports = &#123; entry: &#123; main: &apos;入口文件相对路径.js&apos; &#125;&#125;简写：module.exports = &#123; entry: &apos;入口文件相对路径.js&apos;&#125;-------------多入口 ↓-------------使用场景：一次注入多个依赖文件，并将他们的依赖导向到一个chunkmodule.exports = &#123; entry: [&apos;入口文件相对路径1.js&apos;,&apos;入口文件相对路径2.js&apos;]&#125; 1.2 对象语法对于多页面应用程序来说，页面之间都是相互独立的，这就需要有多个入口分离打包同时，随着入口起点的增多，多页面应用能够复用入口起点之间的大量代码/模块，使用 optimization.splitChunks【有待深入】 为页面间共享的应用程序代码创建 bundle，可以极大地优化应用。123456module.exports = &#123; entry: &#123; app: &apos;./xxx/app.js&apos;, adminApp: &apos;./xxx/adminApp.js&apos; &#125;&#125;; 2.output控制webpack如何向硬盘写入便以文件。多个entry起点，仅会指定一个output配置 app-&gt;应用程序vendor-&gt;第三方库 …[未完待续]]]></content>
      <categories>
        <category>前端</category>
        <category>webpack</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>webpack</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[发布 npm 包]]></title>
    <url>%2F2019%2F04%2F10%2FnpmPublish%2F</url>
    <content type="text"><![CDATA[文章源自发布 npm 包, 如有侵权 请联系删除 1.项目初始化vue init webpack-simple 项目名称 项目结构如下 项目结构 2.components/index.js 文件下 引入文件组件import zlCalendar from &apos;./zl-calendar&apos; import zlRange from &apos;./zl-range&apos; import zlSlideDelete from &apos;./zl-slide-delete&apos; const comment = { install:function(Vue){ Vue.component(&apos;zlCalendar&apos;, zlCalendar) Vue.component(&apos;zlRange&apos;, zlRange) Vue.component(&apos;zlSlideDelete&apos;, zlSlideDelete) } } // global 的状态下自动安装 if(typeof window !== &apos;undefined&apos; &amp;&amp; window.Vue){ window.Vue.use(comment) } // 导出模块 export default comment 3. 修改 package.json{ &quot;name&quot;: &quot;zl-vue-ui&quot;, &quot;description&quot;: &quot;A Vue.js project&quot;, &quot;version&quot;: &quot;1.0.3&quot;, &quot;author&quot;: &quot;徐其闯 &lt;xqc1319681561@163.com&gt;&quot;, &quot;main&quot;: &quot;dist/zl-vue-ui.js&quot;,// 配置main结点，如果不配置，我们在其他项目中就不用import XX from &apos;包名&apos;来引用了，只能以包名作为起点来指定相对的路径 &quot;license&quot;: &quot;MIT&quot;, &quot;private&quot;: false, // 因为组件包是公用的，所以private为false &quot;scripts&quot;: { &quot;dev&quot;: &quot;cross-env NODE_ENV=development webpack-dev-server --open --hot&quot;, &quot;build&quot;: &quot;cross-env NODE_ENV=production webpack --progress --hide-modules&quot; }, &quot;repository&quot;: { // 指定代码所在的仓库地址 &quot;type&quot;: &quot;git&quot;, &quot;url&quot;: &quot;git+https://github.com/xuqichuang/zl-vue-ui.git&quot; }, &quot;dependencies&quot;: { &quot;better-scroll&quot;: &quot;^1.14.1&quot;, &quot;moment&quot;: &quot;^2.24.0&quot;, &quot;vue&quot;: &quot;^2.5.11&quot; }, &quot;browserslist&quot;: [ &quot;&gt; 1%&quot;, &quot;last 2 versions&quot;, &quot;not ie &lt;= 8&quot; ], &quot;keywords&quot;: [// 指定关键字 &quot;vue&quot;, &quot;vue-ui&quot; ], &quot;devDependencies&quot;: { &quot;babel-core&quot;: &quot;^6.26.0&quot;, &quot;babel-loader&quot;: &quot;^7.1.2&quot;, &quot;babel-preset-env&quot;: &quot;^1.6.0&quot;, &quot;babel-preset-stage-3&quot;: &quot;^6.24.1&quot;, &quot;cross-env&quot;: &quot;^5.0.5&quot;, &quot;css-loader&quot;: &quot;^0.28.7&quot;, &quot;file-loader&quot;: &quot;^1.1.4&quot;, &quot;node-sass&quot;: &quot;^4.9.3&quot;, &quot;sass-loader&quot;: &quot;^7.1.0&quot;, &quot;vue-loader&quot;: &quot;^13.0.5&quot;, &quot;vue-template-compiler&quot;: &quot;^2.4.4&quot;, &quot;webpack&quot;: &quot;^3.6.0&quot;, &quot;webpack-dev-server&quot;: &quot;^2.9.1&quot; } } 4.修改webpack.config.js// entry: &apos;./src/main.js&apos;, entry: &apos;./src/components/index.js&apos;, output: { path: path.resolve(__dirname, &apos;./dist&apos;), publicPath: &apos;/dist/&apos;, // filename: &apos;build.js&apos; filename: &apos;zl-vue-ui.js&apos;, library: &apos;zl-vue-ui&apos;, libraryTarget: &apos;umd&apos;, umdNamedDefine: true }, 5.修改.gitignore 文件因为要用dist文件夹，所以在.gitignore文件中把dist/去掉。 6.修改index.html&lt;!-- &lt;script src=&quot;/dist/build.js&quot;&gt;&lt;/script&gt; --&gt; &lt;script src=&quot;/dist/zl-vue-ui.js&quot;&gt;&lt;/script&gt; 7.测试插件在发正式包之前可以在本地先打一个包，然后测试下有没有问题，如果没问题再发布到npm上。 首先，打包到本地 npm run build npm pack npm pack 之后，就会在当前目录下生成 一个tgz 的文件。打开一个新的vue项目，在当前路径下执行(‘路径’ 表示文件所在的位置) npm install 路径/组件名称.tgz //使用方法import 变量名 from ‘组件名称’Vue.use(变量名) 8.发布到NPM 在 npm官网 注册一个npm账号 切换到需要发包的项目根目录下，npm login登录npm账号，输入用户名、密码、邮箱 最后一步，执行npm publish即可 发布到NPM后，使用插件时可以用npm install 组件名称 来安装]]></content>
      <categories>
        <category>npm</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>npm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue源码分析笔记]]></title>
    <url>%2F2019%2F03%2F23%2Fvuebasic%2F</url>
    <content type="text"><![CDATA[vue中的computed原理:set/get方法123456789101112131415161718192021222324//元素值变化的监听const obj = &#123; fName:&apos;ZHAO&apos;, lName:&apos;Danli&apos;,&#125;//obj.fullName = obj.fName + &apos;-&apos; + obj.lName;Object.defineProperty(obj,&apos;fullName&apos;,&#123; get()&#123; //根据其他相关的属性动态计算得到当前属性值 [被动] return this.fName + &apos;-&apos; + this.lName; &#125;, set(value)&#123; //监听当前属性值变化，更新其他相关属性 [主动] const names = value.spilt(&apos;-&apos;); this.fName = names[0]; this.lName = names[1]; &#125;,&#125;)console.log(obj.fullName);obj.fName = &apos;Bai&apos;; //fullName被动改变obj.lName = &apos;Kunjuan&apos;;console.log(obj.fullName);obj.fullName = &apos;Yang-shulin&apos;; //主动变更其他属性值console.log(obj.fName);console.log(obj.lName); DocumentFragment 详细请至MDN(改成链接)查看优：内存中保存多个element的内容容器，不与界面关联 【不会影响界面渲染】，避免过多重流 const ul = document.documentById(&apos;test1&apos;); //创建fragment const fragment = document.createDocumentFragment(); //取出test1中的所有子节点保存到fragment中 let child; while(child = ul.firstChild) { //取出ul的第一个子节点，赋值给child,判断child是否为true fragment.appendChild(child); //⚠️一个节点只能有一个父节点，因此一旦把child添加给fragment了，就脱离了其之前的父节点 } //改变fragment中的所有需要变更的子节点 let childs = fragment.childNodes(); //得到所有的子节点 Array.prototype.slice.call(childs).forEach((node,index)=&gt;{ if(node.nodeType == 1) { //当前节点为元素节点 node.textContent = &apos;新文本内容&apos;+index; } }) //用更改好的fragment插入到test1 ul.appendChild(); 数据代理：通过一个对象代理对另一个对象中属性的操作(读/写)vue数据代理:通过vm对象代理data对象中所有属性的操作原理:Object.defineProperty [es5语法 ie8不支持] 模板解析 …[未完待续]]]></content>
      <categories>
        <category>前端</category>
        <category>vue</category>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>vue</tag>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[理解fileReader]]></title>
    <url>%2F2018%2F12%2F22%2FfileReader%2F</url>
    <content type="text"><![CDATA[TODO … ｄ(･∀･*)♪ﾟ]]></content>
  </entry>
  <entry>
    <title><![CDATA[git常用命令]]></title>
    <url>%2F2018%2F10%2F15%2Fgit-command%2F</url>
    <content type="text"><![CDATA[配置12345678910git config --global user.name &quot;ihoey&quot; // 设置git用户名git config --global user.email &quot;mail@163.com&quot; // 设置git邮箱git config --global color.ui true // 为true是终端着色git config --global alias.co checkout // 配置checkout的别名git config --global alias.ci commit // 配置commit别名git config --global alias.cm commit // 配置commit别名git config --global alias.br branch // 配置branch别名git config --global alias.cp cherry-pick // 配置cherry-pick别名git config --global alias.rb rebase // 配置rebase别名git config -l // 列举所有配置 基本命令12git init // 创建git仓库git status // 查看文件提交状态 commit1234git commit -amend // 修改注释git commit --amend -m &quot;xxxx&quot; // 修改注释git commit -m &quot;xxxx&quot; // 提交文件(暂存区-&gt;本地仓库)git merge --squash branchname //将多次提交合并成一个，然后git add . (等步骤) diff123456789git diff filepaht // 比较文件不同 (工作区 vs 暂存区)git diff HEAD filepath // 比较文件不同 (工作区 vs HEAD[当前工作分支])git diff --staged filepath // 比较文件不同 (暂存区 vs HEAD[当前工作分支])git diff --cached filepath // 比较文件不同 (暂存区 vs HEAD[当前工作分支])git diff branchname filepath // 比较文件不同 (当前分支文件 vs branchname 分支文件)git diff commitid filepath // 比较文件不同 (与某次提交进行比较)git diff commitid1 commitid2 // 比较两次提交间的不同git diff branch1..branch2 // 比较两个分支git diff --stat // 仅比较统计信息 checkout12git checkout -- filepath // 抛弃工作区对此文件的修改git checkout . // 抛弃工作区修改 工作区123git rm filename1 filename2 // 删除工作区文件，并且将这次删除放入暂存区git rm --cached filename // 停止追踪指定文件，但该文件会保留在工作区git fetch --all // 刷新工作区 暂存区12git reset HEAD // 清空暂存区git rm --cached &lt;file&gt; // 从暂存区删除一个文件 工作区 -&gt; 暂存区1234git add fileName // 添加指定文件(工作区-&gt;暂存区)git add . // 添加所有已更改文件(工作区-&gt;暂存区)git add *.js // 添加所有后缀为js的文件到暂存区git add filename -f // 强行添加一个不被版本跟踪的文件 重置/撤销 reset revert123456789101112131415161718暂存区 -&gt; 工作区 ??git reset filename // 暂存区-&gt;工作区,工作区不变git reset -- . // 暂存区全部文件 -&gt; 工作区git reset --hard // 重置暂存区和工作区，与上一次commit保持一致git reset [commit] // 重置当前分支的指针为指定commit,同时重置暂存区，工作区不变git reset --hard [commit] // 重置当前分支的HEAD为指定commit,同时重置暂存区和工作区，与指定commit一致git reset --keep [commit] // 重置当前HEAD为指定commit,但暂存区和工作区不变git revert [commit] // 新建一个commit,用来撤销指定commit(假回滚)git revert HEAD // 恢复到最后一次提交的状态git reset -hard commitid // 回滚到xx时的状态git reset -soft commitid // 会将之前的修改全部进行revertgit reset –mixed // 此为默认方式，不带任何参数的git reset，即时这种方式，它回退到某个版本，只保留源码，回退commit和index信息git reset –soft // 回退到某个版本，只回退了commit的信息，不会恢复到index file一级。如果还要提交，直接commit即可git reset –hard // 彻底回退到某个版本，本地的源码也会变为上一个版本的内容git reset &lt;commit&gt; --soft --hard：--soft // 将所有被更改的文件回溯到“待提交”状态--hard // commit 之后，对被git追踪的文件的任何更改都被丢弃 查看提交记录12345git log filepath // 查看该文件每次提交记录git log // 查看提交记录git log -p filepath // 查看每次详细修改内容的diffgit log -p -2 // 查看最近两次详细修改内容的diffgit log --stat // 查看提交统计信息 分支1234567891011121314151617181920212223242526272829303132333435git branch -l // 查看本地分支git branch -r // 查看远程分支git branch branchname // 创建新分支git branch -v // 查看各个分支最后提交信息git branch --merged // 查看已经被合并到当前分支的分支git branch --no-merged // 查看尚未被合并到当前分支的分支git checkout branchname // 切换到此分支git checkout -b branchname // 创建新的分支，并切换到新分支git checkout -b [newbranch] [refbranch] // 基于refbranch分支，创建新分支，并切换git checkout commitid // 把某次历史提交记录checkout出来，但无分支信息，却环岛其他分支会自动删除git checkout commitid -b branchname // 把某次历史提交记录checkout,创建成一个新分支git branch -d branchname // 删除某个分支git branch -D branchname // 强制删除某个分支(未被合并的分支被删除的时候需要强制)git checkout -f branchname // 强制切换分支git checkout -f branchname // 强制checkout分支覆盖本地文件分支合并git merge branchname // 将branch分支合并到当前分支git merge --no-ff branchname // 不要fast-foward合并，这样可以生成merge提交git rebase master branchname // 将master合并到branch,相当于：git checkout branchname &amp;&amp; git rebase master &amp;&amp; git checkout master &amp;&amp; git merge branchname远程分支管理git pull // 抓取远程仓库所有分支更新合并到本地git pull --no-ff // 不要fast-foward合并，抓取远程仓库所有分支更新合并到本地git fetch origin // 抓取远程仓库更新git merge origin/master // 远程master分支 合并到 本地当前分支git checkout --track origin/branchname // 跟踪此远程分支，创建相应的本地分支git push // push所有分支git push origin master // push 本地分支 -&gt; 远程master分支git push -u origin master // push 本地分支 -&gt; 远程master分支 (当无远程master分支则创建，用于初始化远程仓库)git push origin &lt;local_branch&gt; // 创建远程分支(与本地分支同名)git push origin &lt;local_branch&gt;:&lt;remote_branch&gt; // 创建远程分支git push origin :&lt;remote_branch&gt; // 删除本地分支，再删除远程分支git checkout -b branchname -t origin/master //基于远程master分支创建branchname分支 远程仓库1234git remote -v // 查看远端地址git remote add origin https://gitxxxxxx.git // 要求服务已经建立同名仓库git remote // 显示远程仓库git remote show origin // 显示origin远程库的详情 tag123456789git tag // 查看taggit tag tagname // 创建一个taggit push --tags // 将本地tags推送到远程仓库git push tagname // 推送指定的本地tag到远程仓库git describe --tags --abbrev=0 // 展示当前分支的最近的taggit push origin --tags // 一次性推送所有tag,同步到远程仓库git tag -d tagname // 删除本地仓库taggit push origin :refs/tags/tagname // 删除远程tag,前提是需要先删除本地taggit checkout -b brachname tagname // 切回到某个tag 其他123456git reflog #输出详细的操作历史~/.gitconfig #用户的git配置文件目录gitk --all &amp; #打开git图形化界面git chean -f #删除工作目录中不被git进行版本追踪的文件git clean -xf #删除当前目录下没有被track过的文件和文件夹.gitignore #告诉git,哪些文件不被加入版本控制]]></content>
      <categories>
        <category>git</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
</search>
