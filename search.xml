<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[内外层都有overflow:auto时,滚动条问题]]></title>
    <url>%2F2019%2F05%2F31%2Fjs_q1%2F</url>
    <content type="text"><![CDATA[当div1元素的width || height 小于 内层ul1元素时,内存元素的overflow:auto失效,temp1.html ↓1234567891011121314151617181920212223242526272829303132333435363738&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;内外层双滚动条问题&lt;/title&gt; &lt;style&gt; .div1 &#123; overflow: auto; position: fixed; font-size: 14px; top: 0; bottom: 0; left: 0; right: 0; background: orange; z-index: 100; &#125; .ul1 &#123; width:700px; height:400px; overflow:auto; background:pink; &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div class=&quot;div1&quot;&gt; &lt;ul class=&quot;ul1&quot;&gt; &lt;li&gt;测试1&lt;/li&gt;&lt;li&gt;测试1&lt;/li&gt;&lt;li&gt;测试1&lt;/li&gt;&lt;li&gt;测试1&lt;/li&gt;&lt;li&gt;测试1&lt;/li&gt; &lt;li&gt;测试1&lt;/li&gt;&lt;li&gt;测试1&lt;/li&gt;&lt;li&gt;测试1&lt;/li&gt;&lt;li&gt;测试1&lt;/li&gt;&lt;li&gt;测试1&lt;/li&gt; &lt;li&gt;测试1&lt;/li&gt;&lt;li&gt;测试1&lt;/li&gt;&lt;li&gt;测试1&lt;/li&gt;&lt;li&gt;测试1&lt;/li&gt;&lt;li&gt;测试1&lt;/li&gt; &lt;li&gt;测试1&lt;/li&gt;&lt;li&gt;测试1&lt;/li&gt;&lt;li&gt;测试1&lt;/li&gt;&lt;li&gt;测试1&lt;/li&gt;&lt;li&gt;测试1&lt;/li&gt; &lt;li&gt;测试1&lt;/li&gt;&lt;li&gt;测试1&lt;/li&gt;&lt;li&gt;测试1&lt;/li&gt;&lt;li&gt;测试1&lt;/li&gt;&lt;li&gt;测试1&lt;/li&gt; &lt;li&gt;测试1&lt;/li&gt;&lt;li&gt;测试1&lt;/li&gt;&lt;li&gt;测试1&lt;/li&gt;&lt;li&gt;测试1&lt;/li&gt;&lt;li&gt;测试1&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt; 解决方案:外层容器的width不要与窗口宽度相同实现方法 (缺陷:外层容器没有滚动条，在firefox中会显示滚动条)1234567.div1 &#123; width:110%; overflow-x:hidden; overflow-y:auto; // overflow: auto; // right:0;&#125;]]></content>
      <categories>
        <category>前端</category>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[javascript逗号表达式]]></title>
    <url>%2F2019%2F05%2F28%2Fjs_comma%2F</url>
    <content type="text"><![CDATA[逗号表达式： 一般形式：表达式1，表达式2，表达式3，……表达式n 求解过程：先计算表达式1的值，再计算表达式2的值，......一直计算到表达式n的值。最后整个表达式的值是表达式n的值。 看下面几个例子：123451）x = 8*2, x*4; /*整个表达式为逗号表达式，它的值为64，x的值为16*/2）(x = 8*2, x*4) , x*2; /*整个表达式为逗号表达式，它的值为32，x的值为16*/3）x = (z=5,5*2); /*整个表达式为赋值表达式，它的值为10，z的值为5*/ 请注意：并不是所有的逗号都要看成逗号运算符，如在函数调用时，各个参数是用逗号分隔开的，这里的逗号并不是逗号运算符。如：printf(“%d, %d, %d”, x, y, z); for循环中逗号运算符逗号运算符的常见用法是在for循环的增量表达式中使用。例如：1234var i,j=5,k;for(i=0; i&lt;10; i++,j++) &#123; k = i + j;&#125; 在每次通过循环的结尾时，for语句只允许单个表达式被执行。逗号运算符允许将多个表达式视为单个表达式，因此这两个变量都递增。 逗号运算符与函数调用运算符的冲突在JavaScript中函数调用确实是函数调用运算符。它很特殊，因为其它编程语言资料中从来没有这个叫法。 函数调用运算符将计算它的每一个运算数，第一个运算数指定为函数名（括号前），而括号中的所有运算数的值将传递给这个函数作为参数。 接下来看一个逗号运算符和函数运算符冲突的例子以及解决的方法。12alert(2,5); //2alert((2,5)); //5 由于逗号运算符在JavaScript中的优先级是最低的，因此函数运算符将先于逗号运算符运行，上述代码中第一个alert函数弹出2。 解决方法如第二个alert函数所示，加上括号，保证逗号运算符先运行。 逗号运算符和赋值运算符冲突123var a = 20;var b = ++a, 10;console.log(b); 上述代码报错：由于逗号运算符要求它的运算数为复杂表达式或简单 表达式（如变量或直接量），赋值运算符先于逗号运算符执行，使逗号运算符左边不是一个运算数或表达式，而是含有var关键字的语句，因此报错。解决方法：只需加上括号，即var b = (++a, 10)，保证逗号运算符先执行即可。 再看几个示例，后两个示例略为奇葩。 示例一：1234console.log((0,9)); //9console.log((9,0)); //0if((9,0)) console.log(&quot;no&quot;);if((0,9)) console.log(&quot;yes&quot;); //yes 示例二：交换变量，无需第三个变量12345var a = &apos;a&apos;, b = &apos;b&apos;;//method1a = [b,b=a][0];//method2a = [b][b=a,0]; 分析：a = [b,b=a][0]中，[b,b=a]表示一维数组，[0]表示下标；a = [b][b=a, 0]，其中[b]表示一维数组，[b=a, 0]中按逗号运算符处理，返回0，当做下标。 在这个例子中，我一直将在[b,b=a][0]和[b][b=a, 0]视作二维数组，这不对的。 一维数组形式：[1,2,3][0] //取得值1 二维数组形式：[[1,2,3],[4,5,6]][1][1] //取得值5 不过上述两种数组表示形式很少用。 示例三：简化代码，不过可读性差 12345678if(x) &#123; foo(); return bar();&#125; else &#123; return 1;&#125;// equal to return x ? (foo(), bar()) : 1; 文章转载自 JavaScript逗号运算符]]></content>
      <categories>
        <category>algorithm</category>
      </categories>
      <tags>
        <tag>algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[javascript运算符优先级]]></title>
    <url>%2F2019%2F05%2F28%2Fjs_operator_precedence%2F</url>
    <content type="text"><![CDATA[]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mac快捷键]]></title>
    <url>%2F2019%2F05%2F21%2Fmac_quickkey%2F</url>
    <content type="text"><![CDATA[符号说明⌘：command⌃：control⌥：option⇧：shift↩：enter⌫：delete ⌘ + space =&gt; 切换输入法 shift =&gt; 切换中英 ^ + space =&gt; Spotlight ⇧ + ⌘ + c =&gt; 打开网页控制台 ⌘ + I =&gt; 显示简介 ⇧ + ⌘ + D =&gt; 打开桌面文件夹 ⇧ + ⌘ + N =&gt; 新建文件夹 ⌘ + o =&gt; 打开所选项 ⌘ + 1 =&gt; 以图标显示 ⌘ + 2 =&gt; 以列表显示 ⌘ + 3 =&gt; 以分栏显示 ⌘ + , =&gt; 打开偏好设置 ⌘ + ` =&gt; 循环显示打开的finder窗口 ⇧ + ⌘ + 3 =&gt; 将屏幕捕捉到文件 ⇧ + ⌘ + 4 =&gt; 将所选内容捕捉到文件 ⌥ + ⌘ + F =&gt; 移到搜索栏控件]]></content>
      <categories>
        <category>mac</category>
      </categories>
      <tags>
        <tag>mac</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[charles抓包使用]]></title>
    <url>%2F2019%2F05%2F21%2Fcharles%2F</url>
    <content type="text"><![CDATA[1.charles官方网站 2.charles官方网站工具类 #文章来源：抓包工具Charles的使用教程]]></content>
      <categories>
        <category>前端</category>
        <category>charles</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>charles</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[好文合集]]></title>
    <url>%2F2019%2F05%2F15%2Fgeneration%2F</url>
    <content type="text"><![CDATA[[实践总结]纯css实现动态边框 移动端页面分享快照生成总结 CSS实现两个球相交的粘粘效果 提高幸福感的 9 个 CSS 技巧 5种滚动吸顶实现方式的比较[性能升级版] 从输入 URL 到展现涉及哪些缓存环节(非常详细) 聊一聊前端换肤 CSS 滚屏效果，要比想象中的难 「真®全栈之路」Web前端开发的后端指南 [前端漫谈_3] 从 filter 聊到 Promise 如何编写高质量的函数 – 敲山震虎篇 不可思议的纯 CSS 滚动进度条效果 css做个波浪悬浮球？ CSS——让这些“展示”有更好的扩展性——媒体查询 使用CSS实现逼真的水波纹点击效果 集中コレクション，CSS垂直居中最强合集，看看你喜欢哪种？ css高级应用三种方法实现多行省略 《CSS世界》中提到的实用技巧 前端常用插件、工具类库汇总，不要重复造轮子啦！！！ [译] 从没有人告诉过我的 CSS 小知识 《CSS揭秘》读书笔记 [译] Web 使用 CSS Shapes 的艺术设计 前端基础篇之HTTP协议 拿起VuePress打造属于自己的专属博客 一名【合格】前端工程师的自检清单 [译] Javascript 中 Array.push 要比 Array.concat 快 945 倍！🤯🤔 JS无形装逼，最为致命 ES6、ES7、ES8、ES9、ES10新特性一览 【周刊-2】三年大厂面试官-前端面试题（偏难） 「中高级前端面试」JavaScript手写代码无敌秘籍 从今天开始，拿起 TypeScript 做一个轮子的制造者 用一次就会爱上的cli工具开发 前端代码质量管理（一） Node 12 值得关注的新特性 React Hooks高仿B站Web移动端直播 Webpack5.0 新特性尝鲜实战 🦀🦀 CSS对话框小尾巴实现的最佳方式 流动的SVG线条 幻术，一行代码实现镂空效果 客栈说书：CSS遮罩CSS3 mask/masks详细介绍 导师计划–数据结构和算法系列（上） 导师计划–数据结构和算法系列（下） 【译】20个更有效地使用谷歌搜索的技巧 LeetCode-OpenSource/hire 编写工程化的业务模块 是时候开发你自己的vscode扩展插件了 【周刊-3】三年大厂面试官-十道前端面试题（欢迎挑战） node批量抓取并下载照片 NodeJs/Vue项目中对process.env的使用 纯 CSS实现根据元素已知的宽度设置高度以及注意事项 CentOS7安装node.js npm scripts 使用指南 【太重要惹】🙆🙆🙆 GitHub OAuth 第三方登录示例教程 前端工具函数 面试官(6): 写过『通用前端组件』吗? Linux生产环境上，最常用的一套“Sed“技巧 7个有用的Vue开发技巧 Node.js + ELK 日志规范 CSS3 box-shadow盒阴影图形生成技术 【算法技巧】位运算装逼指南 由三道 LeetCode 题目简单了解一下位运算 让前端开发者失业的技术，Flutter Web初体验 禁止弹窗中蒙层底部页面跟随滚动的几种方法 代码注释的艺术，再也不怕被说代码可读性差啦！ 有助于理解前端工具的 node 知识 彻底弄懂 Nginx location 匹配 快速上手Nginx 摩拜前端周刊第9期 探索 Serverless 中的前端开发模式 前端面试之手写代码 关于webpack4的14个知识点,童叟无欺 大型项目前端架构浅谈 你本可以少写些 if-else 面试必备！webpack 中那些最易混淆的 5 个知识点 vue-cli3开发Chrome插件实践 从今天开始，学习Webpack，减少对脚手架的依赖(下) 从抓取豆瓣电影聊高性能爬虫思路 前端进阶之什么是BFC？BFC的原理是什么？如何创建BFC？ browserslist 目标浏览器配置表 又是一年D2：颇具匠心的中台技术修养 2019 前端面试 | 知其然，并知其所以然 Vue相关 Vue 使用中的小技巧 5分钟撸一个Vue CLI 插件 Vue实践」武装你的前端项目 如何写好一个vue组件,老夫的一年经验全在这了 自己搭建过vue开发环境吗？ 如何写出一个利于扩展的vue路由配置 [手把手系列之]Docker 部署 vue 项目 调试黑科技 Chrome运行时性能瓶颈分析 chrome开发者工具各种骚技巧]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式 [learn]]]></title>
    <url>%2F2019%2F05%2F15%2Fdesign_patterns%2F</url>
    <content type="text"><![CDATA[TODO … ｄ(･∀･*)♪ﾟ]]></content>
      <categories>
        <category>前端</category>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[DOMContentLoaded与load的区别]]></title>
    <url>%2F2019%2F05%2F15%2Fjs_onLoad%2F</url>
    <content type="text"><![CDATA[DOMContentLoaded顾名思义，就是dom内容加载完毕。那什么是dom内容加载完毕呢？我们从打开一个网页说起。当输入一个URL，页面的展示首先是空白的，然后过一会，页面会展示出内容，但是页面的有些资源比如说图片资源还无法看到，此时页面是可以正常的交互，过一段时间后，图片才完成显示在页面。从页面空白到展示出页面内容，会触发DOMContentLoaded事件。而这段时间就是HTML文档被加载和解析完成。 这时候问题又来了，什么是HTML文档被加载和解析完成。要解决这个问题，我们就必须了解浏览器渲染原理。 当我们在浏览器地址输入URL时，浏览器会发送请求到服务器，服务器将请求的HTML文档发送回浏览器，浏览器将文档下载下来后，便开始从上到下解析，解析完成之后，会生成DOM。如果页面中有css，会根据css的内容形成CSSOM，然后DOM和CSSOM会生成一个渲染树，最后浏览器会根据渲染树的内容计算出各个节点在页面中的确切大小和位置，并将其绘制在浏览器上。下面就是页面加载和解析过程中，浏览器的一个快照 上面我们看到在解析html的过程中，html的解析会被中断，这是因为javascript会阻塞dom的解析。当解析过程中遇到&lt;script&gt;标签的时候，便会停止解析过程，转而去处理脚本，如果脚本是内联的，浏览器会先去执行这段内联的脚本，如果是外链的，那么先会去加载脚本，然后执行。在处理完脚本之后，浏览器便继续解析HTML文档。 同时javascript的执行会受到标签前面样式文件的影响。如果在标签前面有样式文件，需要样式文件加载并解析完毕后才执行脚本。这是因为javascript可以查询对象的样式。 这里需要注意一点，在现代浏览器中，为了减缓渲染被阻塞的情况，现代的浏览器都使用了猜测预加载。当解析被阻塞的时候，浏览器会有一个轻量级的HTML（或CSS）扫描器（scanner）继续在文档中扫描，查找那些将来可能能够用到的资源文件的url，在渲染器使用它们之前将其下载下来。 在这里我们可以明确DOMContentLoaded所计算的时间，当文档中没有脚本时，浏览器解析完文档便能触发 DOMContentLoaded 事件；如果文档中包含脚本，则脚本会阻塞文档的解析，而脚本需要等位于脚本前面的css加载完才能执行。在任何情况下，DOMContentLoaded 的触发不需要等待图片等其他资源加载完成。 接下来，我们来说说load，页面上所有的资源（图片，音频，视频等）被加载以后才会触发load事件，简单来说，页面的load事件会在DOMContentLoaded被触发之后才触发。 我们在 jQuery 中经常使用的 $(document).ready(function() { // ...代码... }); 其实监听的就是 DOMContentLoaded 事件，而 $(document).load(function() { // ...代码... }); 监听的是 load 事件。在用jquery的时候，我们一般都会将函数调用写在ready方法内，就是页面被解析后，我们就可以访问整个页面的所有dom元素，可以缩短页面的可交互时间，提高整个页面的体验。 下面我们在来看看如何实现这两个函数 1、onload事件onload事件所有的浏览器都支持，所以我们不需要什么兼容，只要通过调用123window.onload = function()&#123; &#125; 2、DOMContentLoaded 事件DOMContentLoaded不同的浏览器对其支持不同，所以在实现的时候我们需要做不同浏览器的兼容。 支持DOMContentLoaded事件的，就使用DOMContentLoaded事件； IE6、IE7不支持DOMContentLoaded，但它支持onreadystatechange事件，该事件的目的是提供与文档或元素的加载状态有关的信息。 更低的ie还有个特有的方法doScroll， 通过间隔调用：document.documentElement.doScroll(“left”); 可以检测DOM是否加载完成。 当页面未加载完成时，该方法会报错，直到doScroll不再报错时，就代表DOM加载完成了。该方法更接近DOMContentLoaded的实现。12345678910111213141516171819202122232425262728293031function ready(fn)&#123; if(document.addEventListener) &#123; document.addEventListener(&apos;DOMContentLoaded&apos;, function() &#123; document.removeEventListener(&apos;DOMContentLoaded&apos;,arguments.callee, false); fn(); &#125;, false); &#125; // 如果IE else if(document.attachEvent) &#123; // 确保当页面是在iframe中加载时，事件依旧会被安全触发 document.attachEvent(&apos;onreadystatechange&apos;, function() &#123; if(document.readyState == &apos;complete&apos;) &#123; document.detachEvent(&apos;onreadystatechange&apos;, arguments.callee); fn(); &#125; &#125;); // 如果是IE且页面不在iframe中时，轮询调用doScroll 方法检测DOM是否加载完毕 if(document.documentElement.doScroll &amp;&amp; typeof window.frameElement === &quot;undefined&quot;) &#123; try&#123; document.documentElement.doScroll(&apos;left&apos;); &#125; catch(error)&#123; return setTimeout(arguments.callee, 20); &#125;; fn(); &#125; &#125;&#125;; 最后我们来回答这个问题：我们为什么一再强调将css放在头部，将js文件放在尾部 在面试的过程中，经常会有人在回答页面的优化中提到将js放到body标签底部，原因是因为浏览器生成Dom树的时候是一行一行读HTML代码的，script标签放在最后面就不会影响前面的页面的渲染。那么问题来了，既然Dom树完全生成好后页面才能渲染出来，浏览器又必须读完全部HTML才能生成完整的Dom树，script标签不放在body底部是不是也一样，因为dom树的生成需要整个文档解析完毕。我们再来看一下chrome在页面渲染过程中的，绿色标志线是First Paint的时间。纳尼，为什么会出现firstpaint，页面的paint不是在渲染树生成之后吗？其实现代浏览器为了更好的用户体验,渲染引擎将尝试尽快在屏幕上显示的内容。它不会等到所有HTML解析之前开始构建和布局渲染树。部分的内容将被解析并显示。也就是说浏览器能够渲染不完整的dom树和cssom，尽快的减少白屏的时间。假如我们将js放在header，js将阻塞解析dom，dom的内容会影响到First Paint，导致First Paint延后。所以说我们会将js放在后面，以减少First Paint的时间，但是不会减少DOMContentLoaded被触发的时间。 文章转载：DOMContentLoaded与load的区别]]></content>
      <categories>
        <category>前端</category>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[nodejs[learn]]]></title>
    <url>%2F2019%2F05%2F15%2Fnodejs%2F</url>
    <content type="text"></content>
      <categories>
        <category>前端</category>
        <category>nodejs</category>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>学习笔记</tag>
        <tag>nodejs</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[es6[learn]]]></title>
    <url>%2F2019%2F05%2F15%2Fes6%2F</url>
    <content type="text"><![CDATA[1、编码风格1、块级作用域var命令存在变量提升作用let命令不存在这个问题。建议不再使用var命令，而是使用let命令取代 在let和const之间，建议优先使用const,尤其是在全局环境，不应该设置变量，最好设置为常量 2、字符串静态字符串一律使用单引号或反引号，不使用双引号。动态字符串使用反引号。 3、解构赋值使用数组成员对变量赋值时，优先使用解构赋值。函数的参数如果是对象的成员，优先使用解构赋值。 4、对象单行定义的对象，最后一个成员不以逗号结尾。多行定义的对象，最后一个成员以逗号结尾。对象尽量静态化，一旦定义，就不得随意添加新的属性。如果添加属性不可避免，要使用Object.assign方法。1234567891011// badconst a = &#123;&#125;;a.x = 3;// if reshape unavoidableconst a = &#123;&#125;;Object.assign(a, &#123; x: 3 &#125;);// goodconst a = &#123; x: null &#125;;a.x = 3; 对象的属性和方法，尽量采用简洁表达法，这样易于描述和书写。 5、数组使用扩展运算符（…）拷贝数组。const itemsCopy = [...items];使用 Array.from 方法，将类数组对象转为数组。12const foo = document.querySelectorAll(&apos;.foo&apos;);const nodes = Array.from(foo); 6、函数立即执行函数可以写成箭头函数的形式。123(() =&gt; &#123; console.log(&apos;Welcome to the Internet.&apos;);&#125;)(); 箭头函数取代Function.prototype.bind，不应再用 self/_this/that 绑定 this1234567891011// badconst self = this;const boundMethod = function(...params) &#123; return method.apply(self, params);&#125;// acceptableconst boundMethod = method.bind(this);// bestconst boundMethod = (...params) =&gt; method.apply(this, params); 简单的、单行的、不会复用的函数，建议采用箭头函数。如果函数体较为复杂，行数较多，还是应该采用传统的函数写法。 所有配置项都应该集中在一个对象，放在最后一个参数，布尔值不可以直接作为参数。1234567// badfunction divide(a, b, option = false ) &#123;&#125;// goodfunction divide(a, b, &#123; option = false &#125; = &#123;&#125;) &#123;&#125; 不要在函数体内使用 arguments 变量，使用 rest 运算符（…）代替。因为 rest 运算符显式表明你想要获取参数，而且 arguments 是一个类似数组的对象，而 rest 运算符可以提供一个真正的数组。12345678910// badfunction concatenateAll() &#123; const args = Array.prototype.slice.call(arguments); return args.join(&apos;&apos;);&#125;// goodfunction concatenateAll(...args) &#123; return args.join(&apos;&apos;);&#125; 使用默认值语法设置函数参数的默认值。123456789// badfunction handleThings(opts) &#123; opts = opts || &#123;&#125;;&#125;// goodfunction handleThings(opts = &#123;&#125;) &#123; // ...&#125; 7、Map结构注意区分 Object 和 Map，只有模拟现实世界的实体对象时，才使用 Object。如果只是需要key: value的数据结构，使用 Map 结构。因为 Map 有内建的遍历机制。12345678910111213let map = new Map(arr);for (let key of map.keys()) &#123; console.log(key);&#125;for (let value of map.values()) &#123; console.log(value);&#125;for (let item of map.entries()) &#123; console.log(item[0], item[1]);&#125; 8、Class总是用 Class，取代需要 prototype 的操作。因为 Class 的写法更简洁，更易于理解。123456789101112131415161718192021// badfunction Queue(contents = []) &#123; this._queue = [...contents];&#125;Queue.prototype.pop = function() &#123; const value = this._queue[0]; this._queue.splice(0, 1); return value;&#125;// goodclass Queue &#123; constructor(contents = []) &#123; this._queue = [...contents]; &#125; pop() &#123; const value = this._queue[0]; this._queue.splice(0, 1); return value; &#125;&#125; 使用extends实现继承，因为这样更简单，不会有破坏instanceof运算的危险。12345678910111213141516// badconst inherits = require(&apos;inherits&apos;);function PeekableQueue(contents) &#123; Queue.apply(this, contents);&#125;inherits(PeekableQueue, Queue);PeekableQueue.prototype.peek = function() &#123; return this._queue[0];&#125;// goodclass PeekableQueue extends Queue &#123; peek() &#123; return this._queue[0]; &#125;&#125; 9、模块首先，Module 语法是 JavaScript 模块的标准写法，坚持使用这种写法。使用import取代require。1234567// badconst moduleA = require(&apos;moduleA&apos;);const func1 = moduleA.func1;const func2 = moduleA.func2;// goodimport &#123; func1, func2 &#125; from &apos;moduleA&apos;; 使用export取代module.exports。123456789101112131415161718192021// commonJS的写法var React = require(&apos;react&apos;);var Breadcrumbs = React.createClass(&#123; render() &#123; return &lt;nav /&gt;; &#125;&#125;);module.exports = Breadcrumbs;// ES6的写法import React from &apos;react&apos;;class Breadcrumbs extends React.Component &#123; render() &#123; return &lt;nav /&gt;; &#125;&#125;;export default Breadcrumbs; 如果模块只有一个输出值，就使用export default，如果模块有多个输出值，就不使用export default，export default与普通的export不要同时使用。 不要在模块输入中使用通配符。因为这样可以确保你的模块之中，有一个默认输出（export default）。12345// badimport * as myObject from &apos;./importModule&apos;;// goodimport myObject from &apos;./importModule&apos;; 如果模块默认输出一个函数，函数名的首字母应该小写。(小驼峰写法)1234function makeStyleGuide() &#123;&#125;export default makeStyleGuide; 如果模块默认输出一个对象，对象名的首字母应该大写。123456const StyleGuide = &#123; es6: &#123; &#125;&#125;;export default StyleGuide; 10、ESLint的使用在项目的根目录下新建一个.eslintrc文件，配置 ESLint123&#123; &quot;extends&quot;: &quot;eslint-config-airbnb&quot;&#125; 使用 ESLint 检查文件，查看报错。$ eslint index.js 2、Module的加载实现1、加载规则对于外部的模块脚本，有几点需要注意。代码是在模块作用域之中运行，而不是在全局作用域运行。模块内部的顶层变量，外部不可见。 模块脚本自动采用严格模式，不管有没有声明use strict。模块之中，可以使用import命令加载其他模块（.js后缀不可省略，需要提供绝对 URL 或相对 URL），也可以使用export命令输出对外接口。 模块之中，顶层的this关键字返回undefined，而不是指向window。也就是说，在模块顶层使用this关键字，是无意义的。*同一个模块如果加载多次，将只执行一次。 利用顶层的this等于undefined这个语法点，可以侦测当前代码是否在 ES6 模块之中。1const isNotModuleScript = this !== undefined; 2、ES6模块与CommonJS模块的差异ES6 模块与 CommonJS 模块完全不同，它们有两个重大差异:CommonJS 模块输出的是一个值的拷贝，ES6 模块输出的是值的引用。CommonJS 模块是运行时加载，ES6 模块是编译时输出接口。 第二个差异是因为 CommonJS 加载的是一个对象（即module.exports属性），该对象只有在脚本运行完才会生成。而 ES6 模块不是对象，它的对外接口只是一种静态定义，在代码静态解析阶段就会生成。]]></content>
      <categories>
        <category>前端</category>
        <category>es6</category>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>es6</tag>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[brew]]></title>
    <url>%2F2019%2F05%2F14%2Fbrew%2F</url>
    <content type="text"><![CDATA[官网]]></content>
      <categories>
        <category>brew</category>
      </categories>
      <tags>
        <tag>brew</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[常用命令]]></title>
    <url>%2F2019%2F05%2F13%2Fcommands%2F</url>
    <content type="text"><![CDATA[// 查看80端口是否被占用sudo lsof -i :80 // 直接结束占用端口的所有进程kill ${pid} TODO … ｄ(･∀･*)♪ﾟ]]></content>
      <categories>
        <category>计算机</category>
        <category>命令</category>
      </categories>
      <tags>
        <tag>计算机</tag>
        <tag>命令</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[axios]]></title>
    <url>%2F2019%2F05%2F13%2Faxios%2F</url>
    <content type="text"><![CDATA[前言在开发过程中，前端需要mock数据，以便和服务器端同时开发，互不耽误，在本地用mock数据，测试环境用接口。以前在开发过程中，我都是会在打包之前把引入的mock数据注释掉，每次都要更改代码，很可能会”手滑”，那有什么好的解决方案呢？ 为了满足需求，特意看了下axios中文说明文档，生态系统中有一个用来mock第三方库：moxios(就是这么好解决，多百度准没错 youxiu👍) #moxios使用方法 安装moxios包：npm install moxios --save-dev TODO … ｄ(･∀･*)♪ﾟ]]></content>
      <categories>
        <category>前端</category>
        <category>axios</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>axios</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[正则表达式[learn]]]></title>
    <url>%2F2019%2F05%2F13%2Freg%2F</url>
    <content type="text"></content>
      <categories>
        <category>前端</category>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[util]]></title>
    <url>%2F2019%2F05%2F10%2Fjs_util%2F</url>
    <content type="text"><![CDATA[javascript常用工具库1.Browser 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178function getBrowserInfo() &#123; var is360 = false; var isIE = false; var isFirefox = false; var isChrome = false; var isSafari = false; var isEdge = false; var broinfo = &#123; broName:&apos;&apos;, browserVersion:&apos;&apos;, &#125; var str = &apos;&apos;; var strStart = 0; var strStop = 0; var arr = new Array(); var temp = &apos;&apos;; var userAgent = window.navigator.userAgent.toLowerCase(); //包含以下属性中所有或一部分的字符串：appCodeName,appName,appVersion,language,platform // 浏览器类型-IE let ieversion = getIEVersion(); if(ieversion!=-1 &amp;&amp; ieversion!=&apos;edge&apos;) &#123; isIE = true; broinfo.broName = &apos;IE&apos; + ieversion; broinfo.browserVersion = ieversion; return broinfo; &#125; //Edge if(userAgent.indexOf(&apos;edge&apos;) != -1) &#123; isEdge = true; broinfo.broName = &apos;Edge&apos; broinfo.browserVersion = userAgent.match(/edge\/([\d.]+)/)[1]; return broinfo; &#125; // 2345Explorer if (userAgent.indexOf(&quot;2345explorer&quot;) &gt; 0) &#123; broinfo.broName = &apos;2345浏览器&apos; broinfo.browserVersion = userAgent.match(/2345explorer\/([\d.]+)/)[1]; return broinfo; &#125; // 欧朋 if (window.opera || (userAgent.indexOf(&quot;opr&quot;) &gt; 0)) &#123; broinfo.broName = &apos;Opera&apos; broinfo.browserVersion = this.getOperaVersion(userAgent) return broinfo; &#125; // UC if (userAgent.indexOf(&quot;ubrowser&quot;) &gt; 0) &#123; broinfo.broName = &apos;UC&apos; broinfo.browserVersion = userAgent.match(/ubrowser\/([\d.]+)/)[1]; return broinfo; &#125; // 百度 if (userAgent.indexOf(&quot;bidubrowser&quot;) &gt; 0) &#123; broinfo.broName = &apos;百度&apos; broinfo.browserVersion = userAgent.match(/bidubrowser\/([\d.]+)/)[1]; return broinfo; &#125; // 搜狗 if (userAgent.indexOf(&quot;metasr&quot;) &gt; 0 || userAgent.indexOf( &quot;se 2.x&quot; ) &gt; 0 ) &#123; broinfo.broName = &apos;搜狗&apos; broinfo.browserVersion = &apos;&apos;; return broinfo; &#125; // QQ if (userAgent.indexOf(&quot;tencenttraveler&quot;) &gt; 0) &#123; broinfo.broName = &apos;QQ&apos; broinfo.browserVersion = userAgent.match(/tencenttraveler\/([\d.]+)/)[1]; return broinfo; &#125; // QQ if (userAgent.indexOf(&quot;qqbrowser&quot;) &gt; 0) &#123; broinfo.broName = &apos;QQ&apos; broinfo.browserVersion = userAgent.match(/qqbrowser\/([\d.]+)/)[1]; return broinfo; &#125; // 遨游 if (userAgent.indexOf(&quot;maxthon&quot;) &gt; 0) &#123; broinfo.broName = &apos;遨游&apos; broinfo.browserVersion = userAgent.match(/maxthon\/([\d.]+)/)[1]; return broinfo; &#125; // 火狐 if (userAgent.indexOf(&quot;firefox&quot;) &gt; 0) &#123; broinfo.broName = &apos;firefox&apos;; broinfo.browserVersion = userAgent.match(/firefox\/([\d.]+)/)[1]; return broinfo; &#125; if (userAgent.indexOf(&quot;chrome&quot;) &gt; 0) &#123; if (validate360(&apos;type&apos;, &apos;application/x360mmplugin&apos;)) &#123; broinfo.broName = &apos;360&apos; broinfo.browserVersion = userAgent.match(/chrome\/([\d.]+)/)[1]; &#125; else if(_mime(&quot;type&quot;, &quot;application/vnd.chromium.remoting-viewer&quot;))&#123; broinfo.broName = &apos;360&apos; broinfo.browserVersion = userAgent.match(/chrome\/([\d.]+)/)[1]; &#125; else &#123; broinfo.broName = &apos;chrome&apos; broinfo.browserVersion = userAgent.match(/chrome\/([\d.]+)/)[1]; &#125; &#125; else if (userAgent.indexOf(&quot;safari&quot;) &gt; -1) &#123; // 苹果 broinfo.broName = &apos;safari&apos;; broinfo.browserVersion = userAgent.match(/version\/([\d.]+)/)[1]; &#125; if(!broinfo.broName)&#123; broinfo.broName = &apos;其他&apos;; broinfo.browserVersion = &apos;&apos;; &#125; return broinfo;&#125;/* * 判断是否为360浏览器 */ function _mime(option, value) &#123; var mimeTypes = navigator.mimeTypes; for (var mt in mimeTypes) &#123; if (mimeTypes[mt][option] == value) &#123; return true; &#125; &#125; return false;&#125;function validate360(option, value) &#123; let mimeTypes = window.navigator.mimeTypes for (let mt in mimeTypes) &#123; if (mimeTypes[mt][option] == value) &#123; return true; &#125; &#125; return false;&#125;/* * 获取oper浏览器版本 */ function getOperaVersion(userAgent) &#123; try &#123; if (window.opera) &#123; return userAgent.match(/opera.([\d.]+)/)[1]; &#125; else if (userAgent.indexOf(&quot;opr&quot;) &gt; 0) &#123; return userAgent.match(/opr\/([\d.]+)/)[1]; &#125; &#125; catch (e) &#123; return 0; &#125;&#125;/* * 获取IE浏览器版本 */function getIEVersion() &#123; var userAgent = navigator.userAgent; //取得浏览器的userAgent字符串 var isIE = userAgent.indexOf(&quot;compatible&quot;) &gt; -1 &amp;&amp; userAgent.indexOf(&quot;MSIE&quot;) &gt; -1; //判断是否IE&lt;11浏览器 var isEdge = userAgent.indexOf(&quot;Edge&quot;) &gt; -1 &amp;&amp; !isIE; //判断是否IE的Edge浏览器 var isIE11 = userAgent.indexOf(&apos;Trident&apos;) &gt; -1 &amp;&amp; userAgent.indexOf(&quot;rv:11.0&quot;) &gt; -1; if(isIE) &#123; var reIE = new RegExp(&quot;MSIE (\\d+\\.\\d+);&quot;); reIE.test(userAgent); var fIEVersion = parseFloat(RegExp[&quot;$1&quot;]); if(fIEVersion == 7) &#123; return 7; &#125; else if(fIEVersion == 8) &#123; return 8; &#125; else if(fIEVersion == 9) &#123; return 9; &#125; else if(fIEVersion == 10) &#123; return 10; &#125; else &#123; return 6; //IE版本&lt;=7 &#125; &#125; else if(isEdge) &#123; return &apos;edge&apos;; //edge &#125; else if(isIE11) &#123; return 11; //IE11 &#125; else &#123; return -1; //不是ie浏览器 &#125;&#125; 2.setCookie 12345export function setCookie(name, value, hour=24) &#123; var exp = new Date(); exp.setTime(exp.getTime() + hour*3600000); document.cookie = name + &quot;=&quot; + escape(value) + &quot;;expires=&quot; + exp.toGMTString()+&quot;;domain=&apos;.weibo.com&apos;&quot;;&#125; 3.getCookie 1234567891011121314export function getCookie(objname) &#123; //获取指定名称的cookie的值 var v = &quot;&quot;; var arrstr = document.cookie.split(&quot;; &quot;); for(var i = 0; i &lt; arrstr.length; i++) &#123; var temp = arrstr[i].split(&quot;=&quot;); if(temp[0] == objname) &#123; var v1 = unescape(temp[1]); if(v == &quot;&quot; || v1.length &lt; v.length) &#123; v = v1; &#125; &#125; &#125; return v;&#125; 4.clearCookie 123export function clearCookie() &#123; document.cookie = &apos;&apos;;&#125;; 5.safeGet 12345export function safeGet(o, path) &#123; return path.split(&apos;.&apos;).reduce((o = &#123;&#125;, b) =&gt; &#123; //用到参数默认值 return o[b] &#125;, o)&#125;; 6.getFileExt 1234567export function getFileExt(filename) &#123; var pos = filename.lastIndexOf(&apos;.&apos;); if(pos &gt; 0) &#123; return filename.substring(pos + 1).toLowerCase(); &#125; return &apos;&apos;;&#125;; 7.解析url参数 12345678910111213141516171819202122export function parseParam(url) &#123; let paramsStr = /.+\?(.+)$/.exec(url); // 将 ? 后面的字符串取出来 if(!paramsStr) return; paramsStr = paramsStr[1]; const paramsArr = paramsStr.split(&apos;&amp;&apos;); // 将字符串以 &amp; 分割后存到数组中 let paramsObj = &#123;&#125;; // 将 params 存到对象中 paramsArr.forEach(param =&gt; &#123; if(/=/.test(param)) &#123; // 处理有 value 的参数 let [key, val] = param.split(&apos;=&apos;); // 分割 key 和 value val = decodeURIComponent(val); // 解码 val = /^\d+$/.test(val) ? parseFloat(val) : val; // 判断是否转为数字 if(paramsObj.hasOwnProperty(key)) &#123; // 如果对象有 key，则添加一个值 paramsObj[key] = [].concat(paramsObj[key], val); &#125; else &#123; // 如果对象没有这个 key，创建 key 并设置值 paramsObj[key] = val; &#125; &#125; else &#123; // 处理没有 value 的参数 paramsObj[param] = null; &#125; &#125;) return paramsObj;&#125; 8.parseURL 12345678910function parseURL(url)&#123; var parse_url = /^(?:([A-Za-z]+):(/&#123;0,3&#125;))?([0-9.-A-Za-z]+.[0-9A-Za-z]+)?(?::(d+))?(?:/([^?#]*))?(?:?([^#]*))?(?:#(.*))?$/; var names = [&apos;url&apos;, &apos;scheme&apos;, &apos;slash&apos;, &apos;host&apos;, &apos;port&apos;, &apos;path&apos;, &apos;query&apos;, &apos;hash&apos;]; var results = parse_url.exec(url); var that = &#123;&#125;; for (var i = 0, len = names.length; i &lt; len; i += 1) &#123; that[names[i]] = results[i] || &apos;&apos;; &#125; return that;&#125; 9.产生随机字符串 123456789function randomChar(l = 13) &#123; var x = &quot;0123456789qwertyuioplkjhgfdsazxcvbnm&quot;; var tmp = &quot;&quot;; var timestamp = new Date().getTime(); for(var i = 0; i &lt; l; i++) &#123; tmp += x.charAt(Math.ceil(Math.random() * 100000000) % x.length); &#125; return timestamp + tmp;&#125; 10.addClass 123456export function addClass(obj,cls) &#123; var obj_class=obj.className,//获取class的内容； blank = ( obj_class != &apos;&apos; ) ? &apos; &apos; : &apos;&apos;;//判断获取的class是否为空，如果不为空，则添加空格； var added = obj_class + blank + cls;//组合原来的class和需要添加的class，中间加上空格； obj.className = added;//替换原来的class；&#125; 11.removeClass 1234567export function removeClass(obj,cls)&#123; var obj_class = &apos; &apos; + obj.className + &apos; &apos;;//获取class的内容，并在首尾各加一个空格；&apos;abc bcd&apos; -&gt; &apos; abc bcd &apos; obj_class = obj_class.replace(/(\s+)/gi,&apos; &apos;);//将多余的空字符替换成一个空格；&apos; abc bcd &apos; -&gt; &apos; abc bcd &apos; var removed = obj_class.replace(&apos; &apos;+cls+&apos; &apos;,&apos; &apos;);//在原来的class，替换掉首尾加了空格的class &apos; abc bcd &apos; -&gt; &apos;bcd &apos; removed = removed.replace(/(^\s+)|(\s+$)/g,&apos;&apos;);//去掉首尾空格；&apos;bcd &apos; -&gt; &apos;bcd&apos; obj.className = removed;//替换原来的class；&#125; 12.hasClass 123456789101112export function hasClass(obj,cls)&#123; var obj_class = obj.className,//获取class的内容； obj_class_lst = obj_class.split(/\s+/);//通过split空字符将cls转换成数组 console.log(obj_class_lst); var x = 0; for(x in obj_class_lst)&#123; if ( obj_class_lst[x] == cls ) &#123; return true; &#125; &#125; return false;&#125; 13.判断当时用户使用OS版本 1234567891011121314151617181920212223function detectOS() &#123; var sUserAgent = navigator.userAgent; var isWin = (navigator.platform == &quot;Win32&quot;) || (navigator.platform == &quot;Windows&quot;); var isMac = (navigator.platform == &quot;Mac68K&quot;) || (navigator.platform == &quot;MacPPC&quot;) || (navigator.platform == &quot;Macintosh&quot;) || (navigator.platform == &quot;MacIntel&quot;); if(isMac) return &quot;Mac&quot;; var isUnix = (navigator.platform == &quot;X11&quot;) &amp;&amp; !isWin &amp;&amp; !isMac; if(isUnix) return &quot;Unix&quot;; var isLinux = (String(navigator.platform).indexOf(&quot;Linux&quot;) &gt; -1); if(isLinux) return &quot;Linux&quot;; if(isWin) &#123; var isWin2K = sUserAgent.indexOf(&quot;Windows NT 5.0&quot;) &gt; -1 || sUserAgent.indexOf(&quot;Windows 2000&quot;) &gt; -1; if(isWin2K) return &quot;Win2000&quot;; var isWinXP = sUserAgent.indexOf(&quot;Windows NT 5.1&quot;) &gt; -1 || sUserAgent.indexOf(&quot;Windows XP&quot;) &gt; -1; if(isWinXP) return &quot;WinXP&quot;; var isWin2003 = sUserAgent.indexOf(&quot;Windows NT 5.2&quot;) &gt; -1 || sUserAgent.indexOf(&quot;Windows 2003&quot;) &gt; -1; if(isWin2003) return &quot;Win2003&quot;; var isWinVista = sUserAgent.indexOf(&quot;Windows NT 6.0&quot;) &gt; -1 || sUserAgent.indexOf(&quot;Windows Vista&quot;) &gt; -1; if(isWinVista) return &quot;WinVista&quot;; var isWin7 = sUserAgent.indexOf(&quot;Windows NT 6.1&quot;) &gt; -1 || sUserAgent.indexOf(&quot;Windows 7&quot;) &gt; -1; if(isWin7) return &quot;Win7&quot;; &#125; return &quot;other&quot;;&#125; 14.decodeHTML 123456789101112function decodeHTML(str)&#123; if(typeof str !== &apos;string&apos;)&#123; throw &apos;decodeHTML need a string as parameter&apos;; &#125; return str.replace(/&quot;/g,&apos;&quot;&apos;). replace(/&lt;/g,&apos;&lt;&apos;). replace(/&gt;/g,&apos;&gt;&apos;). replace(/&apos;/g,&apos;&apos;&apos;). replace(/ /g,&apos;u00A0&apos;). replace(/ /g,&apos;u0020&apos;). replace(/&amp;/g,&apos;&amp;&apos;);&#125; 15.encodeHTML 1234567891011function encodeHTML(str)&#123; if(typeof str !== &apos;string&apos;)&#123; throw &apos;encodeHTML need a string as parameter&apos;; &#125; return str.replace(/&amp;/g,&apos;&amp;&apos;). replace(/&quot;/g,&apos;&quot;&apos;). replace(//g,&apos;&gt;&apos;). replace(/&apos;/g,&apos;&apos;&apos;). replace(/u00A0/g,&apos; &apos;). replace(/(u0020|u000B|u2028|u2029|f)/g,&apos; &apos;);&#125; 16.从左到右取字符串，中文算两个字符 12345678function leftB(str, lens)&#123; var s = str.replace(/*/g, &apos; &apos;).replace(/[^x00-xff]/g, &apos;**&apos;); str = str.slice(0, s.slice(0, lens).replace(/**/g, &apos; &apos;).replace(/*/g, &apos;&apos;).length); if ($.core.str.bLength(str) &gt; lens &amp;&amp; lens &gt; 0) &#123; str = str.slice(0, str.length - 1); &#125; return str;&#125; 17.全角字转半角字 12345function dbcToSbc(str)&#123; return str.replace(/[uff01-uff5e]/g,function(a)&#123; return String.fromCharCode(a.charCodeAt(0)-65248); &#125;).replace(/u3000/g,&quot; &quot;);&#125; 18.当前用户使用设备ios 12345678var Global = &#123; //用户当前使用设备 // iPhone X、iPhone XS isIPhoneX: /iphone/gi.test(window.navigator.userAgent) &amp;&amp; window.devicePixelRatio &amp;&amp; window.devicePixelRatio === 3 &amp;&amp;window.screen.width === 375 &amp;&amp; window.screen.height === 812, // iPhone XS Max isIPhoneXSMax: /iphone/gi.test(window.navigator.userAgent) &amp;&amp; window.devicePixelRatio &amp;&amp; window.devicePixelRatio ===3 &amp;&amp; window.screen.width === 414 &amp;&amp; window.screen.height === 896, // iPhone XR isIPhoneXR: /iphone/gi.test(window.navigator.userAgent) &amp;&amp; window.devicePixelRatio &amp;&amp; window.devicePixelRatio === 2 &amp;&amp;window.screen.width === 414 &amp;&amp; window.screen.height === 896, &#125;; 19.ua 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214/* eslint no-restricted-syntax: 0*//* eslint max-len: 0 *//* eslint one-var: 0*/module.exports = (function () &#123; const detecter = &#123;&#125;; const u = window.navigator.userAgent; const match = &#123; /* 内核(EdgeHTML,Trident,Presto,WebKit/Blink,Gecko)*/ /* eslint quote-props: 0*/ &apos;Trident&apos;: u.indexOf(&apos;Trident&apos;) &gt; -1 || u.indexOf(&apos;NET CLR&apos;) &gt; -1, &apos;Presto&apos;: u.indexOf(&apos;Presto&apos;) &gt; -1, &apos;WebKit&apos;: u.indexOf(&apos;AppleWebKit&apos;) &gt; -1, &apos;Gecko&apos;: u.indexOf(&apos;Gecko/&apos;) &gt; -1, /* 浏览器: (Safari,chrome,ie,edge,firefox,opera,kindle,360,uc,qq,baidu,maxthone,sogo,lbbrowser,xiaomi) wv: (微博,微信,支付宝,淘宝)*/ &apos;Safari&apos;: u.match(/version\/([\w\.]+).+?mobile\/\w+\s(safari)/i) || u.match(/version\/([\w\.]+).+?(mobile\s?safari|safari)/i), &apos;Chrome&apos;: u.indexOf(&apos;Chrome&apos;) &gt; -1 || u.match(/((?:android.+)crmo|crios)\/([\w\.]+)/i), &apos;IE&apos;: u.match(/(?:ms|\()(ie)\s([\w\.]+)/i) || u.match(/(trident).+rv[:\s]([\w\.]+).+like\sgecko/i), &apos;Edge&apos;: u.match(/(edge)\/((\d+)?[\w\.]+)/i), &apos;Firefox&apos;: u.indexOf(&apos;Firefox&apos;) &gt; -1 || u.match(/fxios\/([\w\.-]+)/i), &apos;Firefox Focus&apos;: u.indexOf(&apos;Focus&apos;) &gt; -1, &apos;Chromium&apos;: u.indexOf(&apos;Chromium&apos;) &gt; -1, &apos;Opera&apos;: u.indexOf(&apos;Opera&apos;) &gt; -1 || u.match(/\s(opr)\/([\w\.]+)/i), &apos;Vivaldi&apos;: u.indexOf(&apos;Vivaldi&apos;) &gt; -1, &apos;Yandex&apos;: u.match(/(yabrowser)\/([\w\.]+)/i), &apos;Kindle&apos;: u.match(/(kindle)\/([\w\.]+)/i), &apos;360&apos;: u.indexOf(&apos;360EE&apos;) &gt; -1 || u.indexOf(&apos;360SE&apos;) &gt; -1, &apos;UC&apos;: u.match(/(uc\s?browser)[\/\s]?([\w\.]+)/i) || u.match(/ucweb.+(ucbrowser)[\/\s]?([\w\.]+)/i) || u.match(/(ucbrowser)\/([\w\.]+)/i) || u.match(/juc.+(ucweb)[\/\s]?([\w\.]+)/i), &apos;QQBrowser&apos;: u.match(/m?(qqbrowser)[\/\s]?([\w\.]+)/i), &apos;Baidu&apos;: u.indexOf(&apos;Baidu&apos;) &gt; -1 || u.indexOf(&apos;BIDUBrowser&apos;) &gt; -1, /* 遨游*/ &apos;Maxthon&apos;: u.indexOf(&apos;Maxthon&apos;) &gt; -1, &apos;Sogou&apos;: u.indexOf(&apos;MetaSr&apos;) &gt; -1 || u.indexOf(&apos;Sogou&apos;) &gt; -1, /* 猎豹*/ &apos;LBBROWSER&apos;: u.indexOf(&apos;LBBROWSER&apos;) &gt; -1, &apos;XiaoMi&apos;: u.match(/xiaomi\/miuibrowser\/([\w\.]+)/i), /* webview*/ &apos;Wechat&apos;: u.match(/(micromessenger)\/([\w\.]+)/i), &apos;Taobao&apos;: u.indexOf(&apos;AliApp(TB&apos;) &gt; -1, &apos;Alipay&apos;: u.indexOf(&apos;AliApp(AP&apos;) &gt; -1, &apos;Weibo&apos;: u.match(/Weibo\s*\((.*?)\)/i), &apos;QQ&apos;: u.indexOf(&apos;QQ/&apos;) &gt; -1, /* 系统或平台*/ &apos;Windows&apos;: u.match(/microsoft\s(windows)\s(vista|xp)/i) || u.match(/(windows)\snt\s6\.2;\s(arm)/i), &apos;Mac OS&apos;: u.match(/(mac\sos\sx)\s?([\w\s\.]+\w)*/i) || u.match(/(macintosh|mac(?=_powerpc)\s)/i), &apos;Android&apos;: u.indexOf(&apos;Android&apos;) &gt; -1, &apos;Windows Phone&apos;: u.indexOf(&apos;IEMobile&apos;) &gt; -1, /* &apos;Windows Phone&apos;: u.match(/(windows\sphone(?:\sos)*)[\s\/]?([\d\.\s]+\w)*!/i) || ua.match(/(windows\smobile|windows)[\s\/]?([ntce\d\.\s]+\w)/i) || u.match(/(win(?=3|9|n)|win\s9x\s)([nt\d\.]+)/i),*/ &apos;iOS&apos;: u.match(/(ip[honead]+)(?:.*os\s([\w]+)*\slike\smac|;\sopera)/i), /* 设备 电脑(PC),平板或PDA(Tablet),手机(Mobile)*/ &apos;Mobile&apos;: u.indexOf(&apos;Mobile&apos;) &gt; -1 || u.indexOf(&apos;iPhone&apos;) &gt; -1 || u.indexOf(&apos;480&apos;) &gt; -1, &apos;Tablet&apos;: u.indexOf(&apos;Tablet&apos;) &gt; -1 || u.indexOf(&apos;Pad&apos;) &gt; -1 || u.indexOf(&apos;Nexus 7&apos;) &gt; -1 &#125;; /* 基本信息*/ const hash = &#123; engine: [&apos;WebKit&apos;, &apos;Trident&apos;, &apos;Gecko&apos;, &apos;Presto&apos;], browser: [&apos;Chrome&apos;, &apos;Safari&apos;, &apos;Edge&apos;, &apos;IE&apos;, &apos;Firefox&apos;, &apos;Firefox Focus&apos;, &apos;Chromium&apos;, &apos;Opera&apos;, &apos;Vivaldi&apos;, &apos;Yandex&apos;, &apos;Kindle&apos;, &apos;360&apos;, &apos;UC&apos;, &apos;QQBrowser&apos;, &apos;QQ&apos;, &apos;Baidu&apos;, &apos;Maxthon&apos;, &apos;Sogou&apos;, &apos;LBBROWSER&apos;, &apos;XiaoMi&apos;, &apos;Wechat&apos;, &apos;Taobao&apos;, &apos;Alipay&apos;, &apos;Weibo&apos;], os: [&apos;Windows&apos;, &apos;Mac OS&apos;, &apos;Android&apos;, &apos;iOS&apos;, &apos;Windows Phone&apos;], device: [&apos;Mobile&apos;, &apos;Tablet&apos;] &#125;; detecter.device = &apos;PC&apos;; /* eslint guard-for-in: 0 */ for (const s in hash) &#123; for (let i = 0; i &lt; hash[s].length; i += 1) &#123; const value = hash[s][i]; if (value &amp;&amp; match[value]) &#123; detecter[s] = value; &#125; &#125; &#125; /* 系统版本信息*/ const osVersion = &#123; &apos;Windows&apos;: function () &#123; const v = u.replace(/^.*Windows NT ([\d.]+);.*$/, &apos;$1&apos;); const hashV = &#123; &apos;6.4&apos;: &apos;10&apos;, &apos;6.3&apos;: &apos;8.1&apos;, &apos;6.2&apos;: &apos;8&apos;, &apos;6.1&apos;: &apos;7&apos;, &apos;6.0&apos;: &apos;Vista&apos;, &apos;5.2&apos;: &apos;XP&apos;, &apos;5.1&apos;: &apos;XP&apos;, &apos;5.0&apos;: &apos;2000&apos; &#125;; return hashV[v] || v; &#125;, &apos;Mac OS&apos;: function () &#123; return u.replace(/^.*Mac OS X ([\d_]+).*$/, &apos;$1&apos;).replace(/_/g, &apos;.&apos;); &#125;, &apos;Android&apos;: function () &#123; return u.replace(/^.*Android ([\d.]+);.*$/, &apos;$1&apos;); &#125;, &apos;iOS&apos;: function () &#123; return u.replace(/^.*OS ([\d_]+) like.*$/, &apos;$1&apos;).replace(/_/g, &apos;.&apos;); &#125;, &apos;Windows Phone&apos;: function () &#123; return u.replace(/^.*Windows Phone( OS)? ([\d.]+);.*$/, &apos;$2&apos;); &#125; &#125;; detecter.osVersion = &apos;&apos;; if (osVersion[detecter.os]) &#123; detecter.osVersion = osVersion[detecter.os](); if (detecter.osVersion === u) &#123; detecter.osVersion = &apos;&apos;; &#125; &#125; /* 浏览器版本信息 */ const version = &#123; &apos;Safari&apos;: function () &#123; return u.replace(/^.*Version\/([\d.]+).*$/, &apos;$1&apos;); &#125;, &apos;Chrome&apos;: function () &#123; return u.replace(/^.*Chrome\/([\d.]+).*$/, &apos;$1&apos;).replace(/^.*CriOS\/([\d.]+).*$/, &apos;$1&apos;); &#125;, &apos;IE&apos;: function () &#123; return u.replace(/^.*MSIE ([\d.]+).*$/, &apos;$1&apos;).replace(/^.*rv:([\d.]+).*$/, &apos;$1&apos;); &#125;, &apos;Edge&apos;: function () &#123; return u.replace(/^.*Edge\/([\d.]+).*$/, &apos;$1&apos;); &#125;, &apos;Firefox&apos;: function () &#123; return u.replace(/^.*Firefox\/([\d.]+).*$/, &apos;$1&apos;).replace(/^.*FxiOS\/([\d.]+).*$/, &apos;$1&apos;); &#125;, &apos;Firefox Focus&apos;: function () &#123; return u.replace(/^.*Focus\/([\d.]+).*$/, &apos;$1&apos;); &#125;, &apos;Chromium&apos;: function () &#123; return u.replace(/^.*Chromium\/([\d.]+).*$/, &apos;$1&apos;); &#125;, &apos;Opera&apos;: function () &#123; return u.replace(/^.*Opera\/([\d.]+).*$/, &apos;$1&apos;).replace(/^.*OPR\/([\d.]+).*$/, &apos;$1&apos;); &#125;, &apos;Vivaldi&apos;: function () &#123; return u.replace(/^.*Vivaldi\/([\d.]+).*$/, &apos;$1&apos;); &#125;, &apos;Yandex&apos;: function () &#123; return u.replace(/^.*YaBrowser\/([\d.]+).*$/, &apos;$1&apos;); &#125;, &apos;Kindle&apos;: function () &#123; return u.replace(/^.*Version\/([\d.]+).*$/, &apos;$1&apos;); &#125;, &apos;Maxthon&apos;: function () &#123; return u.replace(/^.*Maxthon\/([\d.]+).*$/, &apos;$1&apos;); &#125;, &apos;QQBrowser&apos;: function () &#123; return u.replace(/^.*QQBrowser\/([\d.]+).*$/, &apos;$1&apos;); &#125;, /* eslint no-useless-escape: 0*/ &apos;Baidu&apos;: function () &#123; return u.replace(/^.*BIDUBrowser[\s\/]([\d.]+).*$/, &apos;$1&apos;); &#125;, &apos;UC&apos;: function () &#123; return u.replace(/^.*UC?Browser\/([\d.]+).*$/, &apos;$1&apos;).replace(/juc.+(ucweb)[\/\s]?([\w\.]+)/i, &apos;$1&apos;); &#125;, &apos;Sogou&apos;: function () &#123; return u.replace(/^.*SE ([\d.X]+).*$/, &apos;$1&apos;).replace(/^.*SogouMobileBrowser\/([\d.]+).*$/, &apos;$1&apos;); &#125;, &apos;XiaoMi&apos;: function () &#123; return u.replace(/^.*MiuiBrowser\/([\d.]+).*$/, &apos;$1&apos;); &#125;, &apos;Wechat&apos;: function () &#123; return u.replace(/^.*MicroMessenger\/([\d.]+).*$/, &apos;$1&apos;); &#125;, &apos;Taobao&apos;: function () &#123; return u.replace(/^.*AliApp\(TB\/([\d.]+).*$/, &apos;$1&apos;); &#125;, &apos;Alipay&apos;: function () &#123; return u.replace(/^.*AliApp\(AP\/([\d.]+).*$/, &apos;$1&apos;); &#125;, /* &quot;Mozilla/5.0 (iPhone; CPU iPhone OS 10_3_2 like Mac OS X) AppleWebKit/603.2.4 (KHTML, like Gecko) Mobile/14F89 Weibo (iPhone9,2__weibo__7.6.0__iphone__os10.3.2)&quot; */ &apos;Weibo&apos;: function () &#123; const arr = u.match(/__weibo__(\d+?.\d+?.\d+)(_*\w*)*__(.+)?__/); if (!arr || !arr.length || arr.length &lt; 2) &#123; return &apos;&apos;; &#125; return arr[1]; &#125;, &apos;QQ&apos;: function () &#123; return u.replace(/^.*QQ\/([\d.]+).*$/, &apos;$1&apos;); &#125;, &#125;; detecter.version = &apos;&apos;; if (version[detecter.browser]) &#123; detecter.version = version[detecter.browser](); if (detecter.version === u) &#123; detecter.version = &apos;&apos;; &#125; &#125; /* 修正*/ if (detecter.browser === &apos;Edge&apos;) &#123; detecter.engine = &apos;EdgeHTML&apos;; &#125; else if (detecter.browser === &apos;Chrome&apos; &amp;&amp; parseInt(detecter.version, 10) &gt; 27) &#123; detecter.engine = &apos;Blink&apos;; &#125; else if (detecter.browser === &apos;Opera&apos; &amp;&amp; parseInt(detecter.version, 10) &gt; 12) &#123; detecter.engine = &apos;Blink&apos;; &#125; else if (detecter.browser === &apos;Yandex&apos;) &#123; detecter.engine = &apos;Blink&apos;; &#125; detecter.versionCompare = function (a, b) &#123; const pa = a.indexOf(&apos;_&apos;) &gt; -1 ? a.split(&apos;_&apos;) : a.split(&apos;.&apos;); const pb = b.indexOf(&apos;_&apos;) &gt; -1 ? b.split(&apos;_&apos;) : b.split(&apos;.&apos;); const len = Math.max(pa.length, pb.length); for (let i = 0; i &lt; len; i += 1) &#123; const na = Number(pa[i]) || 0; const nb = Number(pb[i]) || 0; if (na &gt; nb) return 1; if (nb &gt; na) return -1; &#125; return 0; &#125;; return detecter;&#125;()); 20.解决ios12上软键盘顶起页面后隐藏不回弹的问题 1!function(e)&#123;var a,i=navigator.userAgent.toLowerCase(),n=document.documentElement,t=parseInt(n.clientWidth);if(/(iPhone|iPad|iPod|iOS)/i.test(navigator.userAgent)||i.indexOf(&quot;like mac os x&quot;)&gt;0)&#123;var s=/os [\d._]*/gi,o=i.match(s);a=(o+&quot;&quot;).replace(/[^0-9|_.]/gi,&quot;&quot;).replace(/_/gi,&quot;.&quot;)&#125;var r=a+&quot;&quot;;&quot;undefined&quot;!=r&amp;&amp;r.length&gt;0&amp;&amp;(a=parseInt(r),a&gt;=8&amp;&amp;(375==t||667==t||320==t||568==t||480==t)?n.className=&quot;iosx2&quot;:(a&gt;=8&amp;&amp;414==t||736==t)&amp;&amp;(n.className=&quot;iosx3&quot;)),/(Android)/i.test(navigator.userAgent)&amp;&amp;(n.className=&quot;android&quot;)&#125;(window);]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[html2canvas]]></title>
    <url>%2F2019%2F05%2F10%2Fhtml2canvas%2F</url>
    <content type="text"><![CDATA[TODO … ｄ(･∀･*)♪ﾟ]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode算法解析]]></title>
    <url>%2F2019%2F05%2F10%2Falgorithm_generation%2F</url>
    <content type="text"><![CDATA[1.两数之和 TODO … ｄ(･∀･*)♪ﾟ]]></content>
      <categories>
        <category>algorithm</category>
      </categories>
      <tags>
        <tag>algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[你不知道的javascript【learn】]]></title>
    <url>%2F2019%2F05%2F10%2Fjs_book_learn%2F</url>
    <content type="text"><![CDATA[TODO … ❣️]]></content>
      <categories>
        <category>javascript</category>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>javascript</tag>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[http权威指南 [学习笔记]]]></title>
    <url>%2F2019%2F05%2F10%2Fhttp_authority_guide%2F</url>
    <content type="text"><![CDATA[TODO … ❣️]]></content>
      <categories>
        <category>http</category>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>http</tag>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue-cli3都有些什么特异功能？]]></title>
    <url>%2F2019%2F05%2F07%2Fvue_cli_feature%2F</url>
    <content type="text"><![CDATA[为了快速开发，少走弯路，决定好好研读下vue-cli3官方文档 一、使用命令在vue cli中，会默认安装@vue/cli-service，@vue/cli-service中有vue-cli-service命令。项目中的package.json文件中的script表示可执行命令，可通过npm 或 yarn 调用这些script:package.json ↓ 123456&#123; &quot;scripts&quot;: &#123; &quot;serve&quot;: &quot;vue-cli-service serve&quot;, &quot;build&quot;: &quot;vue-cli-service build&quot; &#125;&#125; terminal ↓12npm run serveyarn serve serve 命令会启动一个开发服务器 (基于 webpack-dev-server) 并附带开箱即用的模块热重载 1.1 vue-cli-service serve命令1234567891011121314151617181920用法：vue-cli-service serve [options] [entry]options： --open 在服务器启动时打开浏览器 --copy 在服务器启动时将 URL 复制到剪切版 --mode 指定环境模式 (默认值：development) --host 指定 host (默认值：0.0.0.0) --port 指定 port (默认值：8080) --https 使用 https (默认值：false) entry: 唯一入口 ↓ 设置src/main.js文件为唯一入口 package.json &quot;scripts&quot;:&#123; &quot;dev&quot;: &quot;vue-cli-service serve --open --copy ./src/main.js&quot;, &#125; 除了通过命令行参数，还可使用 vue.config.js中的devServer字段配置开发服务器 1.2 vue-cli-service build命令1234567891011121314151617用法：vue-cli-service build [options] [entry|pattern]options： --mode 指定环境模式 (默认值：production) --dest 指定输出目录 (默认值：dist) --modern 面向现代浏览器带自动回退地构建应用 --target app | lib | wc | wc-async (默认值：app) --name 库或 Web Components 模式下的名字 (默认值：package.json 中的 &quot;name&quot; 字段或入口文件名) --no-clean 在构建项目之前不清除目标目录 --report 生成 report.html 以帮助分析包内容 --report-json 生成 report.json 以帮助分析包内容 --watch 监听文件变化 --report 和 --report-json 会根据构建统计生成报告，它会帮助你分析包中包含的模块们的大小。 --target 允许你将项目中的任何组件以一个库或 Web Components 组件的方式进行构建 --modern 使用现代模式构建应用，为现代浏览器交付原生支持的 ES2015 代码，并生成一个兼容老浏览器的包用来自动回退。 栗子 🌰 package.json ↓123 &quot;scripts&quot;:&#123;&quot;build&quot;: &quot;vue-cli-service build --dest output --report --report-json&quot;, &#125; 如图： 1.3 vue-cli-service inspect命令1234567用法：vue-cli-service inspect [options] [...paths]选项： --mode 指定环境模式 (默认值：development) 可使用 vue-cli-service inspect 来审查一个 Vue CLI 项目的 webpack config 二、配置参考2.1 全局配置 👏👏👏命令行中输入vue config可审查、修改全局的cli配置(我的.vuerc文件内容) ↓123456789101112131415161718192021 &#123; &quot;presets&quot;: &#123; &quot;base&quot;: &#123; &quot;useConfigFiles&quot;: false, &quot;plugins&quot;: &#123; &quot;@vue/cli-plugin-babel&quot;: &#123;&#125;, &quot;@vue/cli-plugin-eslint&quot;: &#123; &quot;config&quot;: &quot;standard&quot;, &quot;lintOn&quot;: [ &quot;save&quot; ] &#125; &#125;, &quot;router&quot;: true, &quot;routerHistoryMode&quot;: true, &quot;vuex&quot;: true, &quot;cssPreprocessor&quot;: &quot;less&quot; &#125; &#125;, &quot;useTaobaoRegistry&quot;: true&#125; 2.2 vue.config.js该文件是一个可选的配置文件，如果项目的根目录中存在这个文件，那么它会被@vue/cli-service自动加载 这个文件应该导出一个包含了选项的对象：123module.exports = &#123; //选项...&#125; publicPath [Type:string][Default:’/‘]publicPath是部署应用包时的基本URL，默认情况下，Vue cli会假设你的应用是被部署在一个域名的根路径上。例如https://www.my-app.com/如果应用被部署在一个子路径上，就需要用publicPath指定子路径。如果应用被部署在https://www.my-app.com/my-app/，则设置publicPath为/my-app/这个值在开发环境下同样生效。如果你想把开发服务器架设在根路径，你可以使用一个条件式的值：12345module.exports = &#123; publicPath: process.env.NODE_ENV === &apos;production&apos; ? &apos;/production-sub-path/&apos; : &apos;/&apos;&#125; 默认情况下，打包生成的dist目录下的html文件引用的js、css文件都为 “/“ =&gt; 根路径上如图： 更改publicPath路径后 vue.config.js ↓ 12345module.exports = &#123; publicPath: process.env.NODE_ENV === &apos;production&apos; ? &apos;/production-sub-path/&apos; : &apos;/&apos;&#125; 如图： outputDir [Type:string][Default:’dist’]运行 vue-cli-service build 时生成的生产环境构建文件的目录另:目标目录在构建之前会被清除 (构建时传入 –no-clean 可关闭该行为)。123module.exports = &#123; outputDir: &apos;dist_test --no-clean&apos;&#125; assetsDir [Type:string][Default:’’]放置生成的静态资源 (js、css、img、fonts) 的 (相对于 outputDir 的) 目录。 indexPath [Type:string][Default:’index.html’]指定生成的 index.html 的输出路径 (相对于 outputDir)。也可以是一个绝对路径。如图： filenameHashing [Type:Boolean][Default:true]默认情况下，生成的静态资源在它们的文件名中包含了 hash 以便更好的控制缓存如图： -&gt; pages [Type:object][Default:undefined]在multi-page模式下构建应用时，每个page都应该有一个对应的js入口文件。123456789101112131415161718192021222324用法：module.exports = &#123; pages: &#123; page1: &#123; // page 的入口 entry: &apos;src/page1/main.js&apos;, // 模板来源 template: &apos;src/page1/page1.html&apos;, // 在 dist/index.html 的输出 filename: &apos;page1.html&apos;, // 当使用 title 选项时， // template 中的 title 标签需要是 &lt;title&gt;&lt;%= htmlWebpackPlugin.options.title %&gt;&lt;/title&gt; title: &apos;页面title&apos;, // 在这个页面中包含的块，默认情况下会包含 // 提取出来的通用 chunk 和 vendor chunk。 chunks: [&apos;chunk-vendors&apos;, &apos;chunk-common&apos;, &apos;index&apos;] &#125;, // 当使用只有入口的字符串格式时， // 模板会被推导为 `public/page2.html` // 并且如果找不到的话，就回退到 `public/index.html`。 // 输出文件名会被推导为 `page2.html`。 page2: &apos;src/subpage/main.js&apos; &#125;&#125; package.json ↓123456789101112131415var pages = &#123; page1:&#123; entry:&apos;src/page/page1/main.js&apos;, template:&apos;src/page/page1/page1.html&apos;, filename:&apos;page1.html&apos;, title:&apos;page1&apos;, &#125;, page2:&apos;src/page/page2/main.js&apos;&#125;module.exports = &#123; outputDir: &apos;dist_test&apos;, filenameHashing: false, //静态文件不自动生成hash pages:pages&#125; 执行 npm run build 打包生成dist_test目录如下 ├── favicon.ico├── index.html├── js│ ├── chunk-vendors.js│ ├── chunk-vendors.js.map│ ├── page1.js│ ├── page1.js.map│ ├── page2.js│ └── page2.js.map├── page1.html├── page2.html├── report.html└── report.json lintOnSave [Type:boolean || ‘error’][Default:true]设置为 true 时，eslint-loader 会将 lint 错误输出为编译警告。默认情况下，警告仅仅会被输出到命令行，且不会使得编译失败。如果你希望让 lint 错误在开发时直接显示在浏览器中，你可以使用 lintOnSave: ‘error’。这会强制 eslint-loader 将 lint 错误输出为编译错误，同时也意味着 lint 错误将会导致编译失败。当 lintOnSave 是一个 truthy 的值时，eslint-loader 在开发和生产构建下都会被启用。如果你想要在生产构建时禁用 eslint-loader，你可以用如下配置：1234// vue.config.jsmodule.exports = &#123; lintOnSave: process.env.NODE_ENV !== &apos;production&apos;&#125; transpileDependencies [Type:string || RegExp][Default:[]]默认情况下 babel-loader 会忽略所有 node_modules 中的文件。如果你想要通过 Babel 显式转译一个依赖，可以在这个选项中列出来。 productionSourceMap [Type:boolean][Default:true]如果你不需要生产环境的 source map，可以将其设置为 false 以加速生产环境构建。1234// vue.config.jsmodule.exports = &#123; productionSourceMap:false&#125; -&gt; crossorigin [Type:string][Default:undefined]TODO… integrity [Type:boolean][Default:true]在生成的 HTML 中的 &lt;link rel=&quot;stylesheet&quot;&gt; 和 &lt;script&gt; 标签上启用 Subresource Integrity (SRI)。如果你构建后的文件是部署在 CDN 上的，启用该选项可以提供额外的安全性。需要注意的是该选项仅影响由 html-webpack-plugin 在构建时注入的标签 - 直接写在模版 (public/index.html) 中的标签不受影响。另外，当启用 SRI 时，preload resource hints 会被禁用，因为 Chrome 的一个 bug 会导致文件被下载两次。 configureWebpack [Type:object || Function]如果这个值是一个对象，则会通过 webpack-merge 合并到最终的配置中。如果这个值是一个函数，则会接收被解析的配置作为参数。该函数及可以修改配置并不返回任何东西，也可以返回一个被克隆或合并过的配置版本。更多细节可查阅：配合 webpack &gt; 简单的配置方式webpack官网配置demo如下： vue.config.js123456789101112131415161718192021222324const UglifyJsPlugin = require(&apos;uglifyjs-webpack-plugin&apos;); //清除注释//Objectmodule.exports = &#123; configWebpack:&#123; plugins:[ new UglifyJsPlugin(), ] &#125;&#125;//Functionmodule.exports = &#123; configWebpack: config =&gt;&#123; var plugins = [ new UglifyJsPlugin() ]； config.plugins = [ ...config.plugins, ...plugins ]; &#125;&#125; chainWebpack [Type:Function]是一个函数，会接收一个基于 webpack-chain 的 ChainableConfig 实例。允许对内部的 webpack 配置进行更细粒度的修改你需要熟悉 webpack-chain 的 API 并阅读一些源码以便了解如何最大程度利用好这个选项，但是比起直接修改 webpack 配置，它的表达能力更强，也更为安全。demo如下 vue.config.js123456789101112module.exports = &#123; chainWebpack: config =&gt; &#123; config.module .rule(&apos;vue&apos;) .use(&apos;vue-loader&apos;) .loader(&apos;vue-loader&apos;) .tap(options =&gt; &#123; // 修改它的选项... return options &#125;) &#125;&#125; css.modules [Type:boolean][Default:false]TODO.. css.extract [Type:boolean][Default: 生产环境下是 true，开发环境下是 false]TODO… devServer [Type:object]所有webpack-dev-server的选项都支持 devServer.proxyTODO….. parallel[Type:boolean][Default: require(‘os’).cpus().length &gt; 1]是否为 Babel 或 TypeScript 使用 thread-loader。该选项在系统的 CPU 有多于一个内核时自动启用，仅作用于生产构建。 pluginOptions [Type:object]这是一个不进行任何 schema 验证的对象，因此它可以用来传递任何第三方插件选项。例如：1234567module.exports = &#123; pluginOptions: &#123; foo: &#123; // 插件可以作为 `options.pluginOptions.foo` 访问这些选项。 &#125; &#125;&#125; BabelBabel 可以通过 babel.config.js 进行配置。TIP Vue CLI 使用了 Babel 7 中的新配置格式 babel.config.js。和 .babelrc 或 package.json 中的 babel 字段不同，这个配置文件不会使用基于文件位置的方案，而是会一致地运用到项目根目录以下的所有文件，包括 node_modules 内部的依赖。我们推荐在 Vue CLI 项目中始终使用 babel.config.js 取代其它格式。 TypeScriptTypeScript 可以通过 tsconfig.json 来配置。 更多细节可查阅 @vue/cli-plugin-typescript 单元测试Jest更多细节可查阅 @vue/cli-plugin-unit-jest Mocha (配合 mocha-webpack)更多细节可查阅 @vue/cli-plugin-unit-mocha 三、模式模式是 Vue CLI 项目中一个重要的概念。默认情况下，一个 Vue CLI 项目有三个模式： development 模式用于 vue-cli-service serve production 模式用于 vue-cli-service build 和 vue-cli-service test:e2e test 模式用于 vue-cli-service test:unit 注意模式不同于 NODE_ENV，一个模式可以包含多个环境变量。也就是说，每个模式都会将 NODE_ENV 的值设置为模式的名称——比如在 development 模式下 NODE_ENV 的值会被设置为 “development”。你可以通过为 .env 文件增加后缀来设置某个模式下特有的环境变量。比如，如果你在项目根目录创建一个名为 .env.development 的文件，那么在这个文件里声明过的变量就只会在 development 模式下被载入。 示例：Staging 模式假设我们有一个应用包含以下 .env 文件： VUE_APP_TITLE=My App和 .env.staging 文件：12NODE_ENV=productionVUE_APP_TITLE=My App (staging) vue-cli-service build 会加载可能存在的 .env、.env.production 和 .env.production.local 文件然后构建出生产环境应用； vue-cli-service build --mode staging 会在 staging 模式下加载可能存在的 .env、.env.staging 和 .env.staging.local 文件然后构建出生产环境应用。 这两种情况下，根据 NODE_ENV，构建出的应用都是生产环境应用，但是在 staging 版本中，process.env.VUE_APP_TITLE 被覆写成了另一个值。 在客户端侧代码中使用环境变量只有以 VUE_APP_ 开头的变量会被 webpack.DefinePlugin 静态嵌入到客户端侧的包中。你可以在应用的代码中这样访问它们：1console.log(process.env.VUE_APP_SECRET) 在构建过程中，process.env.VUE_APP_SECRET 将会被相应的值所取代。在 VUE_APP_SECRET=secret 的情况下，它会被替换为 “sercet”。 除了 VUE_APP_* 变量之外，在你的应用代码中始终可用的还有两个特殊的变量： NODE_ENV - 会是 “development”、”production” 或 “test” 中的一个。具体的值取决于应用运行的模式。BASE_URL - 会和 vue.config.js 中的 publicPath 选项相符，即你的应用会部署到的基础路径。所有解析出来的环境变量都可以在 public/index.html 中以 HTML 插值中介绍的方式使用。 GitLab Pages根据gitlab pages文档的描述,所有的配置都在根目录中的.gitlab-ci.yml 文件中。下面的范例是一个很好的入门:123456789101112131415# .gitlab-ci.yml 文件应放在你仓库的根目录下 pages: # 必须定义一个名为 pages 的 job image: node:latest stage: deploy script: - npm ci - npm run build - mv public public-vue # GitLab Pages 的钩子设置在 public 文件夹 - mv dist public # 重命名 dist 文件夹 (npm run build 之后的输出位置) artifacts: paths: - public # artifact path 一定要在 /public , 这样 GitLab Pages 才能获取 only: - master 在推送到仓库之前提交 .gitlab-ci.yml 和 vue.config.js 文件。GitLab CI 的管道将会被触发: 当成功时候, 到 Settings &gt; Pages 查看关于网站的链接。]]></content>
      <categories>
        <category>vue</category>
      </categories>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js常用方法]]></title>
    <url>%2F2019%2F05%2F06%2Fjs_methods%2F</url>
    <content type="text"><![CDATA[1.监听滚动到底部+节流阀 2.canvas绘图 3.HTML代码中&lt;%%&gt;、&lt;%=%&gt;、&lt;%:%&gt;各是什么意思?分别用来实现什么的? 4.img标签中src请求的原理（过程），Filter是否可以拦截不可拦截，但无论是binary还是img对象都可监听onload onerror事件 5.js reduce 6.canvas图片跨域问题 - 简书www.jianshu.com 7.使用Charles进行HTTPS抓包 - 简书www.jianshu.com 8.Tencent/vConsole: A lightweight, extendable front-end developer tool for mobile web page.github.com 9.https://github.com/libin1991/Mobile-webpackPlugin-for-consoleDebug/blob/29367af7d72ade08ae68053ac41bafd4c6373256/files/debug.js 10.MAC终端神器iterm2——告别黑白 - xiaobe - 博客园www.cnblogs.com 11.CSS3 @media查询 | 菜鸟教程www.runoob.com 12.媒体查询使用方法@media - Leaves_Yu的博客 - CSDN博客blog.csdn.net 13.html5的audio实现高仿微信语音播放效果 - 创业男生 - 博客园www.cnblogs.com 14.git 放弃解决冲突_百度搜索www.baidu.com 15.meta no-cache_百度搜索www.baidu.com 16.URL.createObjectURL和URL.revokeObjectURL - 诗&amp;远方 - 博客园www.cnblogs.com 17.input file限制文件类型 - Google 搜索www.google.com.hk 18.input type = file上传图片限制大小、类型判断、像素判断 - 阿俊的博客 - CSDN博客blog.csdn.net 19.GaryStimson/paste.js: read image/text data from clipboard (cross-browser)github.com 20.charles external proxy server https://juejin.im/post/5c9f3d4cf265da30af3c0a94 21.https://juejin.im/post/5cab64ce5188251b19486041 22.https://blog.csdn.net/weixin_42112635/article/details/88070622 23.https://www.jianshu.com/p/903ec28c5640 24.js 在module中解析字符串为变量 brew yarn.lock? 为什么多数项目中都有这个文件 DOMContentLoaded与load的区别 font文件跨域，转成base64过大 在linux下安装Node CentOS7安装node.js switchHosts软件基于electron开发而成 [👍]]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[markdown编辑器语法——文字颜色、大小、字体与背景色的设置]]></title>
    <url>%2F2019%2F04%2F29%2Fmd_config%2F</url>
    <content type="text"><![CDATA[一、颜色 在markdown中采用如下方式能够控制文字的颜色：123浅红色文字：&lt;font color=&quot;#dd0000&quot;&gt;浅红色文字：&lt;/font&gt;&lt;br /&gt; 浅青色文字：&lt;font color=&quot;#00dddd&quot;&gt;浅青色文字&lt;/font&gt;&lt;br /&gt; 浅紫色文字：&lt;font color=&quot;#dd00dd&quot;&gt;浅紫色文字&lt;/font&gt;&lt;br /&gt; 效果如下：浅青色文字：浅青色文字 二、大小12size为1：&lt;font size=&quot;1&quot;&gt;size为1&lt;/font&gt;&lt;br /&gt; size为2：&lt;font size=&quot;2&quot;&gt;size为2&lt;/font&gt;&lt;br /&gt; 效果如下：size为1：size为1 三、字体12&lt;span style=&quot;font-family:&quot;SimHei&quot;, serif;&quot;&gt;我是黑体字&lt;/span&gt;&lt;span style=&quot;font-family:SimSun, serif;&quot;&gt;我是宋体字&lt;/span&gt; 效果如下：我是宋体字 四、背景色1&lt;table&gt;&lt;tr&gt;&lt;td bgcolor=#FFCDC7&gt;背景色的设置是按照十六进制颜色值：#FFCDC7&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt; 效果如下： 背景色的设置是按照十六进制颜色值：#FFCDC7 五：1&lt;span xss=removed&gt;所添加的需要加下划线的行内文字&lt;/span&gt; 效果如下所添加的需要加下划线的行内文字]]></content>
      <categories>
        <category>markdown</category>
      </categories>
      <tags>
        <tag>markdown</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[css填坑指南]]></title>
    <url>%2F2019%2F04%2F29%2Fcss_g%2F</url>
    <content type="text"><![CDATA[前言css的坑跨过了一个又一个，以前总是过了就算了，不久就又忘了 😂so 开一篇文章专门记录遇到的各种css坑~~~ 正文 背景图片旋转TODO … ❣️]]></content>
      <categories>
        <category>css</category>
      </categories>
      <tags>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo神坑]]></title>
    <url>%2F2019%2F04%2F29%2Fhexo_bug%2F</url>
    <content type="text"><![CDATA[想做个内容折叠的功能，网上找到了代码，咔咔咔复制粘贴。发现并没有折叠…….. (〒︿〒)就开始查代码找问题，原来是首页的index.html文件没有引入post-details.js文件，而文章详情页会自动引入post-details.js,所以只有详情页折叠才是生效的 (〒︿〒)^2我是通过 hexo deploy命令 生成public文件夹的，那么这个命令都做了写什么??]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[sublime IDE 常见快捷键]]></title>
    <url>%2F2019%2F04%2F29%2Fsublime_quick_find%2F</url>
    <content type="text"><![CDATA[符号说明⌘：command⌃：control⌥：option⇧：shift↩：enter⌫：delete （打开/关闭/前往）快捷键 功能⌘⇧N 打开一个新的sublime窗口⌘N 新建文件⌘⇧W 关闭sublime，关闭所有文件⌘W 关闭当前文件⌘P 跳转、前往文件、前往项目、命令提示、前往method等等（Goto anything）⌘⇧T 重新打开最近关闭的文件⌘T 前往文件⌘⌃P 前往项目⌘R 前往method⌘⇧P 命令提示⌃G 前往行⌘KB 开关侧栏⌃` 打开控制台⌃- 光标跳回上一个位置⌃⇧- 光标恢复位置 （编辑）快捷键 功能⌘A 全选⌘L 选择行（重复按下将下一行加入选择）⌘D 选择词（重复按下时多重选择相同的词进行多重编辑）⌃⇧M 选择括号的内容⌘⇧↩ 在当前行前插入新行⌘↩ 在当前行后插入新行⌃⇧K 删除行⌘KK 从光标处删除至行尾⌘K⌫ 从光标处删除至行首⌘⇧D 复制（多）行⌘J 合并（多）行⌘KU 改为大写⌘KL 改为小写⌘C 复制⌘X 剪切⌘V 粘贴⌘/ 注释⌘⌥/ 块注释⌘Z 撤销⌘Y 恢复撤销⌘⇧V 粘贴并自动缩进⌘⌥V 从历史中选择粘贴⌃M 跳转至对应的括号⌘U 软撤销（可撤销光标移动）⌘⇧U 软重做（可重做光标移动）⌘⇧S 保存所有文件⌘] 向右缩进⌘[ 向左缩进⌘⌥T 特殊符号集⌘⇧L 将选区转换成多个单行选区 （查找/替换）快捷键 功能⌘f 查找⌘⌥f 查找并替换⌘⌥g 查找下一个符合当前所选的内容⌘⌃g 查找所有符合当前选择的内容进行多重编辑⌘⇧F 在所有打开的文件中进行查找 （拆分窗口/标签页）快捷键 功能⌘⌥[1,2,3,4] 单列、双列、三列、四列⌘⌥5 网格（4组）⌃[1,2,3,4] 焦点移动到相应的组（分屏编号）⌃⇧[1,2,3,4] 将当前文件移动到相应的组（分屏编号）⌘[1,2,3,4] 选择相应的标签页 （快捷操作）快捷键 功能⌘⌃上下键 两行交换位置⌘KB 显示/隐藏侧边 开启vim 模式：在菜单栏中： Preferences -&gt; Setting - User ，即可打开配置文件进行编辑，将 ignored_packages 项的[]里面内容清空或注释掉：]]></content>
      <categories>
        <category>编译器</category>
        <category>sublime</category>
      </categories>
      <tags>
        <tag>sublime</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue插件汇总 [learn]]]></title>
    <url>%2F2019%2F04%2F29%2Fvue_plugin_generation%2F</url>
    <content type="text"><![CDATA[一、UI组件及框架element - 饿了么出品的Vue2的web UI工具套件mint-ui - Vue 2的移动UI元素iview - 基于 Vuejs 的开源 UI 组件库Keen-UI - 轻量级的基本UI组件合集vue-material - 通过Vue Material和Vue 2建立精美的app应用muse-ui - 三端样式一致的响应式 UI 库vuetify - 为移动而生的Vue JS 2组件框架vonic - 快速构建移动端单页应用vue-blu - 帮助你轻松创建web应用vue-multiselect - Vue.js选择框解决方案VueCircleMenu - 漂亮的vue圆环菜单vue-chat - vuejs和vuex及webpack的聊天示例radon-ui - 快速开发产品的Vue组件库vue-waterfall - Vue.js的瀑布布局组件vue-carbon - 基于 vue 开发MD风格的移动端vue-beauty - 由vue和ant design创建的优美UI组件bootstrap-vue - 应用于Vuejs2的Twitter的Bootstrap 4组件vueAdmin - 基于vuejs2和element的简单的管理员模板vue-ztree - 用 vue 写的树层级组件vue-tree - vue树视图组件vue-tabs - 多tab页轻型框架 二、滚动scroll组件vue-scroller - Vonic UI的功能性组件vue-mugen-scroll - 无限滚动组件vue-infinite-loading - VueJS的无限滚动插件vue-virtual-scroller - 带任意数目数据的顺畅的滚动vue-infinite-scroll - VueJS的无限滚动指令vue-scrollbar - 最简单的滚动区域组件vue-scroll - vue滚动vue-pull-to-refresh - Vue2的上拉下拉mint-loadmore - VueJS的双向下拉刷新组件vue-smoothscroll - smoothscroll的VueJS版本 三、slider组件vue-awesome-swiper - vue.js触摸滑动组件vue-slick - 实现流畅轮播框的vue组件vue-swipe - VueJS触摸滑块vue-swiper - 易于使用的滑块组件vue-images - 显示一组图片的lightbox组件vue-carousel-3d - VueJS的3D轮播组件vue-slide - vue轻量级滑动组件vue-slider - vue 滑动组件vue-m-carousel - vue 移动端轮播组件dd-vue-component - 订单来了的公共组件库vue-easy-slider - Vue 2.x的滑块组件 四、编辑器markcook - 好看的markdown编辑器eme - 优雅的Markdown编辑器vue-syntax-highlight - Sublime Text语法高亮vue-quill-editor - 基于Quill适用于Vue2的富文本编辑器Vueditor - 所见即所得的编辑器vue-html5-editor - html5所见即所得编辑器vue2-editor - HTML编辑器vue-simplemde - VueJS的Markdown编辑器组件vue-quill - vue组件构建quill编辑器 五、图表vue-table - 简化数据表格vue-chartjs - vue中的Chartjs的封装vue-charts - 轻松渲染一个图表vue-chart - 强大的高速的vue图表解析vue-highcharts - HighCharts组件chartjs - Vue Bulma的chartjs组件vue-chartkick - VueJS一行代码实现优美图表 六、日历vue-calendar - 日期选择插件vue-datepicker - 日历和日期选择组件vue-datetime-picker - 日期时间选择控件vue2-calendar - 支持lunar和日期事件的日期选择器vue-fullcalendar - 基于vue.js的全日历组件vue-datepicker - 漂亮的Vue日期选择器组件datepicker - 基于flatpickr的时间选择组件vue2-timepicker - 下拉时间选择器vue-date-picker - VueJS日期选择器组件vue-datepicker-simple - 基于vue的日期选择器 七、地址选择vue-city - 城市选择器vue-region-picker - 选择中国的省份市和地区 八、地图vue-amap - 基于Vue 2和高德地图的地图组件vue-google-maps - 带有双向数据绑定Google地图组件vue-baidu-map- 基于 Vue 2的百度地图组件库vue-cmap - Vue China map可视化组件 九、播放器vue-video-player - VueJS视频及直播播放器vue-video - Vue.js的HTML5视频播放器vue-music-master - vue手机端网页音乐播放器 十、文件上传vue-upload-component - Vuejs文件上传组件vue-core-image-upload - 轻量级的vue上传插件vue-dropzone - 用于文件上传的Vue组件 十一、图片处理vue-lazyload-img - 移动优化的vue图片懒加载插件vue-image-crop-upload - vue图片剪裁上传组件vue-svgicon - 创建svg图标组件的工具vue-img-loader - 图片加载UI组件vue-image-clip- 基于vue的图像剪辑组件vue-progressive-image - Vue的渐进图像加载插件 十二、提示vue-toast-mobile - VueJS的toast插件vue-msgbox - vuejs的消息框vue-tooltip - 带绑定信息提示的提示工具vue-verify-pop - 带气泡提示的vue校验插件 十三、进度条vue-radial-progress - Vue.js放射性进度条组件vue-progressbar - vue轻量级进度条vue2-loading-bar - 最简单的仿Youtube加载条视图 十四、开发框架汇总vue-admin - Vue管理面板框架electron-vue - Electron及VueJS快速启动样板vue-2.0-boilerplate - Vue2单页应用样板vue-webgulp - 仿VueJS Vue loader示例vue-bulma - 轻量级高性能MVVM Admin UI框架vue-spa-template - 前后端分离后的单页应用开发Framework7-Vue - VueJS与Framework7结合vue-element-starter - vue启动页 十五、实用库汇总vuelidate - 简单轻量级的基于模块的Vue.js验证qingcheng - qingcheng主题vuex - 专为 Vue.js 应用程序开发的状态管理模式vue-axios - 将axios整合到VueJS的封装vue-desktop - 创建管理面板网站的UI库vue-meta - 管理app的meta信息avoriaz - VueJS测试实用工具库vue-framework7 - 结合VueJS使用的Framework7组件vue-lazy-render - 用于Vue组件的延迟渲染vue-svg-icon - vue2的可变彩色svg图标方案vue-online - reactive的在线和离线组件vue-password-strength-meter - 交互式密码强度计vuep - 用实时编辑和预览来渲染Vue组件vue-bootstrap-modal - vue的Bootstrap样式组件element-admin - 支持 vuecli 的 Element UI 的后台模板vue-shortkey - 应用于Vue.js的Vue-ShortKey 插件cleave - 基于cleave.js的Cleave组件vue-events - 简化事件的VueJS插件http-vue-loader - 从html及js环境加载vue文件vue-electron - 将选择的API封装到Vue对象中的插件vue-router-transition - 页面过渡插件vuemit - 处理VueJS事件vue-cordova - Cordova的VueJS插件vue-qart - 用于qartjs的Vue2指令vue-websocket - VueJS的Websocket插件vue-gesture - VueJS的手势事件插件vue-local-storage - 具有类型支持的Vuejs本地储存插件lazy-vue - 懒加载图片vue-lazyloadImg - 图片懒加载插件vue-bus - VueJS的事件总线vue-observe-visibility - 当元素在页面上可见或隐藏时检测vue-notifications - 非阻塞通知库v-media-query - vue中添加用于配合媒体查询的方法vuex-shared-mutations - 分享某种Vuex mutationsvue-lazy-component - 懒加载组件或者元素的Vue指令vue-reactive-storage - vue插件的Reactive层vue-ts-loader - 在Vue装载机检查脚本vue-pagination-2 - 简单通用的分页组件vuex-i18n - 定位插件Vue.resize - 检测HTML调整大小事件的vue指令vue-zoombox - 一个高级zoomboxleo-vue-validator - 异步的表单验证组件modal - Vue Bulma的modal组件Famous-Vue - Famous库的vue组件vue-input-autosize - 基于内容自动调整文本输入的大小vue-file-base64 - 将文件转换为Base64的vue组件Vue-Easy-Validator - 简单的表单验证vue-truncate-filter - 截断字符串的VueJS过滤器 十六、服务端vue-ssr - 结合Express使用Vue2服务端渲染nuxt.js - 用于服务器渲染Vue app的最小化框架vue-ssr - 非常简单的VueJS服务器端渲染模板vue-easy-renderer - Nodejs服务端渲染express-vue - 简单的使用服务器端渲染vue.js 十七、辅助工具DejaVue - Vuejs可视化及压力测试vue-generate-component - 轻松生成Vue js组件的CLI工具vscode-VueHelper - 目前vscode最好的vue代码提示插件vue-play - 展示Vue组件的最小化框架VuejsStarterKit - vuejs starter套件vue-multipage-cli - 简单的多页CLI 十八、应用实例pagekit - 轻量级的CMS建站系统vuedo - 博客平台koel - 基于网络的个人音频流媒体服务CMS-of-Blog - 博客内容管理器vue-cnode - 重写vue版cnode社区vue-ghpages-blog - 依赖GitHub Pages无需本地生成的静态博客swoole-vue-webim - Web版的聊天应用fewords - 功能极其简单的笔记本jackblog-vue - 个人博客系统vue-blog - 使用Vue2.0 和Vuex的vue-blogvue-dashing-js - nuvo-dashing-js的forkrss-reader - 简单的rss阅读器 声明：作者：尹先生code链接：https://www.jianshu.com/p/3147c5b76f15]]></content>
      <categories>
        <category>前端</category>
        <category>vue</category>
      </categories>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[如何在一台机器上同时使用github与gitlab服务?]]></title>
    <url>%2F2019%2F04%2F29%2Fgithub_gitlab_ssh%2F</url>
    <content type="text"><![CDATA[前言：github是网络公有代码仓库，一般用于私人代码托管，而githuab一般是企业搭建的内部代码仓库。工作期间，我们都会同时用到这两个仓库，但企业邮箱和个人邮箱是不同的，因此产生的ssh key会不同，就造成了冲突。如何在一台机器上同时使用github与gitlab服务呢? 步骤：1.生成秘钥 公司的GitLab生成一个SSH-Key 在~/.ssh/目录会生成gitlab_id-rsa和gitlab_id-rsa.pub私钥和公钥。我们将gitlab_id-rsa.pub中的内容粘帖到公司GitLab服务器的SSH-key的配置中。$ ssh-keygen -t rsa -C “注册的gitlab邮箱” -f ~/.ssh/gitlab_id-rsa 公网github生成一个SSH-Key 在~/.ssh/目录会生成github_id-rsa和github_id-rsa.pub私钥和公钥。我们将github_id-rsa.pub中的内容粘帖到github服务器的SSH-key的配置中。$ ssh-keygen -t rsa -C “注册的github邮箱” -f ~/.ssh/github_id-rsa 2.添加config在~/.ssh下添加config配置文件,内容如下：12345678910111213141516# github keyHost github Port 22 User git HostName github.com PreferredAuthentications publickey IdentityFile ~/.ssh/github_id-rsa#如果你是macOS Sierra 0.12.2及以后版本，都需要添加以下两个字段 AddKeysToAgent yes UseKeychain yesHost gitlab Port 22 User git HostName gitlab.com PreferredAuthentications publickey IdentityFile ~/.ssh/gitlab_id-rsa 下面对上述配置文件中使用到的配置字段信息进行简单解释： Host它涵盖了下面一个段的配置，我们可以通过他来替代将要连接的服务器地址。这里可以使用任意字段或通配符。当ssh的时候如果服务器地址能匹配上这里Host指定的值，则Host下面指定的HostName将被作为最终的服务器地址使用，并且将使用该Host字段下面配置的所有自定义配置来覆盖默认的/etc/ssh/ssh_config配置信息。 Port自定义的端口。默认为22，可不配置 User自定义的用户名，默认为git，可不配置 HostName真正连接的服务器地址 PreferredAuthentications指定优先使用哪种方式验证，支持密码和秘钥验证方式 IdentityFile指定本次连接使用的密钥文件 3 添加ssh私钥到ssh-agentterminal执行命令 ssh-add -K ~/.ssh/gitlab_id-rsa 4.配置仓库假设gitlab与github的工作目录分别如下所示： github工作仓库:~/workspace/githubgitlab工作仓库:~/workspace/gitlab 则配置如下：1234567891011#gitlabcd ~/workspace/gitlabgit initgit config --global user.name &apos;gitlab&apos;git config --global user.email &apos;gitlab@company.com&apos;#githubcd ~/workspace/githubgit initgit config --local user.name &apos;personal&apos;git config --local user.email &apos;personal@163.com&apos; 4.测试12345# 测试github$ ssh -T git@github.com # 测试gitlab$ ssh -T git@gitlab.com .git文件到底有什么用嘞?TODO…. ##不小心把.git文件删除了，如何获取？git init命令自动生成.git文件 修改git远程仓库不知道做了什么操作，今天提代码时发现推不上去 git remote -v命令返回空噔噔噔噔~ 使用 git remote add origin [url] 就好啦 也可以直接修改config文件~ 参考资料：github和gitlab仓库一起使用]]></content>
      <categories>
        <category>git</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[linux学习笔记]]></title>
    <url>%2F2019%2F04%2F13%2Flearn-linux%2F</url>
    <content type="text"><![CDATA[一文字模式下指令的下达默认root的提示符为# 一般身份使用者的提示符为$ Linux的默认shell程序就是bash加入选项设置时，通常选项前会带 - 号，例如-h有时会使用选项的完整全名，则选项前带 – 号，例如–help4.2.2 无论几个空格都会被识别为一个空格4.2.3 enter表示启动当前行指令4.2.4 指令太长，可以使用反斜线()+回车符(enter)换行4.2.5 重要的几个热键 tab 命令补全 ctrl+c 中断程序执行 ctrl+d 直接离开命令行 fn+↑ 上一屏 fn+↓ 下一屏 tab tab 显示所有可用指令 space 显示more时可向下翻页 /关键字 向下主动搜索关键字 （效果如下） ?关键字 向上主动搜索关键字 n, N 利用/或者?来搜索字符串时，可以用n来继续下一个搜索，用N进行反向搜索 4.2.6 –help 可以帮助你如何去使用指令4.2.7 man command 显示完整的操作说明(星星眼) man是manual的简写啦例：输入man date后shell会打印以下信息~截图第一行中可以看到DATE(1) DATE表示指令名称，（1）代表”一般使用者可使用的命令” 那么是不是代表还有其他代号嘞~~ 当然啦 上截图！上述的表格内容可以使用”man man”来更详细的取得说明TIPS:上表中的1,5,8这三个代码hin重要，也请务必将这三个数字的含义记下来！ 简而言之，如何去找到所需要的指令呢？（ 以打印为例lp[line print] ） man lp ，找到相关说明 lp[tab][tab] 找到以lp开头的指令 找到相关指令后， –help 查基本语法 若有需要再以man去查询指令的用法 TIPS：如果你知道某个指令，但却忘记了相关参数与选项，请先善用–help 来查询相关信息；当有任何你不知道的指令或文件格式等，但你想要了解它，请使用man/info查询 二 超简单文本编译器 nano vim 等 (本小节仅讲nano)三 Linux的文件权限与目录配置在linux中任何一个文件都具有user group other三种身份的权限 linux文件权限概念当你在你的屏幕前面出现了”Permission deny”的时候，不用担心，肯定是权限设置错误啦 linux文件属性使用sudo切换为root身份在terminal输入ls -al可查看文件详细信息 d r w x r - x r - x ① ② ③ ④ ⑤ ⑥ ⑦ ⑧ ⑨ ⑩ ① 当为[d]则是目录 当为[-]则是文件 [l]表示为链接未见 [b]可随机存取设备 ②③④ user权限三个为一组，均为“rwx”的三个参数的组合。 [r] —— read [w] —— write [x] —— execute [-] —— 无权限 ⑤⑥⑦ group权限 ⑧⑨⑩ other权限 root基本上是不受系统的权限所限制，无论文件权限是什么，默认root都可存取 如何改变文件属性与权限几种常用于group、user、other权限修改的指令：chgrp ——&gt; 改变文件所属群组 (要被改变的群组名称必须要在/etc/group文件内存在才行)chown ——&gt; 改变文件userchmod ——&gt; 改变文件的权限, SUID, SGID, SBIT等特性 复制文件，cp 来源文件 目的文件，由于cp会复制执行者的属性与权限，可通过chmod修改 改变权限,chmod 数字类型改变文件权限Linux文件的基本权限有9个，分别是owner/user/other三中身份各有read/white/execute权限，这九个权限是三个一组的，可以使用数字表示各个权限，各权限的分数对照表如下： &gt;r:4 &gt; w:2 &gt; x:1 每种身份各自的三个权限(r/w/x)分数是需要累加的，例如：权限为 [-rwxrwx—]分数为： owner = rwx = 4 + 2 + 1 = 7 &gt; group = rwx = 4 + 2 + 1 = 7 &gt; other = 0所以等下我们设置权限的变更时，该文件的权限就是770啦如果我们要将某文件(a.txt)的权限都设置为启用，只需要输入一下命令即可：chmod 777 a.txt 符号类型改变文件权限user group other三种身份可用u g o 表示。此外a表示all,读写权限可写成r w x也就是可以使用下面的方式来看：| chmod | u g o a | + (加入) - (除去) = (设置) | r w x | 文件或目录将一个文件权限改成”-rwxr-xr-x”chmod u=rwx,go=rx a.txt如果不知道原先的文件属性，只想要给a.txt文件的三种身份都增加可写入权限：chmod a+w a.txt 目录与文件权限意义 权限对文件的重要性r 可读取文件的实际内容，如读取文本文件的文字内容等w 可以编辑、新增、修改文件的内容(但不含删除该文件!)x 该文件具有可以被系统执行的权限 权限对目录的重要性r 具有读取目录结构清单的权限w 具有以下权限 1.创建新的文件与目录 2.删除已存在的文件与目录(不论改文件的权限是什么) 3.将已存在的文件或目录更名 4.移动该目录内的文件、目录位置x 使用者能否进入该目录 linux文件种类与扩展名 正规文件——第一个属性为[-] 纯文本文件 二进制档 数据格式文件 目录——第一个属性为[d] 链接文件——类似windows系统下的快捷方式，第一个属性为[l] 设备与设备文件 数据接口文件 数据输送档 常用扩展名 *.sh：脚本或批处理文件，因为批处理文件为使用shell写成的， 所以扩展名为.sh Z, .tar, .tar.gz, .zip, *.tgz: 经过打包的压缩文件 .html .php基本上，linux系统上的文件名只是为了让你了解该文件可能的用途，真正的执行与否仍需要权限 文件名称的开头为小数点.时，代表这个文件为”隐藏文件”。 linux目录配置linux目录配置的依据 —— FHSFHS依据文件系统使用的频繁与否与是否允许使用者随意更改，而将目录定义为四种交互作用的形态1.可分享的——可以分享给其他系统挂载使用的目录2.不可分享——自己机器上运行的设备文件或者是3.不变的4.可变动的 四 安装SentOS7…[未完待续] 272页]]></content>
      <categories>
        <category>计算机</category>
        <category>操作系统</category>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[webpack打包时会打包其他独立页面的js文件[走查纠错]]]></title>
    <url>%2F2019%2F04%2F11%2Fwebpack_bug_fix%2F</url>
    <content type="text"><![CDATA[前言：在开发过程中，遇到一个神奇的问题，Vue多页面配置，打包时，会莫名其妙产生了两个chunk文件，而且这个文件十分庞大，仔细看了下，这个页面中根本没有引入这个文件/(ㄒoㄒ)/~~ 怎么肥四呢~ 正好趁着坑还热乎！ 抓紧去webpack官网看下 打包究竟是怎样的一个流程~ PS:https://webpack.docschina.org/concepts/ webpack官网https://webpack.docschina.org/plugins webpack插件列表， 福音啊~~https://github.com/webpack-contrib/awesome-webpack#webpack-plugins 更多第三方插件，查看 awesome-webpack列表 插件接口(plugin interface) 功能极其强大，可以用来处理各种各样的任务。[删] 核心文档梳理 (基于v4.29.6版本) ↓1.entry每个html对应一个entry入口起点 值：string || array || object 1.1 单个入口（简写）语法123456789101112131415-------------单入口 ↓-------------module.exports = &#123; entry: &#123; main: &apos;入口文件相对路径.js&apos; &#125;&#125;简写：module.exports = &#123; entry: &apos;入口文件相对路径.js&apos;&#125;-------------多入口 ↓-------------使用场景：一次注入多个依赖文件，并将他们的依赖导向到一个chunkmodule.exports = &#123; entry: [&apos;入口文件相对路径1.js&apos;,&apos;入口文件相对路径2.js&apos;]&#125; 1.2 对象语法对于多页面应用程序来说，页面之间都是相互独立的，这就需要有多个入口分离打包同时，随着入口起点的增多，多页面应用能够复用入口起点之间的大量代码/模块，使用 optimization.splitChunks【有待深入】 为页面间共享的应用程序代码创建 bundle，可以极大地优化应用。123456module.exports = &#123; entry: &#123; app: &apos;./xxx/app.js&apos;, adminApp: &apos;./xxx/adminApp.js&apos; &#125;&#125;; 2.output控制webpack如何向硬盘写入便以文件。多个entry起点，仅会指定一个output配置 app-&gt;应用程序vendor-&gt;第三方库 …[未完待续]]]></content>
      <categories>
        <category>前端</category>
        <category>webpack</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>webpack</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[发布 npm 包]]></title>
    <url>%2F2019%2F04%2F10%2FnpmPublish%2F</url>
    <content type="text"><![CDATA[文章源自发布 npm 包, 如有侵权 请联系删除 1.项目初始化vue init webpack-simple 项目名称 项目结构如下 项目结构 2.components/index.js 文件下 引入文件组件import zlCalendar from &apos;./zl-calendar&apos; import zlRange from &apos;./zl-range&apos; import zlSlideDelete from &apos;./zl-slide-delete&apos; const comment = { install:function(Vue){ Vue.component(&apos;zlCalendar&apos;, zlCalendar) Vue.component(&apos;zlRange&apos;, zlRange) Vue.component(&apos;zlSlideDelete&apos;, zlSlideDelete) } } // global 的状态下自动安装 if(typeof window !== &apos;undefined&apos; &amp;&amp; window.Vue){ window.Vue.use(comment) } // 导出模块 export default comment 3. 修改 package.json{ &quot;name&quot;: &quot;zl-vue-ui&quot;, &quot;description&quot;: &quot;A Vue.js project&quot;, &quot;version&quot;: &quot;1.0.3&quot;, &quot;author&quot;: &quot;徐其闯 &lt;xqc1319681561@163.com&gt;&quot;, &quot;main&quot;: &quot;dist/zl-vue-ui.js&quot;,// 配置main结点，如果不配置，我们在其他项目中就不用import XX from &apos;包名&apos;来引用了，只能以包名作为起点来指定相对的路径 &quot;license&quot;: &quot;MIT&quot;, &quot;private&quot;: false, // 因为组件包是公用的，所以private为false &quot;scripts&quot;: { &quot;dev&quot;: &quot;cross-env NODE_ENV=development webpack-dev-server --open --hot&quot;, &quot;build&quot;: &quot;cross-env NODE_ENV=production webpack --progress --hide-modules&quot; }, &quot;repository&quot;: { // 指定代码所在的仓库地址 &quot;type&quot;: &quot;git&quot;, &quot;url&quot;: &quot;git+https://github.com/xuqichuang/zl-vue-ui.git&quot; }, &quot;dependencies&quot;: { &quot;better-scroll&quot;: &quot;^1.14.1&quot;, &quot;moment&quot;: &quot;^2.24.0&quot;, &quot;vue&quot;: &quot;^2.5.11&quot; }, &quot;browserslist&quot;: [ &quot;&gt; 1%&quot;, &quot;last 2 versions&quot;, &quot;not ie &lt;= 8&quot; ], &quot;keywords&quot;: [// 指定关键字 &quot;vue&quot;, &quot;vue-ui&quot; ], &quot;devDependencies&quot;: { &quot;babel-core&quot;: &quot;^6.26.0&quot;, &quot;babel-loader&quot;: &quot;^7.1.2&quot;, &quot;babel-preset-env&quot;: &quot;^1.6.0&quot;, &quot;babel-preset-stage-3&quot;: &quot;^6.24.1&quot;, &quot;cross-env&quot;: &quot;^5.0.5&quot;, &quot;css-loader&quot;: &quot;^0.28.7&quot;, &quot;file-loader&quot;: &quot;^1.1.4&quot;, &quot;node-sass&quot;: &quot;^4.9.3&quot;, &quot;sass-loader&quot;: &quot;^7.1.0&quot;, &quot;vue-loader&quot;: &quot;^13.0.5&quot;, &quot;vue-template-compiler&quot;: &quot;^2.4.4&quot;, &quot;webpack&quot;: &quot;^3.6.0&quot;, &quot;webpack-dev-server&quot;: &quot;^2.9.1&quot; } } 4.修改webpack.config.js// entry: &apos;./src/main.js&apos;, entry: &apos;./src/components/index.js&apos;, output: { path: path.resolve(__dirname, &apos;./dist&apos;), publicPath: &apos;/dist/&apos;, // filename: &apos;build.js&apos; filename: &apos;zl-vue-ui.js&apos;, library: &apos;zl-vue-ui&apos;, libraryTarget: &apos;umd&apos;, umdNamedDefine: true }, 5.修改.gitignore 文件因为要用dist文件夹，所以在.gitignore文件中把dist/去掉。 6.修改index.html&lt;!-- &lt;script src=&quot;/dist/build.js&quot;&gt;&lt;/script&gt; --&gt; &lt;script src=&quot;/dist/zl-vue-ui.js&quot;&gt;&lt;/script&gt; 7.测试插件在发正式包之前可以在本地先打一个包，然后测试下有没有问题，如果没问题再发布到npm上。 首先，打包到本地 npm run build npm pack npm pack 之后，就会在当前目录下生成 一个tgz 的文件。打开一个新的vue项目，在当前路径下执行(‘路径’ 表示文件所在的位置) npm install 路径/组件名称.tgz //使用方法import 变量名 from ‘组件名称’Vue.use(变量名) 8.发布到NPM 在 npm官网 注册一个npm账号 切换到需要发包的项目根目录下，npm login登录npm账号，输入用户名、密码、邮箱 最后一步，执行npm publish即可 发布到NPM后，使用插件时可以用npm install 组件名称 来安装]]></content>
      <categories>
        <category>npm</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>npm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue源码分析笔记]]></title>
    <url>%2F2019%2F03%2F23%2Fvuebasic%2F</url>
    <content type="text"><![CDATA[vue中的computed原理:set/get方法123456789101112131415161718192021222324//元素值变化的监听const obj = &#123; fName:&apos;ZHAO&apos;, lName:&apos;Danli&apos;,&#125;//obj.fullName = obj.fName + &apos;-&apos; + obj.lName;Object.defineProperty(obj,&apos;fullName&apos;,&#123; get()&#123; //根据其他相关的属性动态计算得到当前属性值 [被动] return this.fName + &apos;-&apos; + this.lName; &#125;, set(value)&#123; //监听当前属性值变化，更新其他相关属性 [主动] const names = value.spilt(&apos;-&apos;); this.fName = names[0]; this.lName = names[1]; &#125;,&#125;)console.log(obj.fullName);obj.fName = &apos;Bai&apos;; //fullName被动改变obj.lName = &apos;Kunjuan&apos;;console.log(obj.fullName);obj.fullName = &apos;Yang-shulin&apos;; //主动变更其他属性值console.log(obj.fName);console.log(obj.lName); DocumentFragment 详细请至MDN(改成链接)查看优：内存中保存多个element的内容容器，不与界面关联 【不会影响界面渲染】，避免过多重流 const ul = document.documentById(&apos;test1&apos;); //创建fragment const fragment = document.createDocumentFragment(); //取出test1中的所有子节点保存到fragment中 let child; while(child = ul.firstChild) { //取出ul的第一个子节点，赋值给child,判断child是否为true fragment.appendChild(child); //⚠️一个节点只能有一个父节点，因此一旦把child添加给fragment了，就脱离了其之前的父节点 } //改变fragment中的所有需要变更的子节点 let childs = fragment.childNodes(); //得到所有的子节点 Array.prototype.slice.call(childs).forEach((node,index)=&gt;{ if(node.nodeType == 1) { //当前节点为元素节点 node.textContent = &apos;新文本内容&apos;+index; } }) //用更改好的fragment插入到test1 ul.appendChild(); 数据代理：通过一个对象代理对另一个对象中属性的操作(读/写)vue数据代理:通过vm对象代理data对象中所有属性的操作原理:Object.defineProperty [es5语法 ie8不支持] 模板解析 …[未完待续]]]></content>
      <categories>
        <category>前端</category>
        <category>vue</category>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>vue</tag>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[理解fileReader]]></title>
    <url>%2F2018%2F12%2F22%2FfileReader%2F</url>
    <content type="text"><![CDATA[TODO … ｄ(･∀･*)♪ﾟ]]></content>
  </entry>
  <entry>
    <title><![CDATA[git常用命令]]></title>
    <url>%2F2018%2F10%2F15%2Fgit-command%2F</url>
    <content type="text"><![CDATA[配置12345678910git config --global user.name &quot;ihoey&quot; // 设置git用户名git config --global user.email &quot;mail@163.com&quot; // 设置git邮箱git config --global color.ui true // 为true是终端着色git config --global alias.co checkout // 配置checkout的别名git config --global alias.ci commit // 配置commit别名git config --global alias.cm commit // 配置commit别名git config --global alias.br branch // 配置branch别名git config --global alias.cp cherry-pick // 配置cherry-pick别名git config --global alias.rb rebase // 配置rebase别名git config -l // 列举所有配置 基本命令12git init // 创建git仓库git status // 查看文件提交状态 commit1234git commit -amend // 修改注释git commit --amend -m &quot;xxxx&quot; // 修改注释git commit -m &quot;xxxx&quot; // 提交文件(暂存区-&gt;本地仓库)git merge --squash branchname //将多次提交合并成一个，然后git add . (等步骤) diff123456789git diff filepaht // 比较文件不同 (工作区 vs 暂存区)git diff HEAD filepath // 比较文件不同 (工作区 vs HEAD[当前工作分支])git diff --staged filepath // 比较文件不同 (暂存区 vs HEAD[当前工作分支])git diff --cached filepath // 比较文件不同 (暂存区 vs HEAD[当前工作分支])git diff branchname filepath // 比较文件不同 (当前分支文件 vs branchname 分支文件)git diff commitid filepath // 比较文件不同 (与某次提交进行比较)git diff commitid1 commitid2 // 比较两次提交间的不同git diff branch1..branch2 // 比较两个分支git diff --stat // 仅比较统计信息 checkout12git checkout -- filepath // 抛弃工作区对此文件的修改git checkout . // 抛弃工作区修改 工作区123git rm filename1 filename2 // 删除工作区文件，并且将这次删除放入暂存区git rm --cached filename // 停止追踪指定文件，但该文件会保留在工作区git fetch --all // 刷新工作区 暂存区12git reset HEAD // 清空暂存区git rm --cached &lt;file&gt; // 从暂存区删除一个文件 工作区 -&gt; 暂存区1234git add fileName // 添加指定文件(工作区-&gt;暂存区)git add . // 添加所有已更改文件(工作区-&gt;暂存区)git add *.js // 添加所有后缀为js的文件到暂存区git add filename -f // 强行添加一个不被版本跟踪的文件 重置/撤销 reset revert123456789101112131415161718暂存区 -&gt; 工作区 ??git reset filename // 暂存区-&gt;工作区,工作区不变git reset -- . // 暂存区全部文件 -&gt; 工作区git reset --hard // 重置暂存区和工作区，与上一次commit保持一致git reset [commit] // 重置当前分支的指针为指定commit,同时重置暂存区，工作区不变git reset --hard [commit] // 重置当前分支的HEAD为指定commit,同时重置暂存区和工作区，与指定commit一致git reset --keep [commit] // 重置当前HEAD为指定commit,但暂存区和工作区不变git revert [commit] // 新建一个commit,用来撤销指定commit(假回滚)git revert HEAD // 恢复到最后一次提交的状态git reset -hard commitid // 回滚到xx时的状态git reset -soft commitid // 会将之前的修改全部进行revertgit reset –mixed // 此为默认方式，不带任何参数的git reset，即时这种方式，它回退到某个版本，只保留源码，回退commit和index信息git reset –soft // 回退到某个版本，只回退了commit的信息，不会恢复到index file一级。如果还要提交，直接commit即可git reset –hard // 彻底回退到某个版本，本地的源码也会变为上一个版本的内容git reset &lt;commit&gt; --soft --hard：--soft // 将所有被更改的文件回溯到“待提交”状态--hard // commit 之后，对被git追踪的文件的任何更改都被丢弃 查看提交记录12345git log filepath // 查看该文件每次提交记录git log // 查看提交记录git log -p filepath // 查看每次详细修改内容的diffgit log -p -2 // 查看最近两次详细修改内容的diffgit log --stat // 查看提交统计信息 分支1234567891011121314151617181920212223242526272829303132333435git branch -l // 查看本地分支git branch -r // 查看远程分支git branch branchname // 创建新分支git branch -v // 查看各个分支最后提交信息git branch --merged // 查看已经被合并到当前分支的分支git branch --no-merged // 查看尚未被合并到当前分支的分支git checkout branchname // 切换到此分支git checkout -b branchname // 创建新的分支，并切换到新分支git checkout -b [newbranch] [refbranch] // 基于refbranch分支，创建新分支，并切换git checkout commitid // 把某次历史提交记录checkout出来，但无分支信息，却环岛其他分支会自动删除git checkout commitid -b branchname // 把某次历史提交记录checkout,创建成一个新分支git branch -d branchname // 删除某个分支git branch -D branchname // 强制删除某个分支(未被合并的分支被删除的时候需要强制)git checkout -f branchname // 强制切换分支git checkout -f branchname // 强制checkout分支覆盖本地文件分支合并git merge branchname // 将branch分支合并到当前分支git merge --no-ff branchname // 不要fast-foward合并，这样可以生成merge提交git rebase master branchname // 将master合并到branch,相当于：git checkout branchname &amp;&amp; git rebase master &amp;&amp; git checkout master &amp;&amp; git merge branchname远程分支管理git pull // 抓取远程仓库所有分支更新合并到本地git pull --no-ff // 不要fast-foward合并，抓取远程仓库所有分支更新合并到本地git fetch origin // 抓取远程仓库更新git merge origin/master // 远程master分支 合并到 本地当前分支git checkout --track origin/branchname // 跟踪此远程分支，创建相应的本地分支git push // push所有分支git push origin master // push 本地分支 -&gt; 远程master分支git push -u origin master // push 本地分支 -&gt; 远程master分支 (当无远程master分支则创建，用于初始化远程仓库)git push origin &lt;local_branch&gt; // 创建远程分支(与本地分支同名)git push origin &lt;local_branch&gt;:&lt;remote_branch&gt; // 创建远程分支git push origin :&lt;remote_branch&gt; // 删除本地分支，再删除远程分支git checkout -b branchname -t origin/master //基于远程master分支创建branchname分支 远程仓库1234git remote -v // 查看远端地址git remote add origin https://gitxxxxxx.git // 要求服务已经建立同名仓库git remote // 显示远程仓库git remote show origin // 显示origin远程库的详情 tag123456789git tag // 查看taggit tag tagname // 创建一个taggit push --tags // 将本地tags推送到远程仓库git push tagname // 推送指定的本地tag到远程仓库git describe --tags --abbrev=0 // 展示当前分支的最近的taggit push origin --tags // 一次性推送所有tag,同步到远程仓库git tag -d tagname // 删除本地仓库taggit push origin :refs/tags/tagname // 删除远程tag,前提是需要先删除本地taggit checkout -b brachname tagname // 切回到某个tag 其他123456git reflog #输出详细的操作历史~/.gitconfig #用户的git配置文件目录gitk --all &amp; #打开git图形化界面git chean -f #删除工作目录中不被git进行版本追踪的文件git clean -xf #删除当前目录下没有被track过的文件和文件夹.gitignore #告诉git,哪些文件不被加入版本控制]]></content>
      <categories>
        <category>git</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
</search>
